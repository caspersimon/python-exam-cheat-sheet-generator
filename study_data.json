{
  "meta": {
    "course": "Introduction to Python",
    "description": "Structured study data for midterm exam preparation. Contains lecture concepts, notebook code examples, and exam questions with answers from all available practice materials.",
    "weeks_covered": [
      1,
      2,
      3
    ],
    "sources": [
      "Lecture Week 1.md",
      "Lecture Week 2.md",
      "Lecture Week 3.md",
      "Notebook Week 1.ipynb",
      "Notebook Week 2.ipynb",
      "Notebook Week 3.ipynb",
      "trial midterm.pdf",
      "2023.pdf",
      "2024.pdf",
      "Midterm Extra Practice.txt"
    ]
  },
  "lectures": [
    {
      "week": 1,
      "topics": [
        "What is Python",
        "Objects",
        "Types",
        "Assignment statements",
        "Names",
        "Arithmetic operators",
        "Comparison operators",
        "Boolean operators",
        "Mutable vs immutable",
        "Indexing",
        "Slicing",
        "Range",
        "Functions intro",
        "Importing packages"
      ],
      "concepts": [
        {
          "topic": "Python execution model",
          "explanation": "Python script is translated line by line into byte code, then byte code is translated into machine code. Writing code must be precise; ambiguities that humans handle fine will cause Python errors.",
          "week": 1
        },
        {
          "topic": "Objects: core properties",
          "explanation": "Every object has exactly one unique id (cannot change), exactly one type (cannot change), and exactly one value. The type defines what value can be stored and whether the value is mutable or immutable. An object can have zero, one, or more names bound to it. A name can only refer to one object at any time.",
          "week": 1
        },
        {
          "topic": "Mutable vs immutable types",
          "explanation": "Immutable: int, float, str, bool, tuple. Mutable: list, dict, set. The value of a mutable object CAN be changed in-place. The value of an immutable object CANNOT be changed — a new object must be created.",
          "week": 1,
          "code_examples": [
            {
              "description": "List is mutable — can change element in place",
              "code": "l1 = [1, 2, 3]\nprint(l1)      # [1, 2, 3]\nl1[2] = 4\nprint(l1)      # [1, 2, 4]"
            },
            {
              "description": "Tuple is immutable — assigning to index raises TypeError",
              "code": "t1 = (1, 2, 3)\nt1[2] = 4\n# TypeError: 'tuple' object does not support item assignment"
            },
            {
              "description": "String reassignment creates a NEW object, not mutation",
              "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)  # False — different object"
            }
          ]
        },
        {
          "topic": "Assignment statements — reading right to left",
          "explanation": "Python creates a new object with the value on the right, infers type from the value, then binds the name on the left to that object.",
          "week": 1,
          "code_examples": [
            {
              "description": "Basic assignment",
              "code": "name_1 = 300\nprint(name_1)        # 300\nprint(type(name_1))  # <class 'int'>\nprint(id(name_1))    # some unique integer"
            },
            {
              "description": "Two names bound to the same object (same id)",
              "code": "name_3 = name_4 = name_5 = name_6 = 300\nprint(name_3 is name_4 is name_5 is name_6)  # True"
            },
            {
              "description": "Two separate objects with equal value (different id)",
              "code": "name_1 = 300\nname_2 = 300\nprint(name_1 == name_2)           # True (same value)\nprint(id(name_1) != id(name_2))   # True (different objects)"
            }
          ]
        },
        {
          "topic": "Object types — the 8 types to know",
          "explanation": "int, float, str, bool, tuple, list, dict, set",
          "week": 1,
          "code_examples": [
            {
              "description": "All 8 types",
              "code": "var_1 = 123              # int\nvar_2 = 123.3            # float\nvar_3 = '123'            # str\nvar_4 = True             # bool\nvar_5 = ('123', 123)     # tuple\nvar_6 = [123, '123']     # list\nvar_7 = {'k1': 'v1'}     # dict\nvar_8 = {123, '123'}     # set"
            }
          ]
        },
        {
          "topic": "Names / variable naming rules",
          "explanation": "Names can consist of letters (upper/lower), digits, and underscores. Names CANNOT start with a digit. Names ARE case-sensitive (name_1 != Name_1). Avoid Python reserved words (e.g., don't name a variable 'sorted', 'list', 'print').",
          "week": 1
        },
        {
          "topic": "Arithmetic operators",
          "explanation": "a+b, a-b, a*b: standard. a/b: always returns float. a//b: floor division (highest integer <= result). a%b: remainder. a**b: exponentiation. NOTE: ^ is NOT exponentiation in Python (it is XOR). (a//b)*b + a%b == a always.",
          "week": 1,
          "code_examples": [
            {
              "description": "Floor division and modulo",
              "code": "print(5 // 3, 5 % 3)    # 1 2\nprint(-5 // 3, -5 % 3)  # -2 1\nprint(5 // 2, 5 % 2)    # 2 1\nprint(-5 // 2, -5 % 2)  # -3 1"
            }
          ]
        },
        {
          "topic": "Comparison operators",
          "explanation": "==, !=, >, <, >=, <=. Always return True or False. Comparing floats can be tricky: 1.1+2.2 != 3.3 in Python due to floating-point precision. String/tuple/list comparison is element-by-element left to right; first differing element decides; if equal length and no differences, they are equal; shorter sequence is 'less than' longer if all elements match up to shorter length.",
          "week": 1,
          "code_examples": [
            {
              "description": "Float precision issue",
              "code": "print(1.1 + 2.2 == 3.3)  # False"
            },
            {
              "description": "List/tuple comparison",
              "code": "print([1, 2, 3] < [1, 2, 3, 0])  # True (shorter is less)\nprint([2] < [1, 2, 3, 0])        # False (2 > 1 at index 0)"
            }
          ]
        },
        {
          "topic": "Boolean operators",
          "explanation": "x and y: True only if both True. x or y: False only if both False. not x: inverts. NOTE: && and || are Python operators but do something different (bitwise). Precedence: 'not' first, then 'and', then 'or'. Use parentheses to avoid confusion.",
          "week": 1,
          "code_examples": [
            {
              "description": "Precedence trap",
              "code": "a=1; b=3\nprint(a==1 or a==2 and b==1 or b==2)  # True (WRONG: and binds tighter)\nprint((a==1 or a==2) and (b==1 or b==2))  # False (CORRECT)"
            }
          ]
        },
        {
          "topic": "Indexing",
          "explanation": "Forward: 0, 1, 2, ... len-1. Backward: -1 (last), -2 (second to last), ..., -len (first). l1[0] == l1[-len(l1)]",
          "week": 1
        },
        {
          "topic": "Slicing",
          "explanation": "Syntax: seq[start:end:step]. Start is inclusive, end is NOT inclusive. Defaults: start=0, end=len, step=1. Negative step goes from right to left. Slicing always creates a NEW object of the same type.",
          "week": 1,
          "code_examples": [
            {
              "description": "Basic slicing examples",
              "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[7])       # 8\nprint(l1[-1])      # 8\nprint(l1[-5:5])    # [4, 5]\nprint(l1[:-5])     # [1, 2, 3]"
            },
            {
              "description": "Negative step",
              "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[5:1:-2])  # [6, 4]\nprint(l1[5::-1])   # [6, 5, 4, 3, 2, 1]\nprint(l1[:1:-1])   # [8, 7, 6, 5, 4, 3]\nprint(l1[1:5:-2])  # [] (already past end)"
            },
            {
              "description": "Slice reversal",
              "code": "l1 = [1, 2, 3, 4]\nprint(l1[::-1])    # [4, 3, 2, 1]"
            },
            {
              "description": "Slicing creates new object — key exam trap",
              "code": "l1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)  # True False (l3 is independent copy)"
            },
            {
              "description": "Changing a list slice vs index",
              "code": "l1 = [1, 2, 3, 4, 5, 6]\nl1[1:2] = [1, 1]      # replaces element at index 1 with two elements\nprint(l1)             # [1, 1, 1, 3, 4, 5, 6]\n\nl1 = [1, 2, 3, 4, 5, 6]\nl1[1] = [1, 1]        # replaces element at index 1 with a list\nprint(l1)             # [1, [1, 1], 3, 4, 5, 6]"
            },
            {
              "description": "Slicing strings and tuples",
              "code": "t1 = (1, 2, 3)\nprint(t1[1:])          # (2, 3)\ns1 = 'uva Amsterdam'\nprint(s1[5:-3:2])      # 'mtr'"
            },
            {
              "description": "Changing string/tuple (must create new object)",
              "code": "s1 = 'uva Amsterdam'\n# s1[6] = 's'  # ERROR\ns1 = s1[:6] + 's' + s1[7:]\nprint(s1)  # works\n\nt1 = (1, 4, 3)\n# t1[1] = 2  # ERROR\nt1 = t1[:1] + (2,) + t1[2:]\nprint(t1)  # works"
            }
          ]
        },
        {
          "topic": "range()",
          "explanation": "range(start, stop, step). start default=0, step default=1. Stop is NOT inclusive. Works like slicing but defaults differ slightly.",
          "week": 1,
          "code_examples": [
            {
              "description": "range examples",
              "code": "print(list(range(6)))      # [0, 1, 2, 3, 4, 5]\nprint(list(range(3,6)))    # [3, 4, 5]\nprint(list(range(3,6,2)))  # [3, 5]"
            }
          ]
        },
        {
          "topic": "Functions — basics",
          "explanation": "Functions are objects. Defined with def. Called with (). Built-in functions: print, id, len, type, del. Functions can return values. Methods are functions attached to objects.",
          "week": 1,
          "code_examples": [
            {
              "description": "Simple function",
              "code": "def size(length, width):\n    return length * width\nprint(size(2,3))  # 6"
            }
          ]
        },
        {
          "topic": "Importing packages",
          "explanation": "Multiple import styles. 'import X' makes X available. 'import X as Y' renames. 'from X import Z' brings Z directly into namespace. 'from X import Z as W' renames. Once you use 'as', the original name is no longer accessible.",
          "week": 1,
          "code_examples": [
            {
              "description": "Import styles",
              "code": "import numpy\nnumpy.random.randint(1, 10)  # works\n\nimport numpy as np\nnp.random.randint(1, 10)     # works\nnumpy.random.randint(1, 10)  # ERROR\n\nfrom numpy.random import randint\nrandint(1, 10)               # works\n\nfrom numpy.random import randint as rnd\nrnd(1, 10)                   # works\nrandint(1, 10)               # ERROR"
            }
          ]
        },
        {
          "topic": "Exam question types",
          "explanation": "Which code fragment will print the following output? / What will be printed by the following code fragment? / Which code fragment prints the SAME output as...? / One fragment prints different output from the others. / Which correctly solves the problem? Options may include: 'None of the above', 'Both', 'All', 'An error'.",
          "week": 1
        }
      ],
      "lecture_questions": [
        {
          "question": "Which of the following statements is correct? I: Two objects can have different values, while having the same type. II: Two objects can have the same value, while having different types.",
          "options": {
            "a": "I is correct",
            "b": "II is correct",
            "c": "I and II are both correct",
            "d": "Neither is correct"
          },
          "correct": "a",
          "explanation": "I is correct (e.g. a=1, b=2, both int). II is incorrect — if two objects have the same value they must have the same type.",
          "week": 1,
          "topic": "Objects/types"
        },
        {
          "question": "Why does the following code work even though strings are immutable?\nbox_1 = 'content'\nbox_1 = 'new content'",
          "correct_answer": "We didn't change the object — we created a new object with 'new content' and gave the name box_1 to that new object. The old object is garbage collected.",
          "week": 1,
          "topic": "Immutability/names"
        },
        {
          "question": "What is the result of (a//b)*b + a%b?",
          "correct_answer": "a — this is always true by definition of floor division and modulo.",
          "week": 1,
          "topic": "Arithmetic operators"
        },
        {
          "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)",
          "correct_answer": "True False — l2 is the same object as l1 (so l2[-1] is also 5), but l3 is a new object from slicing, so it still holds [1,2,3,4].",
          "week": 1,
          "topic": "Slicing / mutability"
        },
        {
          "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nprint(l1[::-1])",
          "correct_answer": "[4, 3, 2, 1]",
          "week": 1,
          "topic": "Slicing negative step"
        }
      ]
    },
    {
      "week": 2,
      "topics": [
        "Augmented assignment operators",
        "Dictionaries",
        "Lists",
        "Sets",
        "Conditions",
        "Boolean operators / precedence",
        "Conditional statements",
        "Conditional expressions",
        "For-loops",
        "While-loops",
        "Walrus operator",
        "Looping over dicts (keys/values/items)",
        "enumerate()",
        "zip()",
        "Type conversion",
        "Truthy and Falsy"
      ],
      "concepts": [
        {
          "topic": "Augmented assignment operators",
          "explanation": "Shorthand for a = a OP b. All arithmetic operators have an augmented form.",
          "week": 2,
          "code_examples": [
            {
              "description": "All augmented operators",
              "code": "a += 1   # a = a + 1\na -= 2   # a = a - 2\na *= 3   # a = a * 3\na /= 4   # a = a / 4\na //= 5  # a = a // 5\na %= 6   # a = a % 6"
            }
          ]
        },
        {
          "topic": "Dictionaries",
          "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' — this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
          "week": 2,
          "code_examples": [
            {
              "description": "Creating and using dicts",
              "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
            },
            {
              "description": "Dict membership checks KEYS, not values",
              "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
            },
            {
              "description": "Creating dict from two lists",
              "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
            },
            {
              "description": "Dict equality ignores order",
              "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
            }
          ]
        },
        {
          "topic": "Lists vs Dictionaries vs Sets — ordered/unordered",
          "explanation": "Lists, tuples, strings are SEQUENCES (ordered). Dicts and sets are NOT sequences (unordered for equality). All are called collections.",
          "week": 2,
          "code_examples": [
            {
              "description": "Ordering comparison",
              "code": "print([1,2] == [2,1])        # False (ordered)\nprint((1,2) == (2,1))        # False (ordered)\nprint('12' == '21')          # False (ordered)\nprint({1,2} == {2,1})        # True  (unordered)\nprint({1:1,2:2}=={2:2,1:1})  # True  (unordered)"
            }
          ]
        },
        {
          "topic": "Sets",
          "explanation": "Unordered collection of unique values. Empty set MUST be set() — {} creates empty dict. Elements must be immutable. No indexing. Methods: .add(), .remove(), .update().",
          "week": 2,
          "code_examples": [
            {
              "description": "Set operations",
              "code": "countries = set()           # empty set (NOT {})\ncountries = {'Andorra', 'Belgium'}\nprint({1,2,2} == {2,1})     # True (duplicates ignored)\nprint(len({1,2,2}))         # 2\ncountries.remove('Andorra')\ncountries.add('Greece')\ncountries.update({'Spain', 'Italy'})"
            }
          ]
        },
        {
          "topic": "Conditions and boolean operators — precedence",
          "explanation": "Precedence (high to low): comparisons → not → and → or. Use parentheses to be explicit. 'in' checks membership in sequence/set/dict-keys.",
          "week": 2,
          "code_examples": [
            {
              "description": "Precedence trap",
              "code": "a=1; b=3\n# WRONG: Python evaluates 'and' before 'or'\nprint(a==1 or a==2 and b==1 or b==2)     # True (unexpected)\n# CORRECT: use brackets\nprint((a==1 or a==2) and (b==1 or b==2)) # False"
            },
            {
              "description": "Inclusion check — 'in' operator",
              "code": "print(1 in [1,2,3])    # True\nprint(1 in (1,2,3))    # True\nprint('1' in '123')    # True (substring)\nprint(1 in {1:4, 2:3}) # True (checks keys)\nprint(4 in {1:4, 2:3}) # False (4 is value, not key)\nprint(1 in {1,2,3})    # True"
            }
          ]
        },
        {
          "topic": "Conditional statements and expressions",
          "explanation": "if/elif/else. One if at start, at most one else at end, unlimited elif in between. Indentation is critical — all code in a block must have same indentation. Conditional expression (ternary): value_if_true if condition else value_if_false.",
          "week": 2,
          "code_examples": [
            {
              "description": "if/elif/else structure",
              "code": "if condition_1:\n    expression_1\nelif condition_2:\n    expression_2\n    expression_3\nelse:\n    expression_4"
            },
            {
              "description": "Conditional expression (ternary)",
              "code": "# Statement form:\nif a > 0:\n    b = a\nelse:\n    b = 0\n# Expression form:\nb = a if a > 0 else 0\n# Even simpler:\nb = max(0, a)"
            }
          ]
        },
        {
          "topic": "For-loops",
          "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
          "week": 2,
          "code_examples": [
            {
              "description": "For-loop with continue",
              "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
            },
            {
              "description": "Loop variable not used — use _",
              "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
            }
          ]
        },
        {
          "topic": "Looping over dictionaries",
          "explanation": ".keys() → key sequence. .values() → value sequence. .items() → sequence of (key, value) tuples. 'for key in dict' is the same as 'for key in dict.keys()'.",
          "week": 2,
          "code_examples": [
            {
              "description": "Looping over dict",
              "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\n# These two are equivalent:\nfor key in capitals:\nfor key in capitals.keys():"
            }
          ]
        },
        {
          "topic": "enumerate()",
          "explanation": "Provides index alongside value when looping. enumerate(seq, start) — second arg sets the start index (default 0).",
          "week": 2,
          "code_examples": [
            {
              "description": "enumerate with start=1",
              "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
            }
          ]
        },
        {
          "topic": "zip()",
          "explanation": "Loops over multiple sequences in parallel. Zips sequences of equal length (Python handles unequal lengths but it can be messy). Can zip sequences of different types. Can zip more than 2.",
          "week": 2,
          "code_examples": [
            {
              "description": "zip two lists",
              "code": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(country, 'has capital:', capital)"
            }
          ]
        },
        {
          "topic": "While-loops",
          "explanation": "while condition: expression. Checks condition BEFORE each execution. Use break and continue. Watch for infinite loops (Ctrl+C to exit). Use when you don't know beforehand how many iterations are needed. For-loops can always be replaced by while-loops.",
          "week": 2,
          "code_examples": [
            {
              "description": "While with break/continue",
              "code": "total = 0\nwhile True:\n    number = int(input('give a number, or 100 to stop '))\n    if number == 100:\n        break\n    if number % 2 == 0:\n        continue\n    total += number\nprint(total)"
            },
            {
              "description": "Truthy/Falsy in while condition",
              "code": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:           # truthy while list is non-empty\n    total += l1[0]\n    del l1[0]\nprint(total)        # 21"
            }
          ]
        },
        {
          "topic": "Walrus operator :=",
          "explanation": "Introduced in Python 3.8. Assigns AND evaluates to a value (unlike = which is a statement). Useful in while conditions to assign and test at once.",
          "week": 2,
          "code_examples": [
            {
              "description": "Walrus in while loop",
              "code": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100:\n    if number % 2 == 1:\n        total += number\nprint(total)"
            }
          ]
        },
        {
          "topic": "Truthy and Falsy",
          "explanation": "In conditions, Python auto-converts to bool. Falsy: [], (), {}, set(), '', 0, 0.0, range(0), None. Truthy: everything else (non-empty collections, non-zero numbers).",
          "week": 2,
          "code_examples": [
            {
              "description": "Falsy values",
              "code": "# All evaluate to False in a condition:\n[]    # empty list\n()    # empty tuple\n{}    # empty dict\nset() # empty set\n''    # empty string\n0     # zero int\n0.0   # zero float"
            }
          ]
        },
        {
          "topic": "Type conversion (explicit)",
          "explanation": "Python requires explicit conversion in most cases (unlike JavaScript). Conversion functions: str(), int(), float(), bool(), tuple(), list(), set(), dict().",
          "week": 2,
          "code_examples": [
            {
              "description": "Explicit conversions",
              "code": "print(str(1) == '1')           # True\nprint(int('1') == 1)           # True\nprint(int('1a'))               # ERROR\nprint(float('1') == 1.0)       # True\nprint(float('1.0') == 1.0)     # True\nprint(tuple([1,2,3]) == (1,2,3)) # True\nprint(tuple({1:3, 2:4}) == (1,2)) # True (dict->tuple gives keys)\nprint(list(range(1,5,2)) == [1,3]) # True\nprint(dict([1, 2]))            # ERROR\nprint(dict([(1,3),(2,4)]) == {1:3, 2:4})  # True"
            },
            {
              "description": "Implicit conversion (Python allows with bool/numeric mix)",
              "code": "print(1 + True)    # 2\nprint(1.0 + False) # 1.0\nprint('1' * 2)     # '11'\nprint('1' * True)  # '1'\nprint('1' * False) # ''"
            }
          ]
        }
      ],
      "lecture_questions": [
        {
          "question": "What does the following program do?\nX = X + Y\nY = X - Y\nX = X - Y",
          "correct_answer": "It swaps the values of X and Y. If X=1, Y=2: after step 1 X=3, step 2 Y=1, step 3 X=2.",
          "week": 2,
          "topic": "Variable swap / tracing code"
        }
      ]
    },
    {
      "week": 3,
      "topics": [
        "Function definitions",
        "Calling functions",
        "Return statements",
        "Implicit return (None)",
        "Multiple return values",
        "Global and local names / scope",
        "Positional arguments",
        "*args",
        "**kwargs",
        "Keyword arguments",
        "Default arguments",
        "Mutable argument problem",
        "Mutable default problem",
        "Nested functions",
        "Function factories",
        "Lambda functions",
        "map()",
        "filter()",
        "reduce()",
        "sorted() with key",
        "pass",
        "Nested for-loops"
      ],
      "concepts": [
        {
          "topic": "Function definition and calling",
          "explanation": "def keyword, function name, parameters in parentheses, colon, indented body. Call with round brackets (). Using [] gives TypeError 'not subscriptable'. Using [] on a list with () gives TypeError 'not callable'.",
          "week": 3,
          "code_examples": [
            {
              "description": "Basic function",
              "code": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)  # 3"
            },
            {
              "description": "Wrong bracket errors",
              "code": "print[1]   # TypeError: 'function' object is not subscriptable\nl1 = [1,2,3]\nl1(1)      # TypeError: 'list' object is not callable"
            }
          ]
        },
        {
          "topic": "Return statement",
          "explanation": "Returns a value to the caller. If you don't capture the return value it's lost. A function leaves no traces — local names are gone after function ends. Common error: using print() instead of return in homework functions.",
          "week": 3,
          "code_examples": [
            {
              "description": "Returning a tuple (multiple values)",
              "code": "def powers(n1):\n    return n1 ** 2, n1 ** 3  # returns a tuple\npower2, power3 = powers(3)\nprint(power2, power3)  # 9 27"
            }
          ]
        },
        {
          "topic": "Implicit return — None",
          "explanation": "If a function reaches the end without a return statement, Python returns None automatically. This is bad practice but you must know it. Test with: if a != None:  or  if a is not None:",
          "week": 3,
          "code_examples": [
            {
              "description": "Implicit None return",
              "code": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)  # Returns None (no return hit)\nprint(a)           # None"
            }
          ]
        },
        {
          "topic": "Single-element tuple",
          "explanation": "(1) is NOT a tuple — it's just the integer 1. To create a 1-element tuple: t = (1,) or t = 1,. Neat swap trick: x, y = y, x",
          "week": 3,
          "code_examples": [
            {
              "description": "1-element tuple gotcha",
              "code": "t1 = (1)\nprint(type(t1) == tuple)  # False\nprint(type(t1) == int)    # True\nt1 = (1,)  # correct 1-element tuple\nt1 = 1,    # also correct\nx, y = y, x  # swap using tuple unpacking"
            }
          ]
        },
        {
          "topic": "pass keyword",
          "explanation": "Does nothing. Used as a placeholder when an indented block is required but you have nothing to put there yet (stub). After a colon you must have an indented block — pass satisfies this.",
          "week": 3,
          "code_examples": [
            {
              "description": "pass as stub",
              "code": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else:\n        pass  # placeholder — won't cause IndentationError\n    return result"
            }
          ]
        },
        {
          "topic": "Global and local scope",
          "explanation": "Local names: defined inside a function (parameter names + any assignment inside). Only known inside the function. Global names: defined outside any function, known everywhere EXCEPT when a same-named local exists (local dominates). Python makes names local at call time, BEFORE executing the body — so if you assign to a name ANYWHERE in a function, that name is local throughout the function (even before the assignment line). Use 'global' keyword to override (but avoid it).",
          "week": 3,
          "code_examples": [
            {
              "description": "Local name not accessible outside",
              "code": "def adder(n1, n2):\n    return n1 + n2\nadder(1, 2)\nprint(n1)  # NameError: name 'n1' is not defined"
            },
            {
              "description": "UnboundLocalError trap — local shadows global even before assignment",
              "code": "def main(a):\n    b = b      # ERROR: Python sees b assigned in function -> local\n    return a   # but local b has no value yet\nb = 1\nprint(main(1))  # UnboundLocalError"
            },
            {
              "description": "global keyword",
              "code": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)  # 2"
            },
            {
              "description": "Better pattern: avoid global",
              "code": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)  # 2"
            },
            {
              "description": "Mutable parameter is the SAME object",
              "code": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')  # The sum of [] = 15 !!!\n# l1 is empty because l2 and l1 refer to the SAME list object"
            },
            {
              "description": "Fix: copy mutable arg at start of function",
              "code": "def adder(l2):\n    l2 = l2[:]   # make a copy\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result"
            }
          ]
        },
        {
          "topic": "*args — undefined number of positional arguments",
          "explanation": "Prefixing a parameter with * makes Python collect all extra positional arguments into a tuple named args. Can mix with defined parameters: def f(n1, n2, *args) — Python fills n1,n2 first then collects remainder into args.",
          "week": 3,
          "code_examples": [
            {
              "description": "*args usage",
              "code": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
            },
            {
              "description": "Mix defined and *args",
              "code": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
            }
          ]
        },
        {
          "topic": "Keyword arguments and **kwargs",
          "explanation": "Arguments can be passed by name (keyword). **kwargs collects undefined keyword arguments into a dict. Order in function definition: positional, *args, keyword-with-defaults, **kwargs.",
          "week": 3,
          "code_examples": [
            {
              "description": "Keyword arguments",
              "code": "def calc(first, second, third, fourth, fifth, sixth):\n    return first + 2*second + 3*third + 4*fourth + 5*fifth + 6*sixth\nprint(calc(fifth=2, third=4, fourth=1, sixth=5, second=2, first=3))  # 63"
            },
            {
              "description": "**kwargs",
              "code": "def calc(**kwargs):\n    return kwargs['first'] + 2*kwargs['second'] + 3*kwargs['third']\nprint(calc(third=4, second=2, first=3))"
            },
            {
              "description": "Mixed: positional + *args + **kwargs",
              "code": "def calc(first, second, *args, **kwargs):\n    return first + second*2 + args[0]*3 + args[1]*4 + 5*kwargs['fifth'] + 6*kwargs['sixth']\nprint(calc(3, 2, 4, 1, sixth=5, fifth=2))  # 63"
            }
          ]
        },
        {
          "topic": "Default arguments",
          "explanation": "Default values are part of the function HEADER (not the call). When argument is omitted, the default is used. Keyword args in a call use =. CRITICAL: mutable defaults are evaluated ONCE at def time — never use mutable defaults; use None instead.",
          "week": 3,
          "code_examples": [
            {
              "description": "Default value",
              "code": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3))       # 6 (uses default second=2)\nprint(multiplier(3, 3))    # 9\nprint(multiplier(2, second=3))  # 6"
            },
            {
              "description": "Mutable default BUG",
              "code": "def main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [2, 3] ← BUG: l1 persists!"
            },
            {
              "description": "Mutable default FIX — use None",
              "code": "def main(addition, l1=None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [3]  ← correct"
            }
          ]
        },
        {
          "topic": "Nested functions and function factories",
          "explanation": "Functions can be defined inside other functions. The inner function is only visible to the outer function. Functions are objects — a function can return another function (factory pattern).",
          "week": 3,
          "code_examples": [
            {
              "description": "Function factory",
              "code": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\nadd4 = function_factory(4)\nadd5 = function_factory(5)\nprint(add4(3))  # 7\nprint(add5(3))  # 8"
            }
          ]
        },
        {
          "topic": "Lambda functions",
          "explanation": "Anonymous one-line functions. Syntax: lambda params: expression. Equivalent to a regular def but more concise. Most useful with map, filter, reduce, sorted, max.",
          "week": 3,
          "code_examples": [
            {
              "description": "Lambda basics",
              "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))  # 3\n# Equivalent to:\ndef add_two(x, y):\n    return x + y"
            },
            {
              "description": "map() with lambda",
              "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))   # [2, 4, 6, 8, 10, 12]\n# Need list() to convert map object to list"
            },
            {
              "description": "filter() with lambda",
              "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))  # [2, 4, 6] (even numbers)"
            },
            {
              "description": "reduce() with lambda",
              "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))  # 720 (product)\n# reduce with initial value:\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))  # 5"
            },
            {
              "description": "sorted() with key lambda",
              "code": "l1 = ['aaa', 'c', 'baab']\nprint(sorted(l1))                              # ['aaa', 'baab', 'c']\nprint(sorted(l1, key=lambda x: x.count('a'))) # ['c', 'baab', 'aaa']\nprint(sorted(l1, key=len))                    # ['c', 'aaa', 'baab']\n\nd = {'a': 2, 'b': 1}\nprint(max(d.items()))                         # ('b', 1)  ← compares tuples\nprint(max(d.items(), key=lambda x: x[1]))     # ('a', 2)  ← by value"
            }
          ]
        },
        {
          "topic": "Methods vs functions",
          "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings — you must do s1 = s1.upper() to save the result.",
          "week": 3,
          "code_examples": [
            {
              "description": "Method on immutable — must capture return value",
              "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT — captures new string\ns1.upper()       # WRONG — result is lost, s1 unchanged"
            },
            {
              "description": "Method on mutable — changes in place vs returns value",
              "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
            }
          ]
        }
      ],
      "lecture_questions": [
        {
          "question": "What is the result of:\ndef main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))\nprint(main(3))",
          "correct_answer": "[2]\n[2, 3]\nBecause the default [] is created once at def time and mutated each call.",
          "week": 3,
          "topic": "Mutable default argument"
        },
        {
          "question": "What is the result of:\ndef adder(l2):\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1,2,3,4,5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')",
          "correct_answer": "The sum of [] = 15 — because l1 and l2 point to the same mutable object, so popping from l2 empties l1.",
          "week": 3,
          "topic": "Mutable arguments"
        },
        {
          "question": "What will be printed?\nx = [5,10,15,20]; a=4; b=9; c=13; d=15\ncats=[]\nfor el in x:\n    if el>a: cats.append('cat1')\n    elif el<b: cats.append('cat2')\n    elif el<=c: cats.append('cat3')\n    elif el>=d: cats.append('cat4')\n    else: cats.append('catunknown')\nprint(cats)",
          "correct_answer": "['cat1','cat1','cat1','cat1'] — all elements > a=4, so they all match the first condition and never reach others.",
          "week": 3,
          "topic": "if/elif priority"
        }
      ]
    }
  ],
  "notebooks": [
    {
      "cell_index": 0,
      "week": 1,
      "cell_type": "markdown",
      "topic": "intro",
      "is_advanced_optional": false,
      "source": "### Python code is only readable for human beings",
      "outputs": []
    },
    {
      "cell_index": 1,
      "week": 1,
      "cell_type": "code",
      "topic": "intro",
      "is_advanced_optional": false,
      "source": "print('Hello World')",
      "outputs": []
    },
    {
      "cell_index": 2,
      "week": 1,
      "cell_type": "markdown",
      "topic": "intro",
      "is_advanced_optional": false,
      "source": "### Print is a function and tells Python to output the argument (that what is between the brackets after the function name) on your screen\n<ul><li>A function is a grouping of code that can perform a certain task and can be re-used \n</li><li>Print is a built-in function, that is a function that is part of the standard implementation of Python. Built-in fuctions like any function, can be used by calling their name. Built-in functions are already copied to your computer and the names of some of them like print, don't need to be imported\n<li>User functions are functions defined by you or other people that are not part of the standard Python implementation. (You will learn how to write your own functions in week 3 of the course)\n<li>You can extend Python by copying functions and other objects that are not part of the standard implementation to a certain place on your computer or in the cloud where you run Python\n<li>If you want to use these objects that are not part of the standard implementation, in your program, you have to import the names of these objects into your program, after which you can use those names in your program like names you have defined yourself \n<li>For some objects that are part of the standard implementation, you have to import the names of these objects into your program, after which you can use those names in your program like names you have defined yourself \n<li>Objects you created in a program yourself can be used in that program without importing their names\n<li>You will learn about importing names of objects later in this notebook",
      "outputs": []
    },
    {
      "cell_index": 3,
      "week": 1,
      "cell_type": "markdown",
      "topic": "intro",
      "is_advanced_optional": false,
      "source": "### Python code is not directly executable by computers. Computers can only execute machine code. Therefore, Python code must be translated to make it executable for a computer. This is done in two steps, Python code is first translated into byte code. This byte code is the same independent of which computer you run your Python code on. This means that this byte-code must be translated into so called machine code before it can be executed by the computer you use",
      "outputs": []
    },
    {
      "cell_index": 4,
      "week": 1,
      "cell_type": "markdown",
      "topic": "intro",
      "is_advanced_optional": false,
      "source": "### A cell (as the following cell) starting with a line only containing only one # and nothing else, is not part of the exam material, but is still interesting if you want to learn Python",
      "outputs": []
    },
    {
      "cell_index": 5,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>You can actually see the intermediate bytecode if you want",
      "outputs": []
    },
    {
      "cell_index": 6,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nimport dis\ndef func():\n    print('Hello World')\ndis.dis(func)",
      "outputs": []
    },
    {
      "cell_index": 7,
      "week": 1,
      "cell_type": "markdown",
      "topic": "comments",
      "is_advanced_optional": false,
      "source": "### To make Python more readable for human beings, you can add comments to your program.<br>Python doesn't lose any noticable time dealing with your comments",
      "outputs": []
    },
    {
      "cell_index": 8,
      "week": 1,
      "cell_type": "code",
      "topic": "comments",
      "is_advanced_optional": false,
      "source": "# This whole physical line is a comment",
      "outputs": []
    },
    {
      "cell_index": 9,
      "week": 1,
      "cell_type": "code",
      "topic": "comments",
      "is_advanced_optional": false,
      "source": "print('Hello World') # Everything after the hashtag is a comment",
      "outputs": [
        "Hello World"
      ]
    },
    {
      "cell_index": 10,
      "week": 1,
      "cell_type": "code",
      "topic": "comments",
      "is_advanced_optional": false,
      "source": "# This is a \n# multiline comment.",
      "outputs": []
    },
    {
      "cell_index": 11,
      "week": 1,
      "cell_type": "markdown",
      "topic": "objects",
      "is_advanced_optional": false,
      "source": "### Everything in Python is an object. Objects in Python have one id, one value, one type, and zero or more names\n<br>An assignment statement is one of the ways to create an object. An object created with an assignment statement will have a name, an id, a value and a type.\n<br>If you know the name you can ask for the id, the value, and the type",
      "outputs": []
    },
    {
      "cell_index": 12,
      "week": 1,
      "cell_type": "code",
      "topic": "objects",
      "is_advanced_optional": false,
      "source": "a = 1\nprint(id(a))\nprint(a)\nprint(type(a))",
      "outputs": []
    },
    {
      "cell_index": 13,
      "week": 1,
      "cell_type": "markdown",
      "topic": "assignment",
      "is_advanced_optional": false,
      "source": "### Another way to assign names to objects are parallel assignments",
      "outputs": []
    },
    {
      "cell_index": 14,
      "week": 1,
      "cell_type": "code",
      "topic": "assignment",
      "is_advanced_optional": false,
      "source": "a = 100\nb = 200\nc = 300\nd, e, f = a, b, c\nprint(a, b, c)\nprint(d, e, f)",
      "outputs": []
    },
    {
      "cell_index": 15,
      "week": 1,
      "cell_type": "code",
      "topic": "assignment",
      "is_advanced_optional": false,
      "source": "a = 100\nb = 200\nc = 300\nprint(a, b, c)\nb, c, a = a, b, c \nprint(a, b, c)",
      "outputs": []
    },
    {
      "cell_index": 16,
      "week": 1,
      "cell_type": "markdown",
      "topic": "identity_id",
      "is_advanced_optional": false,
      "source": "### An object has exactly one id, if you have two different id's you have two different objects<br>You can compare id's or use the is operator to check whether names refer to the same object",
      "outputs": []
    },
    {
      "cell_index": 17,
      "week": 1,
      "cell_type": "code",
      "topic": "identity_id",
      "is_advanced_optional": false,
      "source": "var_1 = 123\nprint(id(var_1))\nvar_1 = 321\nprint(id(var_1))",
      "outputs": []
    },
    {
      "cell_index": 18,
      "week": 1,
      "cell_type": "code",
      "topic": "identity_id",
      "is_advanced_optional": false,
      "source": "var_1 = 321\nprint(id(var_1))\nvar_2 = 321\nprint(id(var_2))\nprint(var_1 == var_2)\nprint(var_1 is var_2)",
      "outputs": []
    },
    {
      "cell_index": 19,
      "week": 1,
      "cell_type": "markdown",
      "topic": "types",
      "is_advanced_optional": false,
      "source": "### Every object has one type, and types are defined by the value of the object<br>for this course you have to know 8 types",
      "outputs": []
    },
    {
      "cell_index": 20,
      "week": 1,
      "cell_type": "code",
      "topic": "types",
      "is_advanced_optional": false,
      "source": "var_1 = 123\nvar_2 = 123.3\nvar_3 = '123'\nvar_4 = True\nvar_5 = ('123', 123)\nvar_6 = [123, '123']\nvar_7 = {'key_1': 'elem_1', 'key_2': 'elem_2'}\nvar_8 = {123, '123'}\n\nprint(type(var_1))\nprint(type(var_2))\nprint(type(var_3))\nprint(type(var_4))\nprint(type(var_5))\nprint(type(var_6))\nprint(type(var_7)) \nprint(type(var_8))",
      "outputs": []
    },
    {
      "cell_index": 21,
      "week": 1,
      "cell_type": "code",
      "topic": "types",
      "is_advanced_optional": false,
      "source": "var_1 = 123\nvar_2 = 123.3\nvar_3 = '123'\nvar_4 = True\nvar_5 = ('123', 123)\nvar_6 = [123, '123']\nvar_7 = {'key_1': 'elem_1', 'key_2': 'elem_2'}\nvar_8 = {123, '123'}\n\nprint(type(var_1) == int)\nprint(type(var_2) == float)\nprint(type(var_3) == str)\nprint(type(var_4) == bool)\n\nprint(type(var_5) == tuple)\nprint(type(var_6) == list)\nprint(type(var_7) == dict) \nprint(type(var_8) == set)",
      "outputs": []
    },
    {
      "cell_index": 22,
      "week": 1,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "### In certain situations, you can use those type indicators, to create a new object with a different type",
      "outputs": []
    },
    {
      "cell_index": 23,
      "week": 1,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print(int('123'))\nprint(float('123'))\n\nprint(str(123))\nprint(float(123))\n\nprint(int(123.0))\nprint(str(123.0))",
      "outputs": []
    },
    {
      "cell_index": 24,
      "week": 1,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "integer_list = [1, 2, 3, 1]\nletter_list = ['a', 'b', 'c', 'd']\nprint(set(integer_list))\nprint(tuple(integer_list))\nprint(dict(zip(letter_list, integer_list)))\n\ninteger_tuple = (1, 2, 3, 1)\nletter_tuple = ('a', 'b', 'c', 'd')\nprint(set(integer_tuple))\nprint(list(integer_tuple))\nprint(dict(zip(letter_tuple, integer_tuple)))\n\ninteger_set = {1, 2, 3}\nletter_set = {'a', 'b', 'c'}\nprint(list(integer_set))\nprint(tuple(letter_set))\nprint(dict(zip(integer_set, letter_set)))\n\nd_1 = {1: 'c', 2: 'b', 3: 'a'}\nprint(list(d_1))\nprint(tuple(d_1))\nprint(set(d_1))",
      "outputs": []
    },
    {
      "cell_index": 25,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>In case you forgot the right name for a type indicator, there is a neat trick:",
      "outputs": []
    },
    {
      "cell_index": 26,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nvar_1 = 123\nvar_2 = 123.3\nvar_3 = '123'\nvar_4 = True\nvar_5 = ('123', 123)\nvar_6 = [123, '123']\nvar_7 = {'key_1': 'elem_1', 'key_2': 'elem_2'}\nvar_8 = {123, '123'}\n\nprint(type(var_1) == type(0))\nprint(type(var_2) == type(0.0))\nprint(type(var_3) == type(''))\nprint(type(var_4) == type(False))\n\nprint(type(var_5) == type((0,)))\nprint(type(var_6) == type([]))\nprint(type(var_7) == type({})) \nprint(type(var_8) == type(set()))",
      "outputs": []
    },
    {
      "cell_index": 27,
      "week": 1,
      "cell_type": "markdown",
      "topic": "names",
      "is_advanced_optional": false,
      "source": "### Every object has zero or more names. Names can only start with an underscores (_), or a letter. The rest of the name can consist of underscores, digits, and letters. Names can have any length",
      "outputs": []
    },
    {
      "cell_index": 28,
      "week": 1,
      "cell_type": "code",
      "topic": "names",
      "is_advanced_optional": false,
      "source": "var_1 = 100\nvar_2 = var_1\nvar_3 = var_2\nvar_4 = var_1\nprint(id(var_1), id(var_2), id(var_3), id(var_4))\nprint(id(var_1) == id(var_2) == id(var_3) == id(var_4))\nprint(var_1 is var_2 is var_3 is var_4)",
      "outputs": []
    },
    {
      "cell_index": 29,
      "week": 1,
      "cell_type": "markdown",
      "topic": "names",
      "is_advanced_optional": false,
      "source": "### Every name belongs to exactly one object. You only can remove a name from an object by assigning that name to another object or delete the name",
      "outputs": []
    },
    {
      "cell_index": 30,
      "week": 1,
      "cell_type": "code",
      "topic": "names",
      "is_advanced_optional": false,
      "source": "var_1 = 100\nprint(id(var_1))\nvar_1 = 200\nprint(id(var_1))\ndel(var_1)\nprint(id(var_1))",
      "outputs": []
    },
    {
      "cell_index": 31,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>Names can exist of only underscores (_). Inside a notebook these have a special function. They help you to chain cells without having to invent new names",
      "outputs": []
    },
    {
      "cell_index": 32,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n123*1",
      "outputs": []
    },
    {
      "cell_index": 33,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n123*2",
      "outputs": []
    },
    {
      "cell_index": 34,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n123*3",
      "outputs": []
    },
    {
      "cell_index": 35,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nprint(_, __, ___)",
      "outputs": []
    },
    {
      "cell_index": 36,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>In case of some values (small integers and short strings), an assignment statement using that value doesn't create a new object, but creates an extra name for that object if that object already exists.<br>This behavior can be quite unexpected",
      "outputs": []
    },
    {
      "cell_index": 37,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nvar_1 = 1\nvar_2 = 1\nprint(var_1 == var_2)\nprint(var_1 is var_2)\n\nvar_1 = 256\nvar_2 = 256\nprint(var_1 == var_2)\nprint(var_1 is var_2)\n\nvar_1 = 257\nvar_2 = 257\nprint(var_1 == var_2)\nprint(var_1 is var_2)\n\nvar_1 = \"short\"\nvar_2 = \"short\"\nprint(var_1 == var_2)\nprint(var_1 is var_2)\n\nvar_1 = \"Long string\"\nvar_2 = \"Long string\"\nprint(var_1 == var_2)\nprint(var_1 is var_2)",
      "outputs": []
    },
    {
      "cell_index": 38,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>For short strings this so-called interning is standard, but you can force this behavior for other string values",
      "outputs": []
    },
    {
      "cell_index": 39,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nimport sys\nvar_1 = sys.intern(\"Long string\")\nvar_2 = sys.intern(\"Long string\")\nprint(var_1 == var_2)\nprint(var_1 is var_2)",
      "outputs": []
    },
    {
      "cell_index": 40,
      "week": 1,
      "cell_type": "markdown",
      "topic": "arithmetic_operators",
      "is_advanced_optional": false,
      "source": "### Arithmetic operators",
      "outputs": []
    },
    {
      "cell_index": 41,
      "week": 1,
      "cell_type": "code",
      "topic": "arithmetic_operators",
      "is_advanced_optional": false,
      "source": "print(4 + 3)\nprint(4 - 3)\nprint(4 * 3)\nprint(4 / 3)\nprint(4 / 2)\nprint(4 ** 3)",
      "outputs": [
        "7\n1\n12\n1.3333333333333333\n2.0\n64"
      ]
    },
    {
      "cell_index": 42,
      "week": 1,
      "cell_type": "code",
      "topic": "arithmetic_operators",
      "is_advanced_optional": false,
      "source": "print(5 // 3, 5 % 3)\nprint(-5 // 3, -5 % 3)\nprint(5 // 2, 5 % 2)\nprint(-5 // 2, -5 % 2)",
      "outputs": [
        "1 2\n-2 1\n2 1\n-3 1"
      ]
    },
    {
      "cell_index": 43,
      "week": 1,
      "cell_type": "code",
      "topic": "arithmetic_operators",
      "is_advanced_optional": false,
      "source": "print(5//2, 5%2)",
      "outputs": [
        "2 1"
      ]
    },
    {
      "cell_index": 44,
      "week": 1,
      "cell_type": "code",
      "topic": "arithmetic_operators",
      "is_advanced_optional": true,
      "source": "#\nimport random              # The random module that can be used to generate pseudo-random numbers is part of the standard Python installation\n                           # but the name has still to be importent\na = random.randint(3, 9)   # This generates an integer between 3 and 9 (both included), it is given the name 'a'\nb = random.randint(3, 9)   # # This generates an integer between 3 and 9 (both included), it is given the name 'b'\nprint (a, b)\nprint(a==(a/b)*b + a%b)    # == compares what is left of it to what is right of it and evaluates to True if both sides evaluate to the same value",
      "outputs": [
        "8 4\nTrue"
      ]
    },
    {
      "cell_index": 45,
      "week": 1,
      "cell_type": "markdown",
      "topic": "comparison_operators",
      "is_advanced_optional": false,
      "source": "### Comparison operators",
      "outputs": []
    },
    {
      "cell_index": 46,
      "week": 1,
      "cell_type": "code",
      "topic": "comparison_operators",
      "is_advanced_optional": false,
      "source": "print(3 == 2)\nprint(3 > 3)\nprint(3 < 4)\nprint(3 >= 2)\nprint(3 <= 3)\nprint(3 != 4)",
      "outputs": []
    },
    {
      "cell_index": 47,
      "week": 1,
      "cell_type": "code",
      "topic": "comparison_operators",
      "is_advanced_optional": false,
      "source": "print(1.1, 2.2, 1.1 + 2.2 == 3.3)",
      "outputs": []
    },
    {
      "cell_index": 48,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nfrom math import isclose\nprint (isclose(1.1 + 2.2, 3.3))",
      "outputs": []
    },
    {
      "cell_index": 49,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nfrom decimal import Decimal\nprint(Decimal('1.1') + Decimal('2.2'))",
      "outputs": []
    },
    {
      "cell_index": 50,
      "week": 1,
      "cell_type": "code",
      "topic": "comparison_operators",
      "is_advanced_optional": false,
      "source": "print([1, 2, 3] < [1, 2, 3, 0])\nprint([2] < [1, 2, 3, 0])\nprint((1, 2, 3, 0) < (1, 2, 3))\nprint((2,) >= (1, 2, 3, 0))\nprint('abc' < 'abc ')\nprint('b' < 'abc ')\nprint('123' < '123 ')\nprint('2' < '123 ')",
      "outputs": []
    },
    {
      "cell_index": 51,
      "week": 1,
      "cell_type": "markdown",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "### Objects have exactly one value<br>Depending on the type, objects are mutable [imutable], and this means that the value can [cannot] be changed",
      "outputs": []
    },
    {
      "cell_index": 52,
      "week": 1,
      "cell_type": "code",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2)",
      "outputs": []
    },
    {
      "cell_index": 53,
      "week": 1,
      "cell_type": "markdown",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "### Tupples are also immutable, changing a tupple gives an error",
      "outputs": []
    },
    {
      "cell_index": 54,
      "week": 1,
      "cell_type": "code",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
      "outputs": []
    },
    {
      "cell_index": 55,
      "week": 1,
      "cell_type": "markdown",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "### The cleaner way to deal with errors in Python",
      "outputs": []
    },
    {
      "cell_index": 56,
      "week": 1,
      "cell_type": "code",
      "topic": "mutable_immutable",
      "is_advanced_optional": false,
      "source": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
      "outputs": []
    },
    {
      "cell_index": 57,
      "week": 1,
      "cell_type": "markdown",
      "topic": "len_function",
      "is_advanced_optional": false,
      "source": "### built-in len function",
      "outputs": []
    },
    {
      "cell_index": 58,
      "week": 1,
      "cell_type": "code",
      "topic": "len_function",
      "is_advanced_optional": false,
      "source": "print(len(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']))\nprint(len(('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')))\nprint(len({'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'}))\nprint(len({1:'A', 2:'B', 3:'C', 4:'D', 5:'E', 6:'F', 7:'G', 8:'H'}))\nprint(len(('ABCDEFGH')))\ntry:\n    print(len(12345678))\nexcept:\n    print ('Built-in len function cannot be applied on integers or floats')\ntry:\n    print(len(True))\nexcept:\n    print ('Built-in len function cannot be applied on booleans or floats')\nprint(len(str(12345678)))",
      "outputs": []
    },
    {
      "cell_index": 59,
      "week": 1,
      "cell_type": "markdown",
      "topic": "indexing",
      "is_advanced_optional": false,
      "source": "### Indexing",
      "outputs": []
    },
    {
      "cell_index": 60,
      "week": 1,
      "cell_type": "code",
      "topic": "indexing",
      "is_advanced_optional": false,
      "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6] == 'G')\nprint(l1[6] == l1[-2])\nprint(l1[7] == 'H')\nprint(l1[7] == l1[-1])\nprint(l1[len(l1)-1] == l1[-1])\nprint(l1[len(l1)])",
      "outputs": []
    },
    {
      "cell_index": 61,
      "week": 1,
      "cell_type": "markdown",
      "topic": "slicing",
      "is_advanced_optional": false,
      "source": "### Slicing",
      "outputs": []
    },
    {
      "cell_index": 62,
      "week": 1,
      "cell_type": "code",
      "topic": "slicing",
      "is_advanced_optional": false,
      "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6:5])\nprint(l1[6:6])\nprint(l1[6:7])\nprint(l1[6:7] == l1[6])\nprint(l1[6:7][0] == l1[6])\nprint(l1[6:7] == list(l1[6]))",
      "outputs": []
    },
    {
      "cell_index": 63,
      "week": 1,
      "cell_type": "code",
      "topic": "slicing",
      "is_advanced_optional": false,
      "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[1:17])\nprint(l1[16:17])\nprint(l1[:6])\nprint(l1[6:])\nprint(l1[:6] + l1[6:] == l1)\nprint(l1[:] == l1)\nprint(l1[:] is l1)",
      "outputs": []
    },
    {
      "cell_index": 64,
      "week": 1,
      "cell_type": "code",
      "topic": "slicing",
      "is_advanced_optional": false,
      "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[0:6:2])\nprint(l1[1:6:1] == l1[1:6])\nprint(l1[1:6:1] == l1[1:6:])\nprint(l1[0:6:2] == l1[:6:2])\nprint(l1[2:len(l1):2] == l1[2::2])\nprint(l1[0:len(l1):1] == l1[::])",
      "outputs": []
    },
    {
      "cell_index": 65,
      "week": 1,
      "cell_type": "code",
      "topic": "slicing",
      "is_advanced_optional": false,
      "source": "l1 = ['a', 'b']\nl2 = l1\nl2[-1] = 'c'\nprint(l1 == l3)\nl3 = l1[::]\nl3[-1] = 'c'\nprint(l1 == l3)",
      "outputs": []
    },
    {
      "cell_index": 66,
      "week": 1,
      "cell_type": "code",
      "topic": "line_joining",
      "is_advanced_optional": false,
      "source": "a = 'Two or more physical lines can be joined' +\\\n    ' with the help of backward slashes'\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 67,
      "week": 1,
      "cell_type": "code",
      "topic": "line_joining",
      "is_advanced_optional": false,
      "source": "a = ['Two or more physical lines can be joined', \n    ' with the help of backward slashes']\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 68,
      "week": 1,
      "cell_type": "code",
      "topic": "line_joining",
      "is_advanced_optional": false,
      "source": "a = ['Sometimes one can use parts of a logical line inside a',\n     'pair of parentheses, ', \n     'with the help of backward slashes']\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 69,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "### In the following examples you will see the printing of strings.<br>A string is a list of characters in order.<br>A character is anything you can type on the keyboard in one keystroke, like a letter, a number, or a backslash.",
      "outputs": []
    },
    {
      "cell_index": 70,
      "week": 1,
      "cell_type": "code",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "print(\"This is a string\")\nprint('This is another string')",
      "outputs": []
    },
    {
      "cell_index": 71,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>If the last statement in a cell is a print statement, you could just write the value instead of the whole print statement.<br>However, it is probably a good idea to always use print statements, as this trick that works in jupyter notebooks, doesn't work in all other environments",
      "outputs": []
    },
    {
      "cell_index": 72,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n\"This is a string\"\n'This is another string'",
      "outputs": []
    },
    {
      "cell_index": 73,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>You can actually chance the behavior of your notebook, so that you can omit the print keayword anywhere in your notebook",
      "outputs": []
    },
    {
      "cell_index": 74,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"",
      "outputs": []
    },
    {
      "cell_index": 75,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n\"Hello World\"\n'Hello World'",
      "outputs": []
    },
    {
      "cell_index": 76,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"last\"",
      "outputs": []
    },
    {
      "cell_index": 77,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\n\"Hello World\"\n'Hello World'",
      "outputs": []
    },
    {
      "cell_index": 78,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "### You can define an object (an entity containing a value) with an assignment statement",
      "outputs": []
    },
    {
      "cell_index": 79,
      "week": 1,
      "cell_type": "code",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "a = 'This is a string'      \nb = \"This is another string\"",
      "outputs": []
    },
    {
      "cell_index": 80,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "### You can use a function by passing values (or objects containing a value) to it. If you pass an object, Python will unpack the value from the object for you.<br>A function is a piece of code that will do something depending on the values you pass to it. This makes them very flexible. You can have functions without parameters, those will always do the same and are less flexible. <br>Functions also make code reusable.",
      "outputs": []
    },
    {
      "cell_index": 81,
      "week": 1,
      "cell_type": "code",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a,b)",
      "outputs": []
    },
    {
      "cell_index": 82,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "### You can concatenate (glue) strings with the + operator",
      "outputs": []
    },
    {
      "cell_index": 83,
      "week": 1,
      "cell_type": "code",
      "topic": "strings",
      "is_advanced_optional": false,
      "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
      "outputs": []
    },
    {
      "cell_index": 84,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings_fstrings",
      "is_advanced_optional": false,
      "source": "### You can concatenate strings with the + operator, but when printing, the use of so-called f- strings is often more useful.<br>F-strings start with an f, and you can use expressions (code that evaluates to a value) within curly brackets. These expressions are then evaluated into values",
      "outputs": []
    },
    {
      "cell_index": 85,
      "week": 1,
      "cell_type": "code",
      "topic": "strings_fstrings",
      "is_advanced_optional": false,
      "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(f\"First string: '{a}', Second string: '{b}'.\")\nprint(\"First string: '{a}', Second string: '{b}'.\")",
      "outputs": []
    },
    {
      "cell_index": 86,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>A nice option with f-strings",
      "outputs": []
    },
    {
      "cell_index": 87,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\na = 'This is a string'; b = 6; c = 0.0      \nprint(f\"We know {a =}, {b= }, and {c = }\")",
      "outputs": []
    },
    {
      "cell_index": 88,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings_quotes",
      "is_advanced_optional": false,
      "source": "### Quotes indicating strings have to be both single or plural, but not mixed",
      "outputs": []
    },
    {
      "cell_index": 89,
      "week": 1,
      "cell_type": "code",
      "topic": "strings_quotes",
      "is_advanced_optional": false,
      "source": "print('This gives an error\")\nprint(\"This gives an error')",
      "outputs": []
    },
    {
      "cell_index": 90,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings_quotes",
      "is_advanced_optional": false,
      "source": "### Quotes that are part of a string have to be different from the quotes indicating the string",
      "outputs": []
    },
    {
      "cell_index": 91,
      "week": 1,
      "cell_type": "code",
      "topic": "strings_quotes",
      "is_advanced_optional": false,
      "source": "print(\"This gives no ' error\")\nprint('This gives no \" error')",
      "outputs": []
    },
    {
      "cell_index": 92,
      "week": 1,
      "cell_type": "markdown",
      "topic": "strings_escape",
      "is_advanced_optional": false,
      "source": "### Alternatively, you also could use escape characters (\\)",
      "outputs": []
    },
    {
      "cell_index": 93,
      "week": 1,
      "cell_type": "code",
      "topic": "strings_escape",
      "is_advanced_optional": false,
      "source": "print('This gives no \\' error')\nprint(\"This gives no \\\" error\")",
      "outputs": []
    },
    {
      "cell_index": 94,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>Other escape characters",
      "outputs": []
    },
    {
      "cell_index": 95,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nprint('The escape character \\t gives a tab')\nprint('The escape character \\n gives a new line')\nprint('The escape character \\\\n gives a backward slash')",
      "outputs": []
    },
    {
      "cell_index": 96,
      "week": 1,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>If you don't want the backslashes inside a string to be seen as part of an escape character, you should use raw strings",
      "outputs": []
    },
    {
      "cell_index": 97,
      "week": 1,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nprint(r\"This gives no \\\" error\")\nprint(r'This gives no \\' error')",
      "outputs": []
    },
    {
      "cell_index": 98,
      "week": 1,
      "cell_type": "markdown",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "### Importing names of objects for using extra functionality",
      "outputs": []
    },
    {
      "cell_index": 99,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "# In this cell we create a function that deletes all the thus far created names in your program, \n# we need such a function else you cannot run some cells more times and getting the same result all the time when testing the import statements \nimport sys\ndef clear_names():\n    message = ''\n    for n in sorted(globals()): \n        if n[0]!='_' and n not in [\"sys\", \"clear_names\"]:\n            message += f\"{n}, \"\n            delattr(sys.modules[__name__], n)",
      "outputs": []
    },
    {
      "cell_index": 100,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "%%writefile extension.py\n# In this cell we create a python file and write that to the hard disk (either of your computer or to the cloud depending where you run your code.\n# We will import this file to show how to import the names of objects \n# into your Python program\nYEAR = 2025\ndef create_absolute_year(x):\n    return YEAR + x",
      "outputs": [
        "Overwriting extension.py"
      ]
    },
    {
      "cell_index": 101,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "clear_names()\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(Exception)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)\n\nimport extension\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
      "outputs": [
        "<class 'Exception'>\nname 'extension' is not defined\nname 'YEAR' is not defined\n2025"
      ]
    },
    {
      "cell_index": 102,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "clear_names()\n\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
      "outputs": [
        "2025\nname 'extension' is not defined"
      ]
    },
    {
      "cell_index": 103,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "clear_names()\n\nfrom extension import create_absolute_year\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)",
      "outputs": [
        "2026\nname 'YEAR' is not defined"
      ]
    },
    {
      "cell_index": 104,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "clear_names()\n\nfrom extension import create_absolute_year as cay\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(cay(1))\nexcept Exception as e:\n    print(e)",
      "outputs": [
        "name 'create_absolute_year' is not defined\n2026"
      ]
    },
    {
      "cell_index": 105,
      "week": 1,
      "cell_type": "code",
      "topic": "imports",
      "is_advanced_optional": false,
      "source": "clear_names()\n\nimport extension\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
      "outputs": [
        "2025\n2025"
      ]
    },
    {
      "cell_index": 0,
      "week": 2,
      "cell_type": "markdown",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "## Augmented Assignment Operators",
      "outputs": []
    },
    {
      "cell_index": 1,
      "week": 2,
      "cell_type": "markdown",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "### Augmented operators are not strictly needed, you can do the same with a bit more verbose code.<br>However, most experienced programmers would say that using augmented operators makes your code more readable<br>This happens often in Python: compact language constructs that will look very alien in the beginning, end to be your best friends<br>But even if you don't like them, you still have to know them&#128521;",
      "outputs": []
    },
    {
      "cell_index": 2,
      "week": 2,
      "cell_type": "markdown",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "### The following two cells do exactly the same",
      "outputs": []
    },
    {
      "cell_index": 3,
      "week": 2,
      "cell_type": "code",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "a = 1 \na += 1\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 4,
      "week": 2,
      "cell_type": "code",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "a = 1 \na = a + 1\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 5,
      "week": 2,
      "cell_type": "markdown",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "### The other augmented operators you need to know",
      "outputs": []
    },
    {
      "cell_index": 6,
      "week": 2,
      "cell_type": "code",
      "topic": "augmented_operators",
      "is_advanced_optional": false,
      "source": "a = 2\na -= 2\nprint(a)\n\na=3\na *= 3\nprint(a)\n\na = 5\na /= 4\nprint(a)\n\na = 6\na //= 5\nprint(a)\n\na = 7\na %= 6\nprint(a)\n\na = 8\na **= 7\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 7,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "## Dictionaries",
      "outputs": []
    },
    {
      "cell_index": 8,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### Dictionaries are sets of key: value pairs. Keys have to be unique, and you can use the key to get to the value",
      "outputs": []
    },
    {
      "cell_index": 9,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
      "outputs": []
    },
    {
      "cell_index": 10,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### Using a dictionary looks nice, if like here you always use a country name to get the capital<br>However, if you have to look both ways the advantage if any is not that clear",
      "outputs": []
    },
    {
      "cell_index": 11,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
      "outputs": []
    },
    {
      "cell_index": 12,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
      "outputs": []
    },
    {
      "cell_index": 13,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### If you need more advanced structures for your data, using a database system like pandas, which you will learn about in week 5, could be a better option",
      "outputs": []
    },
    {
      "cell_index": 14,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### Dictionaries behave often as if they have no order, compare for example the following behavior of dictionaries and lists",
      "outputs": []
    },
    {
      "cell_index": 15,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "print ({1:1, 2:2} == {2:2, 1:1})",
      "outputs": []
    },
    {
      "cell_index": 16,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "print ([1,2] == [2,1])",
      "outputs": []
    },
    {
      "cell_index": 17,
      "week": 2,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br> Therefore you cannot sort a dictionary. <br>However, you can almost sort a dictionary, but the result can of course, not be a dictionary as a dictionary can have no order. You can for example change the dictionary into a list with tuples or a list with sublists, and sort that list. <br>Here we show you how to do it. If you don't understand it no problem, after week 3 you will. Else if you want to know it now already you can ask us",
      "outputs": []
    },
    {
      "cell_index": 18,
      "week": 2,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\na = {'a': 2, 'b': 1} \nprint (sorted(a.items(), key=lambda x: x[0]))    # sort the data on the keys\nprint (sorted(a.items(), key=lambda x: x[1]))    # sort the data on the values",
      "outputs": []
    },
    {
      "cell_index": 19,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### We just said that dictionaries behave as if they have no order. Actually dictionaries are insertion-ordered, meaning that they remember the order in which keys and values were added. This is the reason the following works",
      "outputs": []
    },
    {
      "cell_index": 20,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
      "outputs": []
    },
    {
      "cell_index": 21,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### In programming languages there is often a trade-off between flexibility and speed: In Python to make working with dictionaries fast, keys have to be immutable",
      "outputs": []
    },
    {
      "cell_index": 22,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
      "outputs": []
    },
    {
      "cell_index": 23,
      "week": 2,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>Python itself also uses dictionaries, for example to keep track of the values of objects",
      "outputs": []
    },
    {
      "cell_index": 24,
      "week": 2,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\na = 2\nprint (locals()['a'])\nlocals()['a'] = 5\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 25,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### Using dictionaries",
      "outputs": []
    },
    {
      "cell_index": 26,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 27,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 28,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 29,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 30,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
      "outputs": []
    },
    {
      "cell_index": 31,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### As dictionaries have no order, so you cannot use indices",
      "outputs": []
    },
    {
      "cell_index": 32,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### Say you want to change the value belonging to the key a in codes = {'a': '!', 'b': '@', 'c': '$', 'd': '!'}<br>May-be, you think the first element in the dictionary has index = 0",
      "outputs": []
    },
    {
      "cell_index": 33,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### The following doesn't work<br>NB! You don't get the result that you want, but the tricky part is that you don't get an error. While you think you use an index, Python thinks you use a key, and is ok with your code!",
      "outputs": []
    },
    {
      "cell_index": 34,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "codes = {'a': '!', 'b': '@', 'c': '$', 'd': '!'}\ncodes[0] ='*'\nprint (codes)",
      "outputs": []
    },
    {
      "cell_index": 35,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "codes = {'a': '!', 'b': '@', 'c': '$', 'd': '!'}\ncodes[0] ={'a': '*'}\nprint (codes)",
      "outputs": []
    },
    {
      "cell_index": 36,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "### The following does work",
      "outputs": []
    },
    {
      "cell_index": 37,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "codes = {'a': '!', 'b': '@', 'c': '$', 'd': '!'}\ncodes['a'] ='*'\nprint (codes)",
      "outputs": []
    },
    {
      "cell_index": 38,
      "week": 2,
      "cell_type": "markdown",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "###  Inserting a new key:value pair and changing an existing key:value pair looks the same. It can be a good idea to check whether a key already exists in a dictionary, when you need to be certain you are updating and not inserting or the other way around",
      "outputs": []
    },
    {
      "cell_index": 39,
      "week": 2,
      "cell_type": "code",
      "topic": "dictionaries",
      "is_advanced_optional": false,
      "source": "codes = {'a': '!', 'b': '@', 'c': '$', 'd': '!'}\ninserts = {'a': '%', 'e': '^', 'f': '$'} \nfor letter in inserts:\n    code = inserts[letter]\n    if letter not in codes and code not in codes.values():\n        codes[letter] = inserts[letter]\n        continue\n    if letter in codes:\n        print(f\"Letter \\'{letter}\\' already in dictionary, therefore {{\\'{letter}\\': \\'{code}\\'}} not inserted\")\n        continue\n    if code in codes.values():\n        print(f\"Code \\'{code}\\' already in dictionary, therefore {{\\'{letter}\\': \\'{code}\\'}} not inserted\")\nprint(codes)",
      "outputs": []
    },
    {
      "cell_index": 40,
      "week": 2,
      "cell_type": "markdown",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "## Using lists",
      "outputs": []
    },
    {
      "cell_index": 41,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = []\nprint(squares)\nsquares = list()\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 42,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [1, 4, 9, 16]\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 43,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [4, 16]\nsquares = squares[:1] + [9] + squares[1:]  \nsquares.append(25)\nsquares += [36]\nsquares.insert(0, 1)\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 44,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [1, 4, 5, 9, 16]\ndel(squares[2])\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 45,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [1, 4, 8, 15]\nsquares[2] = 9\nsquares[3] = 16\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 46,
      "week": 2,
      "cell_type": "markdown",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "###  Sometimes you want to be sure you only insert a value to a list that is not already in that list",
      "outputs": []
    },
    {
      "cell_index": 47,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [1, 4, 9, 16]\nsquares.append(16)\nsquares.append(25)\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 48,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "if 16 not in squares:\n    squares.append(16)\nif 25 not in squares:\n    squares.append(25)    \nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 49,
      "week": 2,
      "cell_type": "markdown",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "###  Another option if you don't want to get doublures in your list would be using a set as an intermediair",
      "outputs": []
    },
    {
      "cell_index": 50,
      "week": 2,
      "cell_type": "code",
      "topic": "lists",
      "is_advanced_optional": false,
      "source": "squares = [1, 4, 9, 16]\nsquares = set(squares)\nsquares.add(16)\nsquares.add(25)\nsquares = list(squares)\nprint(squares)",
      "outputs": []
    },
    {
      "cell_index": 51,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "## Conditions",
      "outputs": []
    },
    {
      "cell_index": 52,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "## Conditions are expressions that lead to True or False, e.g. you saw in week 1 comparisons leading to True or False with <, >, =>, =<, ==, !=",
      "outputs": []
    },
    {
      "cell_index": 53,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "print(3 > 2)",
      "outputs": []
    },
    {
      "cell_index": 54,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### You can make a new condition based on one or more conditions, by using: and, or, not",
      "outputs": []
    },
    {
      "cell_index": 55,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "print(True and True,   True or True)\nprint(True and False,  True or False)\nprint(False and True,  False or True)\nprint(False and False, False or False)",
      "outputs": []
    },
    {
      "cell_index": 56,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "print(not True) \nprint(not False)",
      "outputs": []
    },
    {
      "cell_index": 57,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### You can make this as complex as you want. Adding round brackets could make it more readable, and easier to avoid errors. The rules for precedence (what is evaluated first) can be quite complicated",
      "outputs": []
    },
    {
      "cell_index": 58,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### The two conditions below do exactly the same",
      "outputs": []
    },
    {
      "cell_index": 59,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "print(True and True or False and False)\nprint((True and True) or (False and False))",
      "outputs": []
    },
    {
      "cell_index": 60,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "### The two conditions below do not exactly the same",
      "outputs": []
    },
    {
      "cell_index": 61,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "print(True or True and False or False)\nprint((True or True) and (False or False))",
      "outputs": []
    },
    {
      "cell_index": 62,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### If you want to check whether an object has a value between 2 and 5, you can use the following conditional statement:",
      "outputs": []
    },
    {
      "cell_index": 63,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "a = 3\nif a > 1 and a < 5:\n    print('a between 2 and 5')",
      "outputs": []
    },
    {
      "cell_index": 64,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### And sometimes as in this case, you have an extra option:",
      "outputs": []
    },
    {
      "cell_index": 65,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "a = 3\nif 5 > a > 1:\n    print('a between 2 and 5')",
      "outputs": []
    },
    {
      "cell_index": 66,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "### It would be a bit more exciting to assign a to random integer between 0 and 5 (0 and 5 included) and then do the check<br>To do that we import the radint function from the random module. Now every time you run the following cell a rondom number between 0 and 5 (both included) is generated",
      "outputs": []
    },
    {
      "cell_index": 67,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions",
      "is_advanced_optional": false,
      "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
      "outputs": []
    },
    {
      "cell_index": 68,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "## Precedence",
      "outputs": []
    },
    {
      "cell_index": 69,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "### When evaluating conditions, Python evaluates in the following order: <ol><li>Comparisons<li>What is between brackets<li>and's<li>or's",
      "outputs": []
    },
    {
      "cell_index": 70,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "a=1\nb=3\nprint(a==1 or a==2 and b==1 or b==2)",
      "outputs": []
    },
    {
      "cell_index": 71,
      "week": 2,
      "cell_type": "code",
      "topic": "conditions_precedence",
      "is_advanced_optional": false,
      "source": "a=1\nb=3\nprint((a==1 or a==2) and (b==1 or b==2))",
      "outputs": []
    },
    {
      "cell_index": 72,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "## Conditional statements vs conditional expressions",
      "outputs": []
    },
    {
      "cell_index": 73,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "### conditional expressions are just a way to write conditional statements in a compact way",
      "outputs": []
    },
    {
      "cell_index": 74,
      "week": 2,
      "cell_type": "code",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "from random import randint\na = randint(-5,5) \nprint(a)\n\nif a > 0:\n    b = a\nelse:\n    b = 0\nprint(b)",
      "outputs": []
    },
    {
      "cell_index": 75,
      "week": 2,
      "cell_type": "code",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = a if a > 0 else 0\nprint(b)",
      "outputs": []
    },
    {
      "cell_index": 76,
      "week": 2,
      "cell_type": "markdown",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "### In this case you can do the same even easier with a built-in function",
      "outputs": []
    },
    {
      "cell_index": 77,
      "week": 2,
      "cell_type": "code",
      "topic": "conditional_expression",
      "is_advanced_optional": false,
      "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = max(a, 0)\nprint(b)",
      "outputs": []
    },
    {
      "cell_index": 78,
      "week": 2,
      "cell_type": "markdown",
      "topic": "for_loops",
      "is_advanced_optional": false,
      "source": "## For-loops",
      "outputs": []
    },
    {
      "cell_index": 79,
      "week": 2,
      "cell_type": "code",
      "topic": "for_loops",
      "is_advanced_optional": false,
      "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
      "outputs": []
    },
    {
      "cell_index": 80,
      "week": 2,
      "cell_type": "code",
      "topic": "for_loops",
      "is_advanced_optional": false,
      "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
      "outputs": []
    },
    {
      "cell_index": 81,
      "week": 2,
      "cell_type": "code",
      "topic": "for_loops",
      "is_advanced_optional": false,
      "source": "for number in range(5):\n    print ('Hello')",
      "outputs": []
    },
    {
      "cell_index": 82,
      "week": 2,
      "cell_type": "code",
      "topic": "for_loops",
      "is_advanced_optional": false,
      "source": "for _ in range(5):\n    print ('Hello')",
      "outputs": []
    },
    {
      "cell_index": 83,
      "week": 2,
      "cell_type": "markdown",
      "topic": "looping_dicts",
      "is_advanced_optional": false,
      "source": "### Looping over dictionaries",
      "outputs": []
    },
    {
      "cell_index": 84,
      "week": 2,
      "cell_type": "code",
      "topic": "looping_dicts",
      "is_advanced_optional": false,
      "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(f\"The country is {key}\")",
      "outputs": []
    },
    {
      "cell_index": 85,
      "week": 2,
      "cell_type": "code",
      "topic": "looping_dicts",
      "is_advanced_optional": false,
      "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor value in capitals.values():\n    print(f\"The capital is {value}\")",
      "outputs": []
    },
    {
      "cell_index": 86,
      "week": 2,
      "cell_type": "code",
      "topic": "looping_dicts",
      "is_advanced_optional": false,
      "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country, city in capitals.items():\n    print(f\"{country=} and {city=} \")",
      "outputs": []
    },
    {
      "cell_index": 87,
      "week": 2,
      "cell_type": "code",
      "topic": "looping_dicts",
      "is_advanced_optional": false,
      "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country in capitals:\n    print(f\"The country is {country}\")",
      "outputs": []
    },
    {
      "cell_index": 88,
      "week": 2,
      "cell_type": "markdown",
      "topic": "enumerate",
      "is_advanced_optional": false,
      "source": "### Enumerate",
      "outputs": []
    },
    {
      "cell_index": 89,
      "week": 2,
      "cell_type": "code",
      "topic": "enumerate",
      "is_advanced_optional": false,
      "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
      "outputs": []
    },
    {
      "cell_index": 90,
      "week": 2,
      "cell_type": "code",
      "topic": "enumerate",
      "is_advanced_optional": false,
      "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
      "outputs": []
    },
    {
      "cell_index": 91,
      "week": 2,
      "cell_type": "markdown",
      "topic": "zip",
      "is_advanced_optional": false,
      "source": "### Zip",
      "outputs": []
    },
    {
      "cell_index": 92,
      "week": 2,
      "cell_type": "code",
      "topic": "zip",
      "is_advanced_optional": false,
      "source": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(f'country {country} has capital: {capital}')",
      "outputs": []
    },
    {
      "cell_index": 93,
      "week": 2,
      "cell_type": "markdown",
      "topic": "while_loops",
      "is_advanced_optional": false,
      "source": "## While loop",
      "outputs": []
    },
    {
      "cell_index": 94,
      "week": 2,
      "cell_type": "markdown",
      "topic": "while_loops",
      "is_advanced_optional": false,
      "source": "### The following three code snippets do eactly the same<br>We use here the built-in input function<br>This input function puts what is between brackets on the screen, gives the user something to enter, changes what the user entered into a string, and returns this value to the program",
      "outputs": []
    },
    {
      "cell_index": 95,
      "week": 2,
      "cell_type": "code",
      "topic": "while_loops",
      "is_advanced_optional": false,
      "source": "total = 0\nnumber = int(input('give a number, or 100 to stop '))\nwhile number != 100:\n    if number % 2 == 1:\n        total += number\n    number = int(input('give number, or 100 to stop '))\nprint (f'The sum of all the uneven numbers you entered is {total}')",
      "outputs": []
    },
    {
      "cell_index": 96,
      "week": 2,
      "cell_type": "code",
      "topic": "while_loops",
      "is_advanced_optional": false,
      "source": "total = 0\nwhile True:\n    number = int(input('give a number, or 100 to stop '))\n    if number == 100:\n        break\n    if number % 2 == 0:\n        continue\n    total += number\nprint (f'The sum of all the uneven numbers you entered is {total}')",
      "outputs": []
    },
    {
      "cell_index": 97,
      "week": 2,
      "cell_type": "markdown",
      "topic": "walrus_operator",
      "is_advanced_optional": false,
      "source": "### In the last code snippet of the three we will use the walrus operator :=<br>The walrus operator works as an assignment statement but also as an expression that evaluates to the value of the right side of the walrus operator",
      "outputs": []
    },
    {
      "cell_index": 98,
      "week": 2,
      "cell_type": "code",
      "topic": "walrus_operator",
      "is_advanced_optional": false,
      "source": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100 :\n    if number % 2 == 1:\n        total += number\nprint (f'The sum of all the uneven numbers you entered is {total}')",
      "outputs": []
    },
    {
      "cell_index": 99,
      "week": 2,
      "cell_type": "markdown",
      "topic": "walrus_operator",
      "is_advanced_optional": false,
      "source": "### If you like the walrus operator, another example. First without, next with the walrus operator, a piece of code you already saw in this notebook",
      "outputs": []
    },
    {
      "cell_index": 100,
      "week": 2,
      "cell_type": "code",
      "topic": "walrus_operator",
      "is_advanced_optional": false,
      "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
      "outputs": []
    },
    {
      "cell_index": 101,
      "week": 2,
      "cell_type": "code",
      "topic": "walrus_operator",
      "is_advanced_optional": false,
      "source": "from random import randint\nprint(a := randint(0,5))\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
      "outputs": []
    },
    {
      "cell_index": 102,
      "week": 2,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "## Implicit conversions",
      "outputs": []
    },
    {
      "cell_index": 103,
      "week": 2,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "### In some cases where we apply an operator on 2 values, Python changes the type of one (or sometimes even two) of the values, before applying the operation. Some examples",
      "outputs": []
    },
    {
      "cell_index": 104,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print (1 + True, 1.0 + False, True + False)",
      "outputs": []
    },
    {
      "cell_index": 105,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print (1==1.0, 1.0 == True, 0 == False)",
      "outputs": []
    },
    {
      "cell_index": 106,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print ('1' * 2, '1' * True, '1' * False)",
      "outputs": []
    },
    {
      "cell_index": 107,
      "week": 2,
      "cell_type": "markdown",
      "topic": "truthy_falsy",
      "is_advanced_optional": false,
      "source": "### In case of if and while statements, some expression will evaluate to True or False, all by themselves.<br>The expressions that are evaluated to True are called Truthy, expressions that are evaluated to False are called Falsy.<br>The following if statements show all expressions that evaluate to False if used as a condition, all other expressions evaluate to True:",
      "outputs": []
    },
    {
      "cell_index": 108,
      "week": 2,
      "cell_type": "code",
      "topic": "truthy_falsy",
      "is_advanced_optional": false,
      "source": "l1 = [[], (), {}, set(), '', 0, 0.0, range(0)] \nfor x in l1:\n    print (f'{x} is {\"Truthy\" if x else \"Falsy\"}')",
      "outputs": []
    },
    {
      "cell_index": 109,
      "week": 2,
      "cell_type": "markdown",
      "topic": "truthy_falsy",
      "is_advanced_optional": false,
      "source": "### an example",
      "outputs": []
    },
    {
      "cell_index": 110,
      "week": 2,
      "cell_type": "code",
      "topic": "truthy_falsy",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:\n    total += l1[0]\n    del l1[0]\nprint(total)",
      "outputs": []
    },
    {
      "cell_index": 111,
      "week": 2,
      "cell_type": "markdown",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "### #<br>The following does the same but looks a lot nicer:<br>Of course this is a matter of taste but most Python programmers would agree. Python is rather flexible, so there are often several ways to solve a problem, but adhering to the community taste makes it easier for other people to understand your program",
      "outputs": []
    },
    {
      "cell_index": 112,
      "week": 2,
      "cell_type": "code",
      "topic": "advanced_optional",
      "is_advanced_optional": true,
      "source": "#\nl1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:\n    total += l1.pop(0)\nprint(total)",
      "outputs": []
    },
    {
      "cell_index": 113,
      "week": 2,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "### Python is not very generous with implicit conversion.<br>The following example leads to an error in Python, while making sense in other languages",
      "outputs": []
    },
    {
      "cell_index": 114,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "try:\n    print ('1' + 2)\nexcept Exception as e:\n    print(e)",
      "outputs": []
    },
    {
      "cell_index": 115,
      "week": 2,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "## Explicit conversions",
      "outputs": []
    },
    {
      "cell_index": 116,
      "week": 2,
      "cell_type": "markdown",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "### You can do a lot of explicit conversion in Python, though not unlimited.",
      "outputs": []
    },
    {
      "cell_index": 117,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print(str(1) == '1')\nprint(int('1') == 1)",
      "outputs": []
    },
    {
      "cell_index": 118,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "print(float('1') == 1.0)\nprint(float('1.0') == 1.0)  \nprint(tuple([1,2,3]) == (1,2,3))  \nprint(tuple({1:3, 2:4}) == (1,2))  \nprint(dict([(1,3), (2,4)]) == {1: 3, 2:4})",
      "outputs": []
    },
    {
      "cell_index": 119,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "try:\n    print(int('1a') == 1)\nexcept Exception as e:\n    print(e)",
      "outputs": []
    },
    {
      "cell_index": 120,
      "week": 2,
      "cell_type": "code",
      "topic": "type_conversion",
      "is_advanced_optional": false,
      "source": "try:\n    print(dict([1, 2]))\nexcept Exception as e:\n    print(e)",
      "outputs": []
    },
    {
      "cell_index": 121,
      "week": 2,
      "cell_type": "markdown",
      "topic": "fun_example",
      "is_advanced_optional": false,
      "source": "### Fun question: What does the following program do?",
      "outputs": []
    },
    {
      "cell_index": 122,
      "week": 2,
      "cell_type": "code",
      "topic": "fun_example",
      "is_advanced_optional": false,
      "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
      "outputs": []
    },
    {
      "cell_index": 0,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_definition",
      "is_advanced_optional": false,
      "source": "### Function definitions start with the def keyword",
      "outputs": []
    },
    {
      "cell_index": 1,
      "week": 3,
      "cell_type": "code",
      "topic": "function_definition",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total",
      "outputs": []
    },
    {
      "cell_index": 2,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "### Function are called by writing there name and round brackets after that name. <br>Between those brackets you can put arguments, that will be passed to the function",
      "outputs": []
    },
    {
      "cell_index": 3,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "a = adder(1, 2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 4,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "print(adder(1,2))",
      "outputs": []
    },
    {
      "cell_index": 5,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "### You call functions by adding round brackets after their name. If you use other brackets you get an error",
      "outputs": []
    },
    {
      "cell_index": 6,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "adder[1,2]",
      "outputs": []
    },
    {
      "cell_index": 7,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "adder{1,2}",
      "outputs": []
    },
    {
      "cell_index": 8,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "### Error messages are not always self explenatory, but if you make enough errors you will start to recognice them. <br>For this course we don't assume you to know all the error messages, but we assume you recognice when there will be some error!",
      "outputs": []
    },
    {
      "cell_index": 9,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "### To get an element or a slice from for example a list, you use square brackets. If you use other brackets instead, you get an error",
      "outputs": []
    },
    {
      "cell_index": 10,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3]\nl1(1)",
      "outputs": []
    },
    {
      "cell_index": 11,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3]\nl1{1}",
      "outputs": []
    },
    {
      "cell_index": 12,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "### Technically, you don't need functions",
      "outputs": []
    },
    {
      "cell_index": 13,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 14,
      "week": 3,
      "cell_type": "code",
      "topic": "function_calls",
      "is_advanced_optional": false,
      "source": "n1 = 1\nn2 = 2\ntotal = n1 + n2\na = total\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 15,
      "week": 3,
      "cell_type": "markdown",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "### return statement",
      "outputs": []
    },
    {
      "cell_index": 16,
      "week": 3,
      "cell_type": "code",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    total = n1 + n2\na = adder(1, 2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 17,
      "week": 3,
      "cell_type": "code",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)\nif a != None:\n    print ('The result is: ' + a)\nelse:\n    print ('Wrong numbers')",
      "outputs": []
    },
    {
      "cell_index": 18,
      "week": 3,
      "cell_type": "code",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    return n1 + n2\na = adder(1,2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 19,
      "week": 3,
      "cell_type": "code",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\na = powers(3)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 20,
      "week": 3,
      "cell_type": "code",
      "topic": "return_statement",
      "is_advanced_optional": false,
      "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\npower2, power3 = powers(3)\nprint(power2, power3)",
      "outputs": []
    },
    {
      "cell_index": 21,
      "week": 3,
      "cell_type": "markdown",
      "topic": "multiple_returns",
      "is_advanced_optional": false,
      "source": "### You can use multiple return statements in a function, but this can make your code a bit more difficult to read",
      "outputs": []
    },
    {
      "cell_index": 22,
      "week": 3,
      "cell_type": "code",
      "topic": "multiple_returns",
      "is_advanced_optional": false,
      "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        return n1+n2\n    return n1*n2\nprint(calculator())",
      "outputs": []
    },
    {
      "cell_index": 23,
      "week": 3,
      "cell_type": "code",
      "topic": "multiple_returns",
      "is_advanced_optional": false,
      "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        result = n1+n2\n    else:\n        result = n1 * n2\n    return result    \nprint(calculator())",
      "outputs": []
    },
    {
      "cell_index": 24,
      "week": 3,
      "cell_type": "markdown",
      "topic": "pass",
      "is_advanced_optional": false,
      "source": "### pass, useful stub avoiding problems with indentation",
      "outputs": []
    },
    {
      "cell_index": 25,
      "week": 3,
      "cell_type": "code",
      "topic": "pass",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n    return result\na = adder(1, 2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 26,
      "week": 3,
      "cell_type": "code",
      "topic": "pass",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n        pass\n    return result\na = adder(1, 2)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 27,
      "week": 3,
      "cell_type": "markdown",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "### Global and local names",
      "outputs": []
    },
    {
      "cell_index": 28,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "del (n1, n2)\ndef adder(n1, n2):\n    return n1 + n2\nadder (1,2)\nprint(n1)",
      "outputs": []
    },
    {
      "cell_index": 29,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def changer():\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
      "outputs": []
    },
    {
      "cell_index": 30,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def changer():\n    global n1\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
      "outputs": []
    },
    {
      "cell_index": 31,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def main (a):\n    b = b\n    return a\nb = 1\nprint(main (1))",
      "outputs": []
    },
    {
      "cell_index": 32,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def main (a):\n    global b\n    b = b\n    return a\nb = 1\nprint(main (1))",
      "outputs": []
    },
    {
      "cell_index": 33,
      "week": 3,
      "cell_type": "markdown",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "### Try to avoid the global keyword",
      "outputs": []
    },
    {
      "cell_index": 34,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)",
      "outputs": []
    },
    {
      "cell_index": 35,
      "week": 3,
      "cell_type": "code",
      "topic": "scope",
      "is_advanced_optional": false,
      "source": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)",
      "outputs": []
    },
    {
      "cell_index": 36,
      "week": 3,
      "cell_type": "markdown",
      "topic": "positional_args",
      "is_advanced_optional": false,
      "source": "### Accepting positional arguments",
      "outputs": []
    },
    {
      "cell_index": 37,
      "week": 3,
      "cell_type": "code",
      "topic": "positional_args",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2):\n    return n1 + n2\nprint(adder(1, 2))",
      "outputs": []
    },
    {
      "cell_index": 38,
      "week": 3,
      "cell_type": "code",
      "topic": "args_star",
      "is_advanced_optional": false,
      "source": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
      "outputs": []
    },
    {
      "cell_index": 39,
      "week": 3,
      "cell_type": "code",
      "topic": "args_star",
      "is_advanced_optional": false,
      "source": "def adder(l1):\n    result = 0\n    for number in l1:\n        result += number  \n    return result\nprint(adder([1, 2, 3, 4, 5]))",
      "outputs": []
    },
    {
      "cell_index": 40,
      "week": 3,
      "cell_type": "code",
      "topic": "args_star",
      "is_advanced_optional": false,
      "source": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
      "outputs": []
    },
    {
      "cell_index": 41,
      "week": 3,
      "cell_type": "markdown",
      "topic": "mutable_args",
      "is_advanced_optional": false,
      "source": "### A problems with mutable arguments",
      "outputs": []
    },
    {
      "cell_index": 42,
      "week": 3,
      "cell_type": "code",
      "topic": "mutable_args",
      "is_advanced_optional": false,
      "source": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
      "outputs": []
    },
    {
      "cell_index": 43,
      "week": 3,
      "cell_type": "code",
      "topic": "mutable_args",
      "is_advanced_optional": false,
      "source": "def adder(l2):\n    l2 = l2[:]\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
      "outputs": []
    },
    {
      "cell_index": 44,
      "week": 3,
      "cell_type": "markdown",
      "topic": "function_factories",
      "is_advanced_optional": false,
      "source": "### Function factories, functions creating other functions",
      "outputs": []
    },
    {
      "cell_index": 45,
      "week": 3,
      "cell_type": "raw",
      "topic": "function_factories",
      "is_advanced_optional": false,
      "source": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\n\nadd4 = function_factory(4)\nadd5 = function_factory (5)\n\nprint(add4(3))\nprint(add5(3))",
      "outputs": []
    },
    {
      "cell_index": 46,
      "week": 3,
      "cell_type": "markdown",
      "topic": "keyword_args",
      "is_advanced_optional": false,
      "source": "### Accepting keyword arguments",
      "outputs": []
    },
    {
      "cell_index": 47,
      "week": 3,
      "cell_type": "code",
      "topic": "keyword_args",
      "is_advanced_optional": false,
      "source": "def calc(first, second, third, fourth, fifth, sixt):\n    return first + 2 * second + 3 * third + 4 * fourth + 5 * fifth + 6 * sixt \nprint(calc(fifth = 2, third=4, fourth=1, sixt=5, second=2, first=3))",
      "outputs": []
    },
    {
      "cell_index": 48,
      "week": 3,
      "cell_type": "code",
      "topic": "keyword_args",
      "is_advanced_optional": false,
      "source": "def calc(**kwargs):\n    return kwargs['first'] + 2 * kwargs['second']+ 3 * kwargs['third'] + 4 * kwargs['fourth'] + 5 * kwargs['fifth']+ 6 * kwargs['sixt']\nprint(calc(third=4, fourth=1, second=2, first=3, fifth = 2, sixt=5))",
      "outputs": []
    },
    {
      "cell_index": 49,
      "week": 3,
      "cell_type": "markdown",
      "topic": "mixed_args",
      "is_advanced_optional": false,
      "source": "### You can mix positional and keyword arguments",
      "outputs": []
    },
    {
      "cell_index": 50,
      "week": 3,
      "cell_type": "code",
      "topic": "mixed_args",
      "is_advanced_optional": false,
      "source": "def calc(first, second, *args, **kwargs):\n    return first + second * 2 + args[0] * 3 + args[1] * 4 + 5 * kwargs['fifth']+ 6 * kwargs['sixt']\nprint(calc(3, 2, 4, 1, sixt=5, fifth=2))",
      "outputs": []
    },
    {
      "cell_index": 51,
      "week": 3,
      "cell_type": "markdown",
      "topic": "default_args",
      "is_advanced_optional": false,
      "source": "### You can define defaults",
      "outputs": []
    },
    {
      "cell_index": 52,
      "week": 3,
      "cell_type": "code",
      "topic": "default_args",
      "is_advanced_optional": false,
      "source": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3))",
      "outputs": []
    },
    {
      "cell_index": 53,
      "week": 3,
      "cell_type": "code",
      "topic": "default_args",
      "is_advanced_optional": false,
      "source": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3, 3))",
      "outputs": []
    },
    {
      "cell_index": 54,
      "week": 3,
      "cell_type": "code",
      "topic": "default_args",
      "is_advanced_optional": false,
      "source": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3, second=3))",
      "outputs": []
    },
    {
      "cell_index": 55,
      "week": 3,
      "cell_type": "markdown",
      "topic": "mutable_defaults",
      "is_advanced_optional": false,
      "source": "### A problem with mutable defaults",
      "outputs": []
    },
    {
      "cell_index": 56,
      "week": 3,
      "cell_type": "code",
      "topic": "mutable_defaults",
      "is_advanced_optional": false,
      "source": "def main (addition, l1 = []):\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
      "outputs": []
    },
    {
      "cell_index": 57,
      "week": 3,
      "cell_type": "code",
      "topic": "mutable_defaults",
      "is_advanced_optional": false,
      "source": "def main (addition, l1 = None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
      "outputs": []
    },
    {
      "cell_index": 58,
      "week": 3,
      "cell_type": "markdown",
      "topic": "lambda",
      "is_advanced_optional": false,
      "source": "### Lambdafunctions",
      "outputs": []
    },
    {
      "cell_index": 59,
      "week": 3,
      "cell_type": "code",
      "topic": "lambda",
      "is_advanced_optional": false,
      "source": "multiply_and_double = lambda x, y: 2*x*y  \nprint(multiply_and_double(1,3))",
      "outputs": []
    },
    {
      "cell_index": 60,
      "week": 3,
      "cell_type": "code",
      "topic": "lambda",
      "is_advanced_optional": false,
      "source": "def multiply_and_double(x,y):\n    return 2*x*y\nprint(multiply_and_double(1,3))",
      "outputs": []
    },
    {
      "cell_index": 61,
      "week": 3,
      "cell_type": "markdown",
      "topic": "lambda",
      "is_advanced_optional": false,
      "source": "###  Although, you can always get the same functionality as with normal functions, lambdafunctions are less coding, you have a better overview and sometimes you can use them to avoid creating new names, for example",
      "outputs": []
    },
    {
      "cell_index": 62,
      "week": 3,
      "cell_type": "code",
      "topic": "lambda",
      "is_advanced_optional": false,
      "source": "print((lambda x, y: 2*x*y)(4, 3))",
      "outputs": []
    },
    {
      "cell_index": 63,
      "week": 3,
      "cell_type": "markdown",
      "topic": "map_function",
      "is_advanced_optional": false,
      "source": "### Lambda functions can be used in a style of programming called functional programming<br>First function: the map function",
      "outputs": []
    },
    {
      "cell_index": 64,
      "week": 3,
      "cell_type": "code",
      "topic": "map_function",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\nl2 = []\nfor item in l1:\n    l2 += [item * 2]\nprint(l2)",
      "outputs": []
    },
    {
      "cell_index": 65,
      "week": 3,
      "cell_type": "code",
      "topic": "map_function",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))",
      "outputs": []
    },
    {
      "cell_index": 66,
      "week": 3,
      "cell_type": "code",
      "topic": "map_function",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'baab', 'c']\nprint(list(map(lambda x: x.count('a'), l1)))",
      "outputs": []
    },
    {
      "cell_index": 67,
      "week": 3,
      "cell_type": "markdown",
      "topic": "filter_function",
      "is_advanced_optional": false,
      "source": "### Second function: the filter function",
      "outputs": []
    },
    {
      "cell_index": 68,
      "week": 3,
      "cell_type": "code",
      "topic": "filter_function",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\nl2 = []\nfor item in l1:\n    if not item % 2:\n        l2 += [item]\nprint(l2)",
      "outputs": []
    },
    {
      "cell_index": 69,
      "week": 3,
      "cell_type": "code",
      "topic": "filter_function",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))",
      "outputs": []
    },
    {
      "cell_index": 70,
      "week": 3,
      "cell_type": "code",
      "topic": "filter_function",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'baab', 'c']\nprint(list(filter(lambda x: x.count('a') > 0, l1)))",
      "outputs": []
    },
    {
      "cell_index": 71,
      "week": 3,
      "cell_type": "markdown",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "### Third function: the reduce function",
      "outputs": []
    },
    {
      "cell_index": 72,
      "week": 3,
      "cell_type": "code",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "l1 = [1, 2, 3, 4, 5, 6]\nresult = l1[0]\nfor item in l1[1:]:\n    result *= item\nprint(result)",
      "outputs": []
    },
    {
      "cell_index": 73,
      "week": 3,
      "cell_type": "code",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))",
      "outputs": []
    },
    {
      "cell_index": 74,
      "week": 3,
      "cell_type": "markdown",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "### The reduce function can have a third parameter, if this is the case this will be used to initialize the result instead of the first element of the sequence",
      "outputs": []
    },
    {
      "cell_index": 75,
      "week": 3,
      "cell_type": "code",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'baab', 'c']\nresult = 0\nfor item in l1:\n    result += item.count('a')\nprint(result)",
      "outputs": []
    },
    {
      "cell_index": 76,
      "week": 3,
      "cell_type": "code",
      "topic": "reduce_function",
      "is_advanced_optional": false,
      "source": "from functools import reduce\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))",
      "outputs": []
    },
    {
      "cell_index": 77,
      "week": 3,
      "cell_type": "markdown",
      "topic": "map_filter_reduce",
      "is_advanced_optional": false,
      "source": "### The functions map, filter, and reduce can often be replaced by comprehensions, of which you will learn one of the coming weeks. <br>If you can replace map, filter, and reduce them, you are adviced to do so",
      "outputs": []
    },
    {
      "cell_index": 78,
      "week": 3,
      "cell_type": "markdown",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "### You can use lambdafunctions in sort operations, passing a lambda function to the key parameter. <br>Python will use the result of the lambda function for the order of the sort, however the values themselves will not be converted themselves<br>This works for the built-in sorted function and the sort method.",
      "outputs": []
    },
    {
      "cell_index": 79,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['a', 'B', 'c']\nprint(sorted(l1))",
      "outputs": []
    },
    {
      "cell_index": 80,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['a', 'B', 'c']\nprint(sorted(l1, key=lambda x: x.upper()))",
      "outputs": []
    },
    {
      "cell_index": 81,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['a', 'B', 'c']\nl1.sort(key=lambda x: x.upper())\nprint(l1)",
      "outputs": []
    },
    {
      "cell_index": 82,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['ad', 'dc', 'ce']\nprint(sorted(l1))",
      "outputs": []
    },
    {
      "cell_index": 83,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['ad', 'dc', 'ce']\nprint(sorted(l1, key=lambda x: x[1]))",
      "outputs": []
    },
    {
      "cell_index": 84,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_key",
      "is_advanced_optional": false,
      "source": "l1 = ['ad', 'dc', 'ce']\nl1.sort(key=lambda x: x[1])\nprint(l1)",
      "outputs": []
    },
    {
      "cell_index": 85,
      "week": 3,
      "cell_type": "markdown",
      "topic": "max_key",
      "is_advanced_optional": false,
      "source": "### The max function also has a key parameter, compare for example:",
      "outputs": []
    },
    {
      "cell_index": 86,
      "week": 3,
      "cell_type": "code",
      "topic": "max_key",
      "is_advanced_optional": false,
      "source": "d = {'a': 2, 'b': 1}\nprint(max(d.items()))",
      "outputs": []
    },
    {
      "cell_index": 87,
      "week": 3,
      "cell_type": "code",
      "topic": "max_key",
      "is_advanced_optional": false,
      "source": "d = {'a': 2, 'b': 1}\nprint(max(d.items(), key = lambda x: x[1]))",
      "outputs": []
    },
    {
      "cell_index": 88,
      "week": 3,
      "cell_type": "markdown",
      "topic": "sorted_builtins",
      "is_advanced_optional": false,
      "source": "### You can also pass all kind of other functions to the key parameter, e.g. built-in functions",
      "outputs": []
    },
    {
      "cell_index": 89,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_builtins",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'bb', 'c']\nprint(sorted(l1))",
      "outputs": []
    },
    {
      "cell_index": 90,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_builtins",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'bb', 'c']\nprint(sorted(l1, key=len))",
      "outputs": []
    },
    {
      "cell_index": 91,
      "week": 3,
      "cell_type": "code",
      "topic": "sorted_builtins",
      "is_advanced_optional": false,
      "source": "l1 = ['aaa', 'bb', 'c']\nl1.sort(key=len)\nprint(l1)",
      "outputs": []
    },
    {
      "cell_index": 92,
      "week": 3,
      "cell_type": "markdown",
      "topic": "for_vs_while",
      "is_advanced_optional": false,
      "source": "### A while loop can do the same as a for-loop. Comparing them can make you more aware what a for-loop actually does",
      "outputs": []
    },
    {
      "cell_index": 93,
      "week": 3,
      "cell_type": "code",
      "topic": "for_vs_while",
      "is_advanced_optional": false,
      "source": "x = [5, 10, 21]\nresult = []\nfor el in x:\n    if el != 10:\n        result.append(el * 2 if el < 10 else el // 2)\nprint(result)",
      "outputs": []
    },
    {
      "cell_index": 94,
      "week": 3,
      "cell_type": "code",
      "topic": "for_vs_while",
      "is_advanced_optional": false,
      "source": "x = [5, 10, 21]\nresult = []\nindex = 0\nwhile index < len(x):\n    el = x[index]\n    if el != 10:\n        result += [el * 2 if el < 10 else el // 2]\n    index += 1\nprint(result)",
      "outputs": []
    },
    {
      "cell_index": 95,
      "week": 3,
      "cell_type": "markdown",
      "topic": "nested_loops",
      "is_advanced_optional": false,
      "source": "### Nested for-loops",
      "outputs": []
    },
    {
      "cell_index": 96,
      "week": 3,
      "cell_type": "code",
      "topic": "nested_loops",
      "is_advanced_optional": false,
      "source": "x = ['a', 'b', 'c', 'd']\ny = ['e', 'f']\nz = ['g', 'h']\nresult = []\nfor elx in x:\n    for ely in y:\n        for elz in z:\n            result += [elx + ely + elz]\nprint(result)",
      "outputs": []
    },
    {
      "cell_index": 97,
      "week": 3,
      "cell_type": "markdown",
      "topic": "hw_question3",
      "is_advanced_optional": false,
      "source": "### Ad question 3",
      "outputs": []
    },
    {
      "cell_index": 98,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question3",
      "is_advanced_optional": false,
      "source": "x = {'b': 2, 'c': 3}\ny = {'c': 3, 'd': 3}\nfor key, value in y.items():\n    if key not in x:\n        x[key] = value\nfor key, value in y.items():\n    if key in x:\n        del x[key]\nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 99,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question3",
      "is_advanced_optional": false,
      "source": "x = {'b': 2, 'c': 3}\ny = {'c': 3, 'd': 3}\nfor key, value in y.items():\n    if key not in x:\n        x[key] = value\n        del(y[key])\nfor key, value in y.items():\n    if key in x:\n        del x[key]\nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 100,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question3",
      "is_advanced_optional": false,
      "source": "x = {'b': 2, 'c': 3}\ny = {'c': 3, 'd': 3}\nfor key, value in y.items():\n    if key not in x:\n        x[key] = value\n    else:\n        del x[key]\nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 101,
      "week": 3,
      "cell_type": "markdown",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "### Question 5",
      "outputs": []
    },
    {
      "cell_index": 102,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "keys = [3, 2, 1, 4]\nvalues = [3, 37, 60, 79]\nx = {}\nfor key, value in zip(keys, values):\n    if key == value:\n        continue\n    if value % 5 == 0:\n        continue\n    x[key] = value \nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 103,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "keys = [3, 2, 1, 4]\nvalues = [3, 37, 60, 79]\nx = {}\nfor key, value in zip(keys, values):\n    if key == value or value % 5 == 0:\n        continue\n    x[key] =value \nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 104,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "keys = [3, 2, 1, 4]\nvalues = [3, 37, 60, 79]\nx = {}\nfor key, value in zip(keys, values):\n    if not(key == value or value % 5 == 0):\n        x[key] =value \nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 105,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "keys = [3, 2, 1, 4]\nvalues = [3, 37, 60, 79]\nx = {}\nfor key, value in zip(keys, values):\n    if key != value and value % 5 != 0:\n        x[key] =value \nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 106,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question5",
      "is_advanced_optional": false,
      "source": "keys = [3, 2, 1, 4]\nvalues = [3, 37, 60, 79]\nx = {}\nfor key, value in zip(keys, values):\n    if key != value and value % 5:\n        x[key] =value \nprint(x)",
      "outputs": []
    },
    {
      "cell_index": 107,
      "week": 3,
      "cell_type": "markdown",
      "topic": "hw_question9",
      "is_advanced_optional": false,
      "source": "### Question 9",
      "outputs": []
    },
    {
      "cell_index": 108,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question9",
      "is_advanced_optional": false,
      "source": "x = [5, 10, 15, 20]; a = 4; b = 9; c = 13; d = 15\ncats = []\nfor element in x:\n    if element > a:\n        cats.append(\"cat1\")\n    elif element < b:\n        cats.append(\"cat2\")\n    elif element <= c:\n        cats.append(\"cat3\")\n    elif element >= d:\n        cats.append(\"cat4\")\n    else:\n        cats.append(\"catunknown\")\nprint(cats)",
      "outputs": []
    },
    {
      "cell_index": 109,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question9",
      "is_advanced_optional": false,
      "source": "x = [5, 10, 15, 20]; a = 4; b = 9; c = 13; d = 15\ncats = []\nfor element in x:\n    if element >= d:\n        cats.append(\"cat4\")\n    elif element <= c:\n        cats.append(\"cat3\")\n    elif element < b:\n        cats.append(\"cat2\")\n    elif element > a:\n        cats.append(\"cat1\")\n    else:\n        cats.append(\"catunknown\")\nprint(cats)",
      "outputs": []
    },
    {
      "cell_index": 110,
      "week": 3,
      "cell_type": "code",
      "topic": "hw_question9",
      "is_advanced_optional": false,
      "source": "x = [5, 10, 15, 20]; a = 4; b = 9; c = 13; d = 15\ncats = []\nfor element in x:\n    result = \"catunknown\"\n    if element > a:\n        result = \"cat1\"\n    if element < b:\n        result = \"cat2\"\n    if element <= c:\n        result = \"cat3\"\n    if element >= d:\n        result = \"cat4\"\n    cats.append(result)    \nprint(cats)",
      "outputs": []
    }
  ],
  "exams": [
    {
      "source": "trial midterm.pdf",
      "exam_label": "trial_midterm",
      "year": "2024-2025",
      "note": "Trial midterm published 15/04/2025. Answers derived by code analysis — no answer key in PDF.",
      "questions": [
        {
          "number": 1,
          "topic": "indexing / slicing",
          "week": 1,
          "question": "What is the output of the following code?\n\nx = 'Hello, World!'\nprint(x[-6:-1])",
          "options": {
            "A": "World",
            "B": "orld!",
            "C": "World!",
            "D": "orld"
          },
          "correct": "A",
          "explanation": "x[-6:-1] starts 6 from the end ('W') and goes to 1 from the end (exclusive of '!'). That gives 'World'."
        },
        {
          "number": 2,
          "topic": "mutable / immutable",
          "week": 1,
          "question": "What is the output of the following code?\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
          "options": {
            "A": "[1, 2, 3]",
            "B": "[1, 2, 3, 4]",
            "C": "[4, 1, 2, 3]",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "y = x makes y point to the same list object. Appending to y also modifies x since they reference the same list."
        },
        {
          "number": 3,
          "topic": "type conversion",
          "week": 1,
          "question": "What is the output of the following code?\n\nx = '5'\ny = 2\nprint(x * y)",
          "options": {
            "A": "10",
            "B": "52",
            "C": "55",
            "D": "Error"
          },
          "correct": "C",
          "explanation": "String * integer repeats the string. '5' * 2 = '55'."
        },
        {
          "number": 4,
          "topic": "slicing",
          "week": 1,
          "question": "What is the output of the following code?\n\nx = [0, 1, 2, 3, 4, 5]\nprint(x[1:5:2])",
          "options": {
            "A": "[1, 3]",
            "B": "[1, 2, 3, 4]",
            "C": "[0, 2, 4]",
            "D": "[1, 2]"
          },
          "correct": "A",
          "explanation": "x[1:5:2] starts at index 1, stops before index 5, step 2. Gives elements at indices 1 and 3: [1, 3]."
        },
        {
          "number": 5,
          "topic": "identity / is operator",
          "week": 1,
          "question": "What is the output of the following code?\n\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b, a is b)",
          "options": {
            "A": "True True",
            "B": "False False",
            "C": "True False",
            "D": "False True"
          },
          "correct": "C",
          "explanation": "a == b compares values (True). a is b checks identity — they are different objects (False)."
        },
        {
          "number": 6,
          "topic": "dictionaries",
          "week": 2,
          "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
          "options": {
            "A": "True",
            "B": "False",
            "C": "Error",
            "D": "None"
          },
          "correct": "B",
          "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
        },
        {
          "number": 7,
          "topic": "lists / append vs extend",
          "week": 2,
          "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst.append([4, 5])\nprint(len(lst))",
          "options": {
            "A": "4",
            "B": "5",
            "C": "6",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "append adds the list [4, 5] as a single element. The list becomes [1, 2, 3, [4, 5]], length 4."
        },
        {
          "number": 8,
          "topic": "truthy / falsy",
          "week": 2,
          "question": "Which of the following values is truthy in Python?",
          "options": {
            "A": "0",
            "B": "''",
            "C": "[]",
            "D": "' '"
          },
          "correct": "D",
          "explanation": "A string with at least one space is truthy. 0, empty string, and empty list are all falsy."
        },
        {
          "number": 9,
          "topic": "for loops / range",
          "week": 2,
          "question": "What is the output of the following code?\n\nresult = 0\nfor i in range(1, 6):\n    result += i\nprint(result)",
          "options": {
            "A": "10",
            "B": "15",
            "C": "21",
            "D": "6"
          },
          "correct": "B",
          "explanation": "range(1,6) gives 1,2,3,4,5. Sum = 15."
        },
        {
          "number": 10,
          "topic": "while loops / walrus operator",
          "week": 2,
          "question": "What is the output of the following code?\n\nnumbers = [1, 3, 5, 2, 7]\nresult = []\nfor num in numbers:\n    if num % 2 == 0:\n        result.append(num)\nprint(result)",
          "options": {
            "A": "[1, 3, 5, 7]",
            "B": "[2]",
            "C": "[]",
            "D": "[1, 3, 5, 2, 7]"
          },
          "correct": "B",
          "explanation": "Only 2 is even in the list. result = [2]."
        },
        {
          "number": 11,
          "topic": "scope / global",
          "week": 3,
          "question": "What is the output of the following code?\n\nx = 10\ndef modify():\n    x = 20\n    print(x)\nmodify()\nprint(x)",
          "options": {
            "A": "20\n20",
            "B": "10\n10",
            "C": "20\n10",
            "D": "10\n20"
          },
          "correct": "C",
          "explanation": "Inside modify(), x = 20 creates a local variable. Printing inside gives 20. After the call, global x is still 10."
        },
        {
          "number": 12,
          "topic": "scope / UnboundLocalError",
          "week": 3,
          "question": "What is the output of the following code?\n\nx = 5\ndef func():\n    print(x)\n    x = 10\nfunc()",
          "options": {
            "A": "5",
            "B": "10",
            "C": "UnboundLocalError",
            "D": "None"
          },
          "correct": "C",
          "explanation": "Because x is assigned inside func(), Python treats x as local throughout the function. Printing x before assignment raises UnboundLocalError."
        },
        {
          "number": 13,
          "topic": "default arguments / mutable defaults",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef add_item(item, lst=[]):\n    lst.append(item)\n    return lst\n\nprint(add_item(1))\nprint(add_item(2))\nprint(add_item(3))",
          "options": {
            "A": "[1]\n[2]\n[3]",
            "B": "[1]\n[1, 2]\n[1, 2, 3]",
            "C": "[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "The default list [] is created once when the function is defined and shared across all calls. Each call appends to the same list."
        },
        {
          "number": 14,
          "topic": "*args",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(*args):\n    return sum(args)\n\nprint(func(1, 2, 3, 4, 5))",
          "options": {
            "A": "15",
            "B": "(1, 2, 3, 4, 5)",
            "C": "[1, 2, 3, 4, 5]",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "*args collects all positional arguments as a tuple. sum((1,2,3,4,5)) = 15."
        },
        {
          "number": 15,
          "topic": "lambda",
          "week": 3,
          "question": "What is the output of the following code?\n\ndouble = lambda x: x * 2\nprint(double(5))",
          "options": {
            "A": "25",
            "B": "10",
            "C": "52",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "The lambda multiplies its argument by 2. double(5) = 5 * 2 = 10."
        },
        {
          "number": 16,
          "topic": "map function",
          "week": 3,
          "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)",
          "options": {
            "A": "[1, 4, 9, 16, 25]",
            "B": "[2, 4, 6, 8, 10]",
            "C": "[1, 2, 3, 4, 5]",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "map applies the lambda (x**2) to each element: [1, 4, 9, 16, 25]."
        },
        {
          "number": 17,
          "topic": "filter function",
          "week": 3,
          "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5, 6]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)",
          "options": {
            "A": "[1, 3, 5]",
            "B": "[2, 4, 6]",
            "C": "[1, 2, 3, 4, 5, 6]",
            "D": "[]"
          },
          "correct": "B",
          "explanation": "filter keeps elements for which the lambda returns True. Even numbers: [2, 4, 6]."
        },
        {
          "number": 18,
          "topic": "sorted / key",
          "week": 3,
          "question": "What is the output of the following code?\n\nwords = ['banana', 'apple', 'cherry', 'date']\nsorted_words = sorted(words, key=len)\nprint(sorted_words)",
          "options": {
            "A": "['apple', 'banana', 'cherry', 'date']",
            "B": "['date', 'apple', 'banana', 'cherry']",
            "C": "['apple', 'date', 'banana', 'cherry']",
            "D": "['cherry', 'banana', 'apple', 'date']"
          },
          "correct": "B",
          "explanation": "sorted by len: date(4), apple(5), banana(6), cherry(6). Ties in len preserve original order: ['date', 'apple', 'banana', 'cherry']."
        },
        {
          "number": 19,
          "topic": "function factories / closures",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = make_multiplier(3)\nprint(times3(5))",
          "options": {
            "A": "15",
            "B": "8",
            "C": "3",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "make_multiplier(3) returns a closure that multiplies by 3. times3(5) = 5 * 3 = 15."
        },
        {
          "number": 20,
          "topic": "mutable args",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef append_to(element, to):\n    to.append(element)\n    return to\n\nmy_list = []\nresult1 = append_to(1, my_list)\nresult2 = append_to(2, my_list)\nprint(result1)\nprint(result2)",
          "options": {
            "A": "[1]\n[2]",
            "B": "[1]\n[1, 2]",
            "C": "[1, 2]\n[1, 2]",
            "D": "Error"
          },
          "correct": "C",
          "explanation": "Both result1 and result2 refer to the same list my_list. After both calls, my_list = [1, 2], so both prints show [1, 2]."
        },
        {
          "number": 21,
          "topic": "nested loops",
          "week": 3,
          "question": "What is the output of the following code?\n\nresult = []\nfor i in range(3):\n    for j in range(3):\n        if i == j:\n            result.append((i, j))\nprint(result)",
          "options": {
            "A": "[(0,0), (1,1), (2,2)]",
            "B": "[(0,1), (0,2), (1,2)]",
            "C": "[(0,0), (0,1), (0,2)]",
            "D": "[]"
          },
          "correct": "A",
          "explanation": "Only pairs where i == j: (0,0), (1,1), (2,2)."
        },
        {
          "number": 22,
          "topic": "keyword args / **kwargs",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef greet(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\ngreet(name='Alice', age=30)",
          "options": {
            "A": "name: Alice\nage: 30",
            "B": "Alice: name\n30: age",
            "C": "{'name': 'Alice', 'age': 30}",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "**kwargs collects keyword arguments as a dict. Iterating items() gives key-value pairs: name: Alice, age: 30."
        },
        {
          "number": 23,
          "topic": "reduce function",
          "week": 3,
          "question": "What is the output of the following code?\n\nfrom functools import reduce\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, numbers)\nprint(result)",
          "options": {
            "A": "15",
            "B": "120",
            "C": "24",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "reduce multiplies left to right: 1*2=2, 2*3=6, 6*4=24, 24*5=120."
        },
        {
          "number": 24,
          "topic": "for vs while / loop control",
          "week": 3,
          "question": "What is the output of the following code?\n\nresult = []\ni = 0\nwhile i < 5:\n    if i % 2 == 0:\n        result.append(i)\n    i += 1\nprint(result)",
          "options": {
            "A": "[1, 3]",
            "B": "[0, 2, 4]",
            "C": "[0, 1, 2, 3, 4]",
            "D": "[2, 4]"
          },
          "correct": "B",
          "explanation": "Loop i=0..4, appending even values: 0, 2, 4. Result = [0, 2, 4]."
        }
      ]
    },
    {
      "source": "2023.pdf",
      "exam_label": "midterm_2023",
      "year": "2022-2023",
      "note": "Trial midterm 22/23. Scanned PDF — answers read from filled radio buttons. Some question text reconstructed from visual inspection.",
      "questions": [
        {
          "number": 1,
          "topic": "objects / identity",
          "week": 1,
          "question": "What is the output of the following code?\n\nx = 257\ny = 257\nprint(x is y)",
          "options": {
            "A": "True",
            "B": "False",
            "C": "Error",
            "D": "None"
          },
          "correct": "B",
          "explanation": "For integers outside the range [-5, 256], Python does not guarantee interning. Two separate 257 literals are different objects, so 'is' returns False."
        },
        {
          "number": 2,
          "topic": "slicing",
          "week": 1,
          "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[::2])",
          "options": {
            "A": "[10, 30, 50]",
            "B": "[20, 40]",
            "C": "[10, 20, 30, 40, 50]",
            "D": "[50, 30, 10]"
          },
          "correct": "A",
          "explanation": "lst[::2] takes every other element starting from index 0: [10, 30, 50]."
        },
        {
          "number": 3,
          "topic": "mutable / immutable",
          "week": 1,
          "question": "Which of the following is immutable in Python?\n\na) list\nb) dict\nc) tuple\nd) set",
          "options": {
            "A": "list",
            "B": "dict",
            "C": "tuple",
            "D": "set"
          },
          "correct": "C",
          "explanation": "Tuples are immutable — their elements cannot be changed after creation. Lists, dicts, and sets are mutable."
        },
        {
          "number": 4,
          "topic": "string indexing",
          "week": 1,
          "question": "What is the output of the following code?\n\ns = 'Python'\nprint(s[1:4])",
          "options": {
            "A": "Pyt",
            "B": "yth",
            "C": "ytho",
            "D": "ython"
          },
          "correct": "B",
          "explanation": "s[1:4] gives characters at indices 1, 2, 3: 'y', 't', 'h' = 'yth'."
        },
        {
          "number": 5,
          "topic": "dictionaries",
          "week": 2,
          "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
          "options": {
            "A": "2",
            "B": "3",
            "C": "4",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
        },
        {
          "number": 6,
          "topic": "lists",
          "week": 2,
          "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
          "options": {
            "A": "[1, 2, 3]\n[1, 2, 3, 4]",
            "B": "[1, 2, 3, 4]\n[1, 2, 3, 4]",
            "C": "[1, 2, 3]\n[1, 2, 3]",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "lst[:] creates a shallow copy. Modifying lst2 does not affect lst. lst stays [1,2,3], lst2 becomes [1,2,3,4]."
        },
        {
          "number": 7,
          "topic": "conditions / truthy falsy",
          "week": 2,
          "question": "What is the output of the following code?\n\nx = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')",
          "options": {
            "A": "truthy",
            "B": "falsy",
            "C": "0",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "0 is falsy in Python. The else branch executes, printing 'falsy'."
        },
        {
          "number": 8,
          "topic": "for loops / enumerate",
          "week": 2,
          "question": "What is the output of the following code?\n\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
          "options": {
            "A": "0 apple\n1 banana\n2 cherry",
            "B": "1 apple\n2 banana\n3 cherry",
            "C": "apple 0\nbanana 1\ncherry 2",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "enumerate starts at 0 by default and yields (index, value) pairs."
        },
        {
          "number": 9,
          "topic": "scope / global",
          "week": 3,
          "question": "What is the output of the following code?\n\ncount = 0\ndef increment():\n    global count\n    count += 1\n\nincrement()\nincrement()\nprint(count)",
          "options": {
            "A": "0",
            "B": "1",
            "C": "2",
            "D": "Error"
          },
          "correct": "C",
          "explanation": "The global keyword lets increment() modify the global count. After two calls, count = 2."
        },
        {
          "number": 10,
          "topic": "return statement",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func():\n    return 1, 2, 3\n\nresult = func()\nprint(type(result))",
          "options": {
            "A": "<class 'list'>",
            "B": "<class 'tuple'>",
            "C": "<class 'int'>",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "Returning multiple values with commas creates a tuple. type(result) is tuple."
        },
        {
          "number": 11,
          "topic": "default args",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef greet(name, greeting='Hello'):\n    print(f'{greeting}, {name}!')\n\ngreet('Alice')\ngreet('Bob', 'Hi')",
          "options": {
            "A": "Hello, Alice!\nHi, Bob!",
            "B": "Hi, Alice!\nHello, Bob!",
            "C": "Hello, Alice!\nHello, Bob!",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "First call uses default greeting 'Hello'. Second call overrides with 'Hi'."
        },
        {
          "number": 12,
          "topic": "lambda / sorted",
          "week": 3,
          "question": "What is the output of the following code?\n\npairs = [(1, 3), (2, 1), (3, 2)]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nprint(sorted_pairs)",
          "options": {
            "A": "[(1, 3), (2, 1), (3, 2)]",
            "B": "[(2, 1), (3, 2), (1, 3)]",
            "C": "[(3, 2), (2, 1), (1, 3)]",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "Sorted by second element (x[1]): 1 < 2 < 3. Result: [(2,1), (3,2), (1,3)]."
        },
        {
          "number": 13,
          "topic": "map / filter",
          "week": 3,
          "question": "What is the output of the following code?\n\nnums = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x > 2, map(lambda x: x * 2, nums)))\nprint(result)",
          "options": {
            "A": "[6, 8, 10]",
            "B": "[2, 4, 6, 8, 10]",
            "C": "[3, 4, 5]",
            "D": "[4, 6, 8, 10]"
          },
          "correct": "A",
          "explanation": "map doubles: [2,4,6,8,10]. filter keeps >2: [4,6,8,10]... wait, 4>2, 6>2, 8>2, 10>2 so [4,6,8,10]. But 2 is not >2 so filtered out. Result: [4, 6, 8, 10].",
          "correct_override": "D",
          "note": "map doubles [1,2,3,4,5] -> [2,4,6,8,10]. filter(x>2) keeps [4,6,8,10]. Correct answer is D."
        },
        {
          "number": 14,
          "topic": "*args / **kwargs",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\n\nfunc(1, 2, 3, 4, x=5, y=6)",
          "options": {
            "A": "1 2 (3, 4) {'x': 5, 'y': 6}",
            "B": "1 2 [3, 4] {'x': 5, 'y': 6}",
            "C": "1 2 3 4 5 6",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "a=1, b=2, args=(3,4) as tuple, kwargs={'x':5,'y':6} as dict."
        },
        {
          "number": 15,
          "topic": "nested functions / scope",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
          "options": {
            "A": "10",
            "B": "None",
            "C": "Error",
            "D": "0"
          },
          "correct": "A",
          "explanation": "inner() can access x from the enclosing scope (closure). Prints 10."
        },
        {
          "number": 16,
          "topic": "zip / looping",
          "week": 2,
          "question": "What is the output of the following code?\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
          "options": {
            "A": "Alice: 85\nBob: 92\nCharlie: 78",
            "B": "Alice: 92\nBob: 85\nCharlie: 78",
            "C": "Alice Bob Charlie: 85 92 78",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "zip pairs elements positionally. Output: Alice: 85, Bob: 92, Charlie: 78."
        }
      ]
    },
    {
      "source": "2024.pdf",
      "exam_label": "midterm_2024",
      "year": "2023-2024",
      "note": "Trial midterm 23/24. Answers read from boxed letters in PDF.",
      "questions": [
        {
          "number": 1,
          "topic": "objects / types",
          "week": 1,
          "question": "What is the output of the following code?\n\nprint(type(True))",
          "options": {
            "A": "<class 'int'>",
            "B": "<class 'bool'>",
            "C": "<class 'str'>",
            "D": "<class 'NoneType'>"
          },
          "correct": "B",
          "explanation": "True is of type bool in Python."
        },
        {
          "number": 2,
          "topic": "mutable / immutable",
          "week": 1,
          "question": "What is the output of the following code?\n\nt = (1, 2, 3)\nt[0] = 10",
          "options": {
            "A": "(10, 2, 3)",
            "B": "(1, 2, 3)",
            "C": "TypeError",
            "D": "None"
          },
          "correct": "C",
          "explanation": "Tuples are immutable. Attempting to assign to an index raises TypeError."
        },
        {
          "number": 3,
          "topic": "slicing",
          "week": 1,
          "question": "What is the output of the following code?\n\ns = 'abcdef'\nprint(s[2:5])",
          "options": {
            "A": "bcd",
            "B": "cde",
            "C": "cdef",
            "D": "bcde"
          },
          "correct": "B",
          "explanation": "s[2:5] gives characters at indices 2,3,4: 'c','d','e' = 'cde'."
        },
        {
          "number": 4,
          "topic": "indexing / negative",
          "week": 1,
          "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[-2])",
          "options": {
            "A": "20",
            "B": "30",
            "C": "40",
            "D": "50"
          },
          "correct": "C",
          "explanation": "lst[-2] is the second-to-last element: 40."
        },
        {
          "number": 5,
          "topic": "type conversion",
          "week": 1,
          "question": "What is the output of the following code?\n\nprint(int('42') + float('3.5'))",
          "options": {
            "A": "45",
            "B": "45.5",
            "C": "'423.5'",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "int('42')=42, float('3.5')=3.5. 42 + 3.5 = 45.5."
        },
        {
          "number": 6,
          "topic": "augmented operators",
          "week": 2,
          "question": "What is the output of the following code?\n\nx = 10\nx //= 3\nprint(x)",
          "options": {
            "A": "3",
            "B": "3.33",
            "C": "4",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "//= is floor division assignment. 10 // 3 = 3."
        },
        {
          "number": 7,
          "topic": "dictionaries",
          "week": 2,
          "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
          "options": {
            "A": "{'x': 1, 'z': 3}",
            "B": "{'x': 1, 'y': 2, 'z': 3}",
            "C": "{'y': 2}",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
        },
        {
          "number": 8,
          "topic": "sets",
          "week": 2,
          "question": "What is the output of the following code?\n\ns = {1, 2, 3, 2, 1}\nprint(len(s))",
          "options": {
            "A": "5",
            "B": "3",
            "C": "2",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "Sets do not allow duplicates. {1,2,3,2,1} has 3 unique elements."
        },
        {
          "number": 9,
          "topic": "conditions / conditional expression",
          "week": 2,
          "question": "What is the output of the following code?\n\nx = 7\nresult = 'odd' if x % 2 != 0 else 'even'\nprint(result)",
          "options": {
            "A": "even",
            "B": "odd",
            "C": "7",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "7 % 2 = 1 != 0, so result = 'odd'."
        },
        {
          "number": 10,
          "topic": "for loops / enumerate",
          "week": 2,
          "question": "What is the output of the following code?\n\nlst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
          "options": {
            "A": "0 a\n1 b\n2 c",
            "B": "1 a\n2 b\n3 c",
            "C": "a 1\nb 2\nc 3",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "enumerate(lst, start=1) begins counting at 1. Output: 1 a, 2 b, 3 c."
        },
        {
          "number": 11,
          "topic": "while loops",
          "week": 2,
          "question": "What is the output of the following code?\n\nn = 1\nwhile n < 32:\n    n *= 2\nprint(n)",
          "options": {
            "A": "16",
            "B": "32",
            "C": "64",
            "D": "31"
          },
          "correct": "B",
          "explanation": "n: 1->2->4->8->16->32. 32 < 32 is False, loop stops. print(n) = 32."
        },
        {
          "number": 12,
          "topic": "truthy / falsy",
          "week": 2,
          "question": "Which of the following expressions evaluates to True?",
          "options": {
            "A": "bool([])",
            "B": "bool(0)",
            "C": "bool('')",
            "D": "bool([0])"
          },
          "correct": "D",
          "explanation": "A list with one element [0] is truthy even though the element itself is falsy. [], 0, and '' are all falsy."
        },
        {
          "number": 13,
          "topic": "scope / UnboundLocalError",
          "week": 3,
          "question": "What is the output of the following code?\n\ny = 100\ndef func():\n    y += 1\n    return y\nprint(func())",
          "options": {
            "A": "101",
            "B": "100",
            "C": "UnboundLocalError",
            "D": "None"
          },
          "correct": "C",
          "explanation": "y += 1 makes y local to func(). But y hasn't been assigned locally before this line, causing UnboundLocalError."
        },
        {
          "number": 14,
          "topic": "return / None",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(x):\n    if x > 0:\n        return x\n\nprint(func(-1))",
          "options": {
            "A": "-1",
            "B": "0",
            "C": "None",
            "D": "Error"
          },
          "correct": "C",
          "explanation": "func(-1): condition x>0 is False, function falls through without a return statement and implicitly returns None."
        },
        {
          "number": 15,
          "topic": "positional / keyword args",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(a, b, c):\n    return a - b + c\n\nprint(func(c=3, a=1, b=2))",
          "options": {
            "A": "0",
            "B": "2",
            "C": "-4",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "a=1, b=2, c=3. 1 - 2 + 3 = 2."
        },
        {
          "number": 16,
          "topic": "default args / mutable defaults",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))\nprint(func(3, []))",
          "options": {
            "A": "[1]\n[2]\n[3]",
            "B": "[1]\n[1, 2]\n[3]",
            "C": "[1]\n[1, 2]\n[1, 2, 3]",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "func(1) and func(2) share the default list: [1] then [1,2]. func(3,[]) uses a fresh list: [3]."
        },
        {
          "number": 17,
          "topic": "*args",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef func(*args):\n    print(type(args))\n\nfunc(1, 2, 3)",
          "options": {
            "A": "<class 'list'>",
            "B": "<class 'tuple'>",
            "C": "<class 'dict'>",
            "D": "<class 'set'>"
          },
          "correct": "B",
          "explanation": "*args collects positional arguments as a tuple."
        },
        {
          "number": 18,
          "topic": "lambda",
          "week": 3,
          "question": "What is the output of the following code?\n\nf = lambda x, y: x if x > y else y\nprint(f(3, 7))",
          "options": {
            "A": "3",
            "B": "7",
            "C": "10",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "3 > 7 is False, so the lambda returns y = 7."
        },
        {
          "number": 19,
          "topic": "map function",
          "week": 3,
          "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nresult = list(map(str, lst))\nprint(result)",
          "options": {
            "A": "[1, 2, 3]",
            "B": "['1', '2', '3']",
            "C": "['str', 'str', 'str']",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "map(str, lst) converts each integer to string. Result: ['1', '2', '3']."
        },
        {
          "number": 20,
          "topic": "filter function",
          "week": 3,
          "question": "What is the output of the following code?\n\nlst = [0, 1, 2, 0, 3, 0]\nresult = list(filter(None, lst))\nprint(result)",
          "options": {
            "A": "[0, 0, 0]",
            "B": "[1, 2, 3]",
            "C": "[0, 1, 2, 0, 3, 0]",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "filter(None, lst) keeps truthy values. 0 is falsy, so it filters out all 0s: [1, 2, 3]."
        },
        {
          "number": 21,
          "topic": "sorted / key",
          "week": 3,
          "question": "What is the output of the following code?\n\nlst = [-3, 1, -2, 4, -1]\nsorted_lst = sorted(lst, key=abs)\nprint(sorted_lst)",
          "options": {
            "A": "[-1, 1, -2, -3, 4]",
            "B": "[-3, -2, -1, 1, 4]",
            "C": "[-1, 1, -2, -3, 4]",
            "D": "[1, -1, -2, -3, 4]"
          },
          "correct": "C",
          "explanation": "Sorted by absolute value: abs values are 3,1,2,4,1. Order: 1,-1(tie→original order),-2,-3,4 → [-1, 1, -2, -3, 4]. Wait: sorted by abs: 1(idx1), 1(idx4=-1), 2(idx2=-2), 3(idx0=-3), 4(idx3=4). Result: [1, -1, -2, -3, 4].",
          "correct_override": "D",
          "note": "Sorted by abs value ascending: abs=1 (value 1), abs=1 (value -1), abs=2 (value -2), abs=3 (value -3), abs=4 (value 4). Stable sort preserves original order for ties. Result: [1, -1, -2, -3, 4]. Correct answer is D."
        },
        {
          "number": 22,
          "topic": "function factories / closures",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())\nprint(c())",
          "options": {
            "A": "1\n1\n1",
            "B": "1\n2\n3",
            "C": "0\n1\n2",
            "D": "Error"
          },
          "correct": "B",
          "explanation": "nonlocal allows increment() to modify count in the enclosing scope. Each call increments count: 1, 2, 3."
        },
        {
          "number": 23,
          "topic": "mutable args / side effects",
          "week": 3,
          "question": "What is the output of the following code?\n\ndef double_list(lst):\n    lst = [x * 2 for x in lst]\n    return lst\n\nmy_list = [1, 2, 3]\nresult = double_list(my_list)\nprint(my_list)\nprint(result)",
          "options": {
            "A": "[1, 2, 3]\n[2, 4, 6]",
            "B": "[2, 4, 6]\n[2, 4, 6]",
            "C": "[1, 2, 3]\n[1, 2, 3]",
            "D": "Error"
          },
          "correct": "A",
          "explanation": "Inside the function, lst = [...] rebinds the local name to a new list. my_list is not modified. result is [2,4,6]."
        },
        {
          "number": 24,
          "topic": "nested loops / complexity",
          "week": 3,
          "question": "What is the output of the following code?\n\ncount = 0\nfor i in range(4):\n    for j in range(i):\n        count += 1\nprint(count)",
          "options": {
            "A": "4",
            "B": "6",
            "C": "10",
            "D": "16"
          },
          "correct": "B",
          "explanation": "i=0: j in range(0) → 0 iterations. i=1: 1. i=2: 2. i=3: 3. Total: 0+1+2+3 = 6."
        }
      ]
    },
    {
      "source": "Midterm Extra Practice.txt",
      "exam_label": "extra_practice",
      "year": "unknown",
      "note": "Extra practice questions. Answers derived by code analysis — no key in file.",
      "questions": [
        {
          "number": 1,
          "topic": "lists / sets / duplicates",
          "week": 2,
          "question": "Suppose you have the following function:\n\ndef func1(l1):\n    return len(list(l1))==len(set(l1))\n\nWhich of the functions below returns the same values as the function above, if we call it in any of the following ways?\n\nfunc1(l1 = [1,2,3])\nfunc1(l1 = [1,2,2])\nfunc1(l1 = (1,2,2))",
          "options": {
            "a": "def func1(l1):\n    counter = 0\n    for element in l1:\n        if l1.count(element)>1:\n            counter += 1\n    return (counter == 0)",
            "b": "def func1(l1):\n    counter = []\n    for element in l1:\n        if element in l1[l1.index(element)+1:]:\n            counter.append(element)\n    return (len(counter) == 0)",
            "c": "Neither function returns the same values.",
            "d": "Both functions return the same values."
          },
          "correct": "c",
          "explanation": "Option a: for (1,2,2), tuple has no .count() — wait, actually tuples DO have .count(). For [1,2,2]: element 2 has count>1 so counter=2, returns False. Original returns False. But for a tuple (1,2,2): tuple has .count(), works. But option b: l1[l1.index(element)+1:] — tuples support slicing and indexing too. Let's re-examine: for a tuple (1,2,2), both a and b should work the same. Actually option a counts ALL duplicated elements (counts 2 twice for [1,2,2]), making counter=2, so counter==0 is False. Original is False too. Both match. For option b applied to tuple: l1[l1.index(element)+1:] works for tuples too. Actually both a and b return same values as original. Correct: d.",
          "correct_override": "d",
          "note": "Both a and b correctly identify duplicates for lists and tuples. The original function checks if len without duplicates equals len with duplicates. Both implementations correctly return the same boolean."
        },
        {
          "number": 2,
          "topic": "scope / global",
          "week": 3,
          "question": "val = 2\ndef func():\n    val = 3\n    print(val)\nfunc()\nprint(val)\n\nWhich of the following code snippets produces the same output as the above code snippet?",
          "options": {
            "a": "val1 = 2\ndef func1():\n    val1 = val1 + 1\n    print(val1)\nfunc1()\nprint(val1)",
            "b": "val2 = 2\ndef func2():\n    global val2\n    val2 = val2 + 1\n    print(val2)\nfunc2()\nprint(val2)",
            "c": "val3 = 2\ndef func3():\n    val3 = 3\n    def innerfunc():\n        val3 = 2\n        print(val3)\n    print(val3)\nfunc3()\nprint(val3)",
            "d": "val4 = 2\ndef func4():\n    val4 = 3\n    def innerfunc():\n        val4 = 2\n        print(val4)\n    print(val4)\nfunc4()\ninnerfunc()"
          },
          "correct": "c",
          "explanation": "Original output: 3, 2. Option a: UnboundLocalError (val1 used before local assignment). Option b: global val2 modified to 3, print 3, then print val2=3. Output: 3,3. Option c: func3 creates local val3=3, prints 3. Global val3=2 unchanged, prints 2. Output: 3,2. Matches! Option d: innerfunc() called outside func4 scope — NameError. Correct: c."
        },
        {
          "number": 3,
          "topic": "dictionaries / nested dicts",
          "week": 2,
          "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
          "options": {
            "a": "Snippet using allscores list + max/min",
            "b": "Snippet using nested max/min directly on scorelist.values()",
            "c": "Both code snippets will work as intended.",
            "d": "Neither code snippet will work as intended."
          },
          "correct": "c",
          "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
        },
        {
          "number": 4,
          "topic": "dictionaries / average",
          "week": 2,
          "question": "math_scores = {'John': 85, 'Sarah': 92, 'Michael': 78, 'Emma': 90, 'David': 82}\n\nYou want to find and print the names of the students who scored above the average score.\n\nWhich of the following code segments will work as intended?",
          "options": {
            "a": "average_score = sum(math_scores.values())/len(math_scores)\n\tfor student in math_scores.keys():\n\t\tif math_scores[student] > average_score:\n\t\t\tprint(student)",
            "b": "for student in math_scores:\n\tif math_scores[student] > (sum(math_scores.values())/len(math_scores)):\n\t\tprint(student)",
            "c": "Both code segments will work as intended.",
            "d": "Neither code segment will work as intended."
          },
          "correct": "d",
          "explanation": "Option a has an indentation error (the for loop is indented under the average_score line as if it's a block, but there's no colon). This causes an IndentationError. Option b works correctly. Actually option a depends on whether the indentation shown is a tab after a plain statement — in Python that's an IndentationError. So only b works. Correct: b.",
          "correct_override": "b",
          "note": "Option a has a misleading indentation (tab before for loop on a non-compound statement line), which would cause IndentationError. Only option b works correctly."
        },
        {
          "number": 5,
          "topic": "dictionaries / zip / counting",
          "week": 2,
          "question": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\nYou need to create a dictionary called grade_counts that counts the number of students in each grade level.\n\nExpected: {9:3, 10:2, 11:1}\n\nWhich of the following code segments will work as intended?",
          "options": {
            "a": "grade_counts = {}\nfor grade in grades:\n\tif grade not in grade_counts:\n\t\tgrade_counts[grade] = 0\n\tgrade_counts[grade] += 1",
            "b": "grade_counts = {}\nfor student, grade in zip(students, grades):\n\tif grade in grade_counts:\n\t\tgrade_counts[grade].append(student)\n\telse:\n\t\tgrade_counts[grade] = [student]",
            "c": "Both of the given options will work as intended.",
            "d": "Neither of the given options will work as intended."
          },
          "correct": "a",
          "explanation": "Option a correctly counts grades: initialises to 0 and increments. Produces {9:3, 10:2, 11:1}. Option b creates lists of student names, not counts — produces {9:['A','C','F'], 10:['B','E'], 11:['D']}, not the required format. Correct: a."
        },
        {
          "number": 6,
          "topic": "slicing / negative step",
          "week": 1,
          "question": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nWhich of the following lines of code will NOT create a list with the name subset, and the value [10, 8, 6, 4, 2]?",
          "options": {
            "a": "subset = numbers[-1::-2]",
            "b": "subset = numbers[::-2]",
            "c": "subset = numbers[::-1][::2]",
            "d": "subset = numbers[::2][::-1]"
          },
          "correct": "d",
          "explanation": "a: starts at -1 (10), step -2: [10,8,6,4,2]. Correct. b: [::-2] starts at last (10), step -2: [10,8,6,4,2]. Correct. c: [::-1] reverses to [10,9,8,7,6,5,4,3,2,1], then [::2] takes every 2nd: [10,8,6,4,2]. Correct. d: [::2] gives [1,3,5,7,9], then [::-1] reverses: [9,7,5,3,1]. This does NOT give [10,8,6,4,2]. Correct answer (the one that does NOT work): d."
        },
        {
          "number": 7,
          "topic": "return / None / global",
          "week": 3,
          "question": "def multiply(num1, num2):\n\tglobal result\n\tresult = num1 * num2\n\nprint(multiply(2, 3))\nprint(result)",
          "options": {
            "a": "6\n6",
            "b": "None\n6",
            "c": "6\nNone",
            "d": "None\nNone"
          },
          "correct": "b",
          "explanation": "multiply() has no return statement, so it returns None. print(multiply(2,3)) prints None. But inside, global result is set to 6. print(result) prints 6. Output: None, 6."
        },
        {
          "number": 8,
          "topic": "dictionaries / indexing",
          "week": 2,
          "question": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\n\nWhich of the following lines of code will print True?",
          "options": {
            "a": "print(x['a'][1] * x['b'][0] == x['c'][1])",
            "b": "print(x['b'][0] + x['c'][0] == x['d'][1])",
            "c": "print(x['d'][0] - x['c'][0] == x['a'][1])",
            "d": "All of the above."
          },
          "correct": "d",
          "explanation": "a: x['a'][1]=2, x['b'][0]=3, 2*3=6, x['c'][1]=6. True. b: x['b'][0]=3, x['c'][0]=5, 3+5=8, x['d'][1]=8. True. c: x['d'][0]=7, x['c'][0]=5, 7-5=2, x['a'][1]=2. True. All are True, so d is correct."
        },
        {
          "number": 9,
          "topic": "*args / passing to function",
          "week": 3,
          "question": "Assume sum_even_in_list(l1) filters non-integers and sums even integers.\n\nYou want sum_even_integers that accepts a flexible number of arguments.\n\nFor example: sum_even_integers(1,'2', 3.0, 4) should return 4.\n\nWhich of the following function definitions will work as intended?",
          "options": {
            "a": "def sum_even_integers(*args):\n\treturn sum_even_in_list(args)",
            "b": "def sum_even_integers(*args):\n\treturn sum([x for x in args if type(x) == int and x%2 == 0])",
            "c": "def sum_even_integers(*args):\n\tresult = 0\n\tfor x in args:\n\t\tif type(x) == int and x%2 == 0:\n\t\t\tresult += x\n\treturn result",
            "d": "All of the above."
          },
          "correct": "d",
          "explanation": "a: *args creates a tuple, sum_even_in_list accepts any iterable so passing a tuple works. b: list comprehension on tuple works fine. c: direct iteration over tuple works. All three produce the same result. Correct: d."
        },
        {
          "number": 10,
          "topic": "nested loops / pairs",
          "week": 3,
          "question": "You need to write a function main(target_num, list_num) that returns all unique pairs of numbers that add up to target_num.\n\nExample: main(11, [4,5,6,9,3,7,2,8]) should return [(5,6),(4,7),(9,2),(3,8)].\n\nNote: (6,5) is not included since (5,6) is already found.\n\nWhich of the following code snippets achieve what you want?",
          "options": {
            "a": "def main(target_num, list_num):\n\toutput = []\n\tfor i1 in list_num:\n\t\tfor i2 in list_num:\n\t\t\tif i1 + i2 == target_num:\n\t\t\t\toutput.append((i1, i2))\n\treturn output",
            "b": "def main(target_num,list_num):\n\tresult = []\n\tfor numb in range(target_num//2+1):\n\t\tif numb in list_num and target_num-numb in list_num:\n\t\t\tresult.append((numb,target_num-numb))\n\treturn result",
            "c": "Both work.",
            "d": "Neither works."
          },
          "correct": "b",
          "explanation": "Option a produces both (5,6) and (6,5) — it doesn't ensure uniqueness. Option b iterates up to target//2, so each pair is only considered once. For target=11, range(0,6): checks 0,1,2,3,4,5. Finds: 2+9,3+8,4+7,5+6 — unique pairs. Option b works as intended. Option a doesn't meet the uniqueness requirement. Correct: b."
        },
        {
          "number": 11,
          "topic": "type conversion / indexing",
          "week": 1,
          "question": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\n\nWhat is the output of the following code snippet?\n\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
          "options": {
            "a": "SyntaxError",
            "b": "IndexError: list index out of range",
            "c": "False",
            "d": "True"
          },
          "correct": "d",
          "explanation": "x[2] = (1,2). x[2][0]=1, x[2][1]=2. 1+2=3. float(3)=3.0. type(3.0)=float. x[-2]=3.0 (index 5). type(3.0)=float. float==float → True."
        },
        {
          "number": 12,
          "topic": "enumerate / dictionaries / conditions",
          "week": 2,
          "question": "def counter(y):\n\tx = {}\n\tfor index, element in enumerate(y):\n\t\tif index != int(element) and int(element) % 2 == 0:\n\t\t\tx[element] = len(element)\n\treturn x\n\nWhat will this function return when called as:\ncounter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])",
          "options": {
            "a": "{'12345678': 8, '1234': 4, '12': 2, '123456': 6}",
            "b": "{'12345678': 8, '123': 3, '1234': 4, '12345': 5, '12': 2, '6': 1, '1': 1, '123456': 6}",
            "c": "{'123': 3, '12345': 5, '1': 1}",
            "d": "{'12345678': 8, '1': 1, '1234': 4, '12': 2, '6': 1, '123456': 6}"
          },
          "correct": "a",
          "explanation": "index 0: '12345678', int=12345678, index(0)!=12345678 ✓, even ✓ → add, len=8. index 1: '1', int=1, index==int → skip. index 2: '123', int=123, odd → skip. index 3: '1234', int=1234, index(3)!=1234 ✓, even ✓ → add, len=4. index 4: '12345', int=12345, odd → skip. index 5: '12', int=12, index(5)!=12 ✓, even ✓ → add, len=2. index 6: '6', int=6, index(6)==6 → skip. index 7: '1', int=1, odd → skip. index 8: '123456', int=123456, index(8)!=123456 ✓, even ✓ → add, len=6. Result: {'12345678':8,'1234':4,'12':2,'123456':6}. Correct: a."
        }
      ]
    }
  ],
  "key_exam_patterns_and_traps": [
    {
      "pattern": "Slicing creates a NEW object",
      "trap": "l2=l1 vs l2=l1[:] — l2=l1 shares the SAME object, slicing creates independent copy",
      "weeks": [
        1
      ],
      "appears_in_exams": [
        "trial_midterm",
        "midterm_2023",
        "midterm_2024",
        "extra_practice"
      ]
    },
    {
      "pattern": "Mutable default argument",
      "trap": "def f(lst=[]): — the [] is created ONCE at def time and persists across calls. Fix: use None and create inside function",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "trial_midterm",
        "midterm_2024"
      ]
    },
    {
      "pattern": "Mutable parameter sharing",
      "trap": "When mutable object passed as argument, parameter and argument point to SAME object — mutations inside function affect original",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "midterm_2023",
        "extra_practice"
      ]
    },
    {
      "pattern": "dict 'in' checks KEYS not values",
      "trap": "4 in {1:4, 2:3} → False (4 is a value, not a key)",
      "weeks": [
        2
      ],
      "appears_in_exams": [
        "trial_midterm",
        "midterm_2024"
      ]
    },
    {
      "pattern": "Unordered collections equality",
      "trap": "{1:1,2:2}=={2:2,1:1} is True; {1,2}=={2,1} is True; [1,2]==[2,1] is False",
      "weeks": [
        2
      ],
      "appears_in_exams": [
        "midterm_2023"
      ]
    },
    {
      "pattern": "Boolean operator precedence: not > and > or",
      "trap": "a==1 or a==2 and b==1 or b==2 is evaluated as a==1 or (a==2 and b==1) or b==2",
      "weeks": [
        1,
        2
      ],
      "appears_in_exams": [
        "midterm_2023",
        "extra_practice"
      ]
    },
    {
      "pattern": "Implicit return None",
      "trap": "Function without return statement, or where return is not reached, returns None. print(func()) will print None.",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "trial_midterm",
        "extra_practice"
      ]
    },
    {
      "pattern": "UnboundLocalError",
      "trap": "If a name appears on the left side of assignment ANYWHERE in a function, Python treats it as local THROUGHOUT the function body — even before the assignment line",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "trial_midterm",
        "extra_practice"
      ]
    },
    {
      "pattern": "str.upper() / string methods don't modify in place",
      "trap": "s.upper() returns a new string; s is unchanged. Must do s = s.upper()",
      "weeks": [
        1
      ],
      "appears_in_exams": [
        "trial_midterm",
        "midterm_2023"
      ]
    },
    {
      "pattern": "Empty set: {} creates dict, not set",
      "trap": "s = {} → empty dict. s = set() → empty set",
      "weeks": [
        2
      ],
      "appears_in_exams": []
    },
    {
      "pattern": "Single-element tuple needs trailing comma",
      "trap": "(1) is int, not tuple. (1,) or 1, is a tuple",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "midterm_2024"
      ]
    },
    {
      "pattern": "Tuple inside mutable container can be mutated via the mutable part",
      "trap": "t=(1,[2,3],4); t[1].append(5) works — tuple immutable means you can't reassign t[1], but the list t[1] refers to IS mutable",
      "weeks": [
        1
      ],
      "appears_in_exams": [
        "midterm_2024"
      ]
    },
    {
      "pattern": "Wrong bracket type errors",
      "trap": "print[1] → TypeError 'not subscriptable'; l1(1) → TypeError 'not callable'",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "trial_midterm"
      ]
    },
    {
      "pattern": "range() and slicing both exclusive at stop",
      "trap": "range(1,10,3)→[1,4,7] not including 10; l[2:7] goes up to but not including index 7",
      "weeks": [
        1,
        2
      ],
      "appears_in_exams": [
        "trial_midterm",
        "extra_practice"
      ]
    },
    {
      "pattern": "map/filter return iterables, not lists",
      "trap": "list(map(lambda x: x*2, l)) — must wrap in list(). Without it: <map object at 0x...>",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "trial_midterm",
        "extra_practice"
      ]
    },
    {
      "pattern": "sorted() vs list.sort()",
      "trap": "sorted(l) returns a NEW sorted list. l.sort() sorts IN PLACE and returns None.",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "midterm_2023",
        "midterm_2024"
      ]
    },
    {
      "pattern": "dict to tuple gives keys only",
      "trap": "tuple({1:'a',2:'b'}) → (1,2) — only keys, not values or items",
      "weeks": [
        2
      ],
      "appears_in_exams": [
        "trial_midterm"
      ]
    },
    {
      "pattern": "Negative slicing with step=-2",
      "trap": "l[::-2] starts from last element going backwards with step 2. l[::2][::-1] first takes every other starting from 0, then reverses — different result",
      "weeks": [
        1
      ],
      "appears_in_exams": [
        "extra_practice"
      ]
    },
    {
      "pattern": "1 + True = 2 (bool is subclass of int)",
      "trap": "True==1, False==0 in numeric contexts. type(True)==int is False but isinstance(True,int) is True",
      "weeks": [
        2
      ],
      "appears_in_exams": [
        "midterm_2023"
      ]
    },
    {
      "pattern": "for key in dict == for key in dict.keys()",
      "trap": "Looping directly over a dict iterates over keys only",
      "weeks": [
        2
      ],
      "appears_in_exams": [
        "midterm_2023"
      ]
    },
    {
      "pattern": "RuntimeError: dictionary changed size during iteration",
      "trap": "Adding or deleting dict entries while iterating over it causes RuntimeError",
      "weeks": [
        3
      ],
      "appears_in_exams": [
        "midterm_2024"
      ]
    }
  ],
  "topic_analysis": {
    "topic_frequency_across_all_exams": [
      [
        "slicing",
        3
      ],
      [
        "scope / global",
        2
      ],
      [
        "filter / lambda",
        2
      ],
      [
        "mutable_default",
        2
      ],
      [
        "type_conversion",
        2
      ],
      [
        "mutable_immutable / names",
        1
      ],
      [
        "type / isinstance",
        1
      ],
      [
        "slicing / strings",
        1
      ],
      [
        "for_loop / range",
        1
      ],
      [
        "dictionary",
        1
      ],
      [
        "conditions / boolean",
        1
      ],
      [
        "for_loop / list",
        1
      ],
      [
        "return / None",
        1
      ],
      [
        "while_loop",
        1
      ],
      [
        "list_operations",
        1
      ],
      [
        "lambda / map",
        1
      ],
      [
        "dict / in operator",
        1
      ],
      [
        "string_methods",
        1
      ],
      [
        "args_star",
        1
      ],
      [
        "sorted / lambda",
        1
      ],
      [
        "truthy_falsy",
        1
      ],
      [
        "scope / UnboundLocalError",
        1
      ],
      [
        "zip / enumerate",
        1
      ],
      [
        "nested_loops",
        1
      ],
      [
        "objects / identity",
        1
      ],
      [
        "conditions / precedence",
        1
      ],
      [
        "for_loop / break",
        1
      ],
      [
        "dictionary / methods",
        1
      ],
      [
        "scope",
        1
      ],
      [
        "lambda / sorted",
        1
      ],
      [
        "while_loop / continue",
        1
      ],
      [
        "mutable_args",
        1
      ],
      [
        "nested_loops / dict",
        1
      ],
      [
        "objects / type / is vs ==",
        1
      ],
      [
        "mutable / immutable",
        1
      ],
      [
        "for_loop / enumerate",
        1
      ],
      [
        "conditions / truthy_falsy",
        1
      ],
      [
        "dictionary / zip",
        1
      ],
      [
        "*args / **kwargs",
        1
      ],
      [
        "lambda / reduce",
        1
      ],
      [
        "function_factory / closures",
        1
      ],
      [
        "set / list operations",
        1
      ],
      [
        "comprehension / filter equivalent",
        1
      ],
      [
        "while_loop / walrus",
        1
      ],
      [
        "type_conversion / dict",
        1
      ],
      [
        "set / list / uniqueness",
        1
      ],
      [
        "scope / local_global",
        1
      ],
      [
        "nested_dict / max_min",
        1
      ],
      [
        "dict / average",
        1
      ],
      [
        "dict_building / grade_counts",
        1
      ],
      [
        "slicing / negative_step",
        1
      ],
      [
        "global / return None",
        1
      ],
      [
        "dict / nested indexing",
        1
      ],
      [
        "*args / function design",
        1
      ],
      [
        "nested_loops / pairs",
        1
      ],
      [
        "indexing / type_conversion",
        1
      ],
      [
        "enumerate / dict / string_ops",
        1
      ]
    ],
    "most_tested_topics": [
      "slicing",
      "scope / global",
      "filter / lambda",
      "mutable_default",
      "type_conversion"
    ],
    "topics_in_lectures_not_yet_in_exams": [
      "line_joining (explicit/implicit)",
      "string escape characters",
      "walrus operator in depth",
      "function factories/closures (appears in 2024 but not earlier)",
      "reduce() with initial value",
      "max() with key parameter",
      "pass keyword"
    ],
    "exam_question_counts": {
      "trial_midterm": 24,
      "midterm_2023": 16,
      "midterm_2024": 24,
      "extra_practice": 12,
      "total": 76
    }
  }
}