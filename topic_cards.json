{
  "meta": {
    "generated_from": "study_data.json",
    "generator": "build_topic_cards.py",
    "course": "Introduction to Python",
    "weeks_covered": [
      1,
      2,
      3
    ],
    "total_cards": 37,
    "notes": [
      "Sections (1) lecture snippets, (2) exam Q&A, and (4) notebook snippets are sourced from study_data.json.",
      "Low-value one-line notebook/heading snippets are filtered out automatically.",
      "AI sections are generated separately (summary, common questions, examples).",
      "AI summary/common-questions/examples generated with gemini-cli and validated.",
      "Generated key_points_to_remember and recommended_ids via gemini-cli.",
      "Post-processed key_points_to_remember to remove question-style/low-value lines.",
      "Replaced generic fallback key points with topic-specific references for scope/exam/execution cards.",
      "Added optional key point detail blocks (tables/examples/explanations) for reference usage.",
      "Added optional key point detail blocks (tables/examples/explanations) for reference usage.",
      "Expanded optional key-point details via parallel Gemini generation with Gemini audit checks for alignment/completeness/quality (2026-02-25)."
    ]
  },
  "cards": [
    {
      "id": "topic-loop",
      "topic": "For Loops",
      "canonical_topic": "for loop",
      "weeks": [
        1,
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 14,
        "coverage_count": 4,
        "by_exam": {
          "extra_practice": 2,
          "midterm_2023": 3,
          "midterm_2024": 4,
          "trial_midterm": 5
        }
      },
      "related_topics": [
        "Dictionaries",
        "For-loops",
        "Looping over dictionaries",
        "While-loops",
        "dictionaries / nested dicts",
        "for loops / enumerate",
        "for loops / range",
        "for vs while / loop control",
        "for_loop / break",
        "for_loops",
        "for_vs_while",
        "looping_dicts",
        "nested loops",
        "nested loops / complexity",
        "nested loops / pairs",
        "nested_loops",
        "nested_loops / dict",
        "nested_loops / pairs",
        "walrus_operator",
        "while loops",
        "while loops / walrus operator",
        "while_loop",
        "while_loop / continue",
        "while_loop / walrus",
        "while_loops",
        "zip / looping",
        "for_loop / range",
        "range()"
      ],
      "trap_patterns": [
        {
          "pattern": "range() and slicing both exclusive at stop",
          "trap": "range(1,10,3)\u2192[1,4,7] not including 10; l[2:7] goes up to but not including index 7",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' \u2014 this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used \u2014 use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          },
          {
            "id": "lec-5ae780c366",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Looping over dictionaries",
            "explanation": ".keys() \u2192 key sequence. .values() \u2192 value sequence. .items() \u2192 sequence of (key, value) tuples. 'for key in dict' is the same as 'for key in dict.keys()'.",
            "code_examples": [
              {
                "description": "Looping over dict",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\n# These two are equivalent:\nfor key in capitals:\nfor key in capitals.keys():"
              }
            ]
          },
          {
            "id": "lec-35530d9a47",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "While-loops",
            "explanation": "while condition: expression. Checks condition BEFORE each execution. Use break and continue. Watch for infinite loops (Ctrl+C to exit). Use when you don't know beforehand how many iterations are needed. For-loops can always be replaced by while-loops.",
            "code_examples": [
              {
                "description": "While with break/continue",
                "code": "total = 0\nwhile True:\n    number = int(input('give a number, or 100 to stop '))\n    if number == 100:\n        break\n    if number % 2 == 0:\n        continue\n    total += number\nprint(total)"
              },
              {
                "description": "Truthy/Falsy in while condition",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:           # truthy while list is non-empty\n    total += l1[0]\n    del l1[0]\nprint(total)        # 21"
              }
            ]
          },
          {
            "id": "lec-e8f2474ca1",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "range()",
            "explanation": "range(start, stop, step). start default=0, step default=1. Stop is NOT inclusive. Works like slicing but defaults differ slightly.",
            "code_examples": [
              {
                "description": "range examples",
                "code": "print(list(range(6)))      # [0, 1, 2, 3, 4, 5]\nprint(list(range(3,6)))    # [3, 4, 5]\nprint(list(range(3,6,2)))  # [3, 5]"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-7f6a7c840f",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 10,
            "week": 3,
            "topic": "nested loops / pairs",
            "question": "You need to write a function main(target_num, list_num) that returns all unique pairs of numbers that add up to target_num.\n\nExample: main(11, [4,5,6,9,3,7,2,8]) should return [(5,6),(4,7),(9,2),(3,8)].\n\nNote: (6,5) is not included since (5,6) is already found.\n\nWhich of the following code snippets achieve what you want?",
            "code_context": "",
            "options": {
              "a": "def main(target_num, list_num):\n\toutput = []\n\tfor i1 in list_num:\n\t\tfor i2 in list_num:\n\t\t\tif i1 + i2 == target_num:\n\t\t\t\toutput.append((i1, i2))\n\treturn output",
              "b": "def main(target_num,list_num):\n\tresult = []\n\tfor numb in range(target_num//2+1):\n\t\tif numb in list_num and target_num-numb in list_num:\n\t\t\tresult.append((numb,target_num-numb))\n\treturn result",
              "c": "Both work.",
              "d": "Neither works."
            },
            "correct": "b",
            "explanation": "Option a produces both (5,6) and (6,5) \u2014 it doesn't ensure uniqueness. Option b iterates up to target//2, so each pair is only considered once. For target=11, range(0,6): checks 0,1,2,3,4,5. Finds: 2+9,3+8,4+7,5+6 \u2014 unique pairs. Option b works as intended. Option a doesn't meet the uniqueness requirement. Correct: b."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-b7bad1b1ce",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 8,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
            "code_context": "",
            "options": {
              "A": "0 apple\n1 banana\n2 cherry",
              "B": "1 apple\n2 banana\n3 cherry",
              "C": "apple 0\nbanana 1\ncherry 2",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "enumerate starts at 0 by default and yields (index, value) pairs."
          },
          {
            "id": "exm-ba031912fa",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 16,
            "week": 2,
            "topic": "zip / looping",
            "question": "What is the output of the following code?\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
            "code_context": "",
            "options": {
              "A": "Alice: 85\nBob: 92\nCharlie: 78",
              "B": "Alice: 92\nBob: 85\nCharlie: 78",
              "C": "Alice Bob Charlie: 85 92 78",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "zip pairs elements positionally. Output: Alice: 85, Bob: 92, Charlie: 78."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-09e753703b",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 10,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nlst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
            "code_context": "",
            "options": {
              "A": "0 a\n1 b\n2 c",
              "B": "1 a\n2 b\n3 c",
              "C": "a 1\nb 2\nc 3",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "enumerate(lst, start=1) begins counting at 1. Output: 1 a, 2 b, 3 c."
          },
          {
            "id": "exm-19033dcb2f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 11,
            "week": 2,
            "topic": "while loops",
            "question": "What is the output of the following code?\n\nn = 1\nwhile n < 32:\n    n *= 2\nprint(n)",
            "code_context": "",
            "options": {
              "A": "16",
              "B": "32",
              "C": "64",
              "D": "31"
            },
            "correct": "B",
            "explanation": "n: 1->2->4->8->16->32. 32 < 32 is False, loop stops. print(n) = 32."
          },
          {
            "id": "exm-f49499c6d8",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 24,
            "week": 3,
            "topic": "nested loops / complexity",
            "question": "What is the output of the following code?\n\ncount = 0\nfor i in range(4):\n    for j in range(i):\n        count += 1\nprint(count)",
            "code_context": "",
            "options": {
              "A": "4",
              "B": "6",
              "C": "10",
              "D": "16"
            },
            "correct": "B",
            "explanation": "i=0: j in range(0) \u2192 0 iterations. i=1: 1. i=2: 2. i=3: 3. Total: 0+1+2+3 = 6."
          },
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          },
          {
            "id": "exm-7b51257c98",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 9,
            "week": 2,
            "topic": "for loops / range",
            "question": "What is the output of the following code?\n\nresult = 0\nfor i in range(1, 6):\n    result += i\nprint(result)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "15",
              "C": "21",
              "D": "6"
            },
            "correct": "B",
            "explanation": "range(1,6) gives 1,2,3,4,5. Sum = 15."
          },
          {
            "id": "exm-e6b8037e2c",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 10,
            "week": 2,
            "topic": "while loops / walrus operator",
            "question": "What is the output of the following code?\n\nnumbers = [1, 3, 5, 2, 7]\nresult = []\nfor num in numbers:\n    if num % 2 == 0:\n        result.append(num)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 3, 5, 7]",
              "B": "[2]",
              "C": "[]",
              "D": "[1, 3, 5, 2, 7]"
            },
            "correct": "B",
            "explanation": "Only 2 is even in the list. result = [2]."
          },
          {
            "id": "exm-405a1c9038",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 21,
            "week": 3,
            "topic": "nested loops",
            "question": "What is the output of the following code?\n\nresult = []\nfor i in range(3):\n    for j in range(3):\n        if i == j:\n            result.append((i, j))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[(0,0), (1,1), (2,2)]",
              "B": "[(0,1), (0,2), (1,2)]",
              "C": "[(0,0), (0,1), (0,2)]",
              "D": "[]"
            },
            "correct": "A",
            "explanation": "Only pairs where i == j: (0,0), (1,1), (2,2)."
          },
          {
            "id": "exm-6265aa347e",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 24,
            "week": 3,
            "topic": "for vs while / loop control",
            "question": "What is the output of the following code?\n\nresult = []\ni = 0\nwhile i < 5:\n    if i % 2 == 0:\n        result.append(i)\n    i += 1\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 3]",
              "B": "[0, 2, 4]",
              "C": "[0, 1, 2, 3, 4]",
              "D": "[2, 4]"
            },
            "correct": "B",
            "explanation": "Loop i=0..4, appending even values: 0, 2, 4. Result = [0, 2, 4]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          },
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-1eed6533a3",
            "week": 2,
            "cell_index": 84,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(f\"The country is {key}\")",
            "outputs": []
          },
          {
            "id": "nb-d50eeb7b9a",
            "week": 2,
            "cell_index": 85,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor value in capitals.values():\n    print(f\"The capital is {value}\")",
            "outputs": []
          },
          {
            "id": "nb-f09c460011",
            "week": 2,
            "cell_index": 86,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country, city in capitals.items():\n    print(f\"{country=} and {city=} \")",
            "outputs": []
          },
          {
            "id": "nb-faf3afc44b",
            "week": 2,
            "cell_index": 87,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country in capitals:\n    print(f\"The country is {country}\")",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "For-loops iterate over iterables such as lists, strings, dictionaries, and `range()` sequences. In exam questions, trace loop variables and accumulator updates step by step, and remember that `range(start, stop, step)` includes `start` but excludes `stop`. Negative steps reverse direction and require start/stop values that match that direction."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the final value of a variable after the loop finishes?",
            "What is the difference between `break` and `continue`?",
            "What items are collected in a list inside a loop?",
            "What is the output of a nested loop structure?",
            "Does `range(a, b)` include the value `b`? (No)",
            "How many times will a given loop run?",
            "What is the value of the outer loop variable during the third iteration of the inner loop?",
            "What's the total number of iterations for `for i in range(4): for j in range(i):`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic For-Loop Summation",
            "code": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "why": "This loop iterates through the list, summing all numeric elements. The result is 21.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "For-Loop with `continue` to Skip Elements",
            "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)",
            "why": "The loop adds numbers to total. When a string ('3') is encountered, `continue` skips the addition for that iteration, resulting in 1+2+3+5+7 = 18.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "For-Loop with Unused Loop Variable `_`",
            "code": "for _ in range(5):\n    print('Hello')",
            "why": "This loop prints 'Hello' five times. The underscore `_` indicates that the iteration variable's value is not needed within the loop body.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Using `zip` to Iterate Multiple Sequences",
            "code": "names = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
            "why": "`zip` pairs corresponding elements from `names` and `scores`, allowing simultaneous iteration. Output: Alice: 85, Bob: 92, Charlie: 78.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "`range()` Function Behavior",
            "code": "print(list(range(6)))\nprint(list(range(3,6)))\nprint(list(range(3,6,2)))",
            "why": "`range(6)` generates [0,1,2,3,4,5]. `range(3,6)` generates [3,4,5]. `range(3,6,2)` generates [3,5]. The `stop` parameter is always exclusive.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Basic `while` Loop Execution",
            "code": "n = 1\nwhile n < 32:\n    n *= 2\nprint(n)",
            "why": "The loop multiplies `n` by 2 in each iteration until `n` is no longer less than 32. `n` becomes 32, which stops the loop, and then 32 is printed.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "`while` Loop with `break` and `continue`",
            "code": "total_while = 0\ni = 0\ntest_numbers = [1, 2, 3, 4, 100]\nwhile True:\n    if i >= len(test_numbers): \n        break\n    number = test_numbers[i]\n    i += 1\n\n    if number == 100:\n        break\n    if number % 2 == 0:\n        continue\n    total_while += number\nprint(total_while)",
            "why": "The loop sums odd numbers. `continue` skips even numbers, and `break` terminates the loop if 100 is encountered or if `test_numbers` is exhausted. For `[1, 2, 3, 4, 100]`, the total is 1 + 3 = 4.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "`while` Loop with Truthiness of a List",
            "code": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1: # loop continues while list is not empty (truthy)\n    total += l1[0]\n    del l1[0]\nprint(total)",
            "why": "The loop continues as long as `l1` is not empty (truthy). It sums the first element and then removes it, eventually leading to `l1` being empty (falsy) and terminating the loop. The total sum is 21.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Nested For-Loops for Iteration Count",
            "code": "count = 0\nfor i in range(4):\n    for j in range(i):\n        count += 1\nprint(count)",
            "why": "The outer loop runs for `i = 0, 1, 2, 3`. The inner loop `range(i)` runs 0, 1, 2, and 3 times respectively. The total count is 0 + 1 + 2 + 3 = 6.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Nested For-Loops with Conditional Appending",
            "code": "result = []\nfor i in range(3):\n    for j in range(3):\n        if i == j:\n            result.append((i, j))\nprint(result)",
            "why": "The nested loops iterate through all pairs of (i, j) where `i` and `j` are from 0 to 2. Only pairs where `i` equals `j` are appended, resulting in `[(0,0), (1,1), (2,2)]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "For-Loop with Conditional List Appending",
            "code": "numbers = [1, 3, 5, 2, 7]\nresult = []\nfor num in numbers:\n    if num % 2 == 0:\n        result.append(num)\nprint(result)",
            "why": "The loop iterates through the `numbers` list, appending only the even numbers to `result`. The only even number is 2, so the output is `[2]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "correct",
            "title": "`while` Loop with Conditional List Appending",
            "code": "result = []\ni = 0\nwhile i < 5:\n    if i % 2 == 0:\n        result.append(i)\n    i += 1\nprint(result)",
            "why": "The loop iterates `i` from 0 to 4. Even values of `i` (0, 2, 4) are appended to the `result` list. The final output is `[0, 2, 4]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Looping Over Dictionary Keys",
            "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\n# Also equivalent:\nfor key in capitals:\n    print(key)",
            "why": "Both methods iterate and print the keys of the dictionary: 'Andorra' and 'Belgium'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-14",
            "kind": "correct",
            "title": "Looping Over Dictionary Values",
            "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor val in capitals.values():\n    print(val)",
            "why": "This loop iterates and prints the values of the dictionary: 'Andorra la Vella' and 'Brussels'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-15",
            "kind": "correct",
            "title": "Looping Over Dictionary Items (Key-Value Pairs)",
            "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key, value in capitals.items():\n    print(key, value)",
            "why": "The `.items()` method allows iterating over key-value pairs simultaneously. Output shows 'Andorra Andorra la Vella' and 'Belgium Brussels'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-16",
            "kind": "correct",
            "title": "Finding Max/Min Scores and Corresponding Players in Nested Dictionaries",
            "code": "results = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nallscores = []\nfor player_results in results.values():\n    allscores.extend(player_results.values())\n\nmax_score = max(allscores)\nmin_score = min(allscores)\n\nplayers_by_score = {max_score: [], min_score: []}\n\nfor player, player_results in results.items():\n    for score in player_results.values():\n        if score == max_score:\n            if player not in players_by_score[max_score]:\n                players_by_score[max_score].append(player)\n        if score == min_score:\n            if player not in players_by_score[min_score]:\n                players_by_score[min_score].append(player)\n\nprint(players_by_score)",
            "why": "This code correctly identifies the global maximum (6) and minimum (1) scores from nested dictionaries and then iterates to find all players who achieved these scores. It avoids adding duplicate player names to the lists.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-17",
            "kind": "incorrect",
            "title": "Finding Pairs Summing to Target (Produces Duplicates)",
            "code": "def main_incorrect(target_num, list_num):\n    output = []\n    for i1 in list_num:\n        for i2 in list_num:\n            if i1 + i2 == target_num:\n                output.append((i1, i2))\n    return output\n\nprint(main_incorrect(11, [4,5,6,9,3,7,2,8]))",
            "why": "This nested loop approach will find both `(a, b)` and `(b, a)` if they sum to `target_num`, leading to duplicate pairs in the output (e.g., both `(5, 6)` and `(6, 5)`).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-18",
            "kind": "correct",
            "title": "Finding Unique Pairs Summing to Target",
            "code": "def main_correct(target_num, list_num):\n    result = []\n    for numb in range(target_num // 2 + 1):\n        if numb in list_num and target_num - numb in list_num:\n            result.append((numb, target_num - numb))\n    return result\n\nprint(main_correct(11, [4,5,6,9,3,7,2,8]))",
            "why": "This solution correctly finds unique pairs that sum to `target_num`. By iterating `numb` only up to `target_num // 2`, it ensures that each unique pair `(a, b)` (where `a <= b`) is considered only once, preventing duplicates like `(5, 6)` and `(6, 5)`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "For-loops iterate over sequences, executing expressions for each item.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Basic Iteration",
                "text": "",
                "code": "numbers = [1, 3, 5, 2, 7]\nresult = []\nfor num in numbers:\n    if num % 2 == 0:\n        result.append(num)\nprint(result)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "The `break` statement exits a loop entirely, terminating its execution.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Exiting a Loop",
                "text": "The `break` statement immediately terminates the loop's execution. Control flows to the statement immediately following the loop.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-2-d2",
                "kind": "example",
                "title": "Break in While Loop",
                "text": "",
                "code": "total = 0\nwhile True:\n    number = int(input('give a number, or 100 to stop '))\n    if number == 100:\n        break\n    total += number\nprint(total)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The `continue` statement skips the current iteration of a loop and proceeds to the next one.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "explanation",
                "title": "Skipping an Iteration",
                "text": "The `continue` statement skips the rest of the current iteration and proceeds to the next iteration of the loop.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Continue Example",
                "text": "",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "The underscore `_` is a conventional variable name for loop variables that are not explicitly used within the loop body.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Unused Loop Variable",
                "text": "Using `_` as a variable name signals that the iterated item is not needed within the loop body, improving readability.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Underscore for Ignored Variable",
                "text": "",
                "code": "for _ in range(5):\n    print('Hello') # prints Hello 5 times",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`enumerate` provides both the index and the value for each item during iteration, with a default starting index of 0.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Enumerate Basic Use",
                "text": "",
                "code": "fruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "The `enumerate` function can be configured to start counting from a specified index using the `start` parameter.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Enumerate with Start Index",
                "text": "",
                "code": "lst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`zip` can be used within a for loop to iterate over multiple sequences simultaneously, pairing elements positionally.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Iterating with Zip",
                "text": "",
                "code": "names = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`range(start, stop, step)` generates a sequence of numbers, where the `stop` value is exclusive (not included in the sequence).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "explanation",
                "title": "Range Stop Exclusivity",
                "text": "The `stop` value in `range(start, stop, step)` is not included in the generated sequence, similar to slicing behavior.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-8-d2",
                "kind": "example",
                "title": "Range with Step",
                "text": "",
                "code": "print(list(range(3,6,2))) # Output: [3, 5]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`range(stop)` defaults to a starting value of 0 and a step of 1.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "Range Defaults",
                "text": "",
                "code": "print(list(range(6))) # Output: [0, 1, 2, 3, 4, 5]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "`while` loops execute as long as their condition evaluates to `True`, checking the condition before each iteration.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "explanation",
                "title": "While Loop Condition",
                "text": "A `while` loop continues to execute as long as its condition evaluates to `True`. The condition is checked before each iteration.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-10-d2",
                "kind": "example",
                "title": "Basic While Loop",
                "text": "",
                "code": "n = 1\nwhile n < 32:\n    n *= 2\nprint(n) # Output: 32",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "`while` loops are particularly useful when the exact number of required iterations is not known in advance.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "explanation",
                "title": "When to Use While Loops",
                "text": "While loops are best suited for situations where the number of iterations required is not known in advance, for example, waiting for a user input or a specific state.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "Direct iteration over a dictionary (e.g., `for key in dict_name`) iterates over its keys.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "explanation",
                "title": "Direct Dictionary Iteration",
                "text": "Iterating directly over a dictionary (e.g., `for key in my_dict:`) will yield its keys.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-12-d2",
                "kind": "example",
                "title": "Iterate Over Keys Directly",
                "text": "",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country in capitals:\n    print(f\"The country is {country}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "The `.keys()` method returns a view of a dictionary's keys.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "explanation",
                "title": ".keys() Method",
                "text": "The `.keys()` method returns a view object that displays a list of all the keys in the dictionary.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-13-d2",
                "kind": "example",
                "title": "Using .keys()",
                "text": "",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(f\"The country is {key}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "The `.values()` method returns a view of a dictionary's values.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "explanation",
                "title": ".values() Method",
                "text": "The `.values()` method returns a view object that displays a list of all the values in the dictionary.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-14-d2",
                "kind": "example",
                "title": "Using .values()",
                "text": "",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor value in capitals.values():\n    print(f\"The capital is {value}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "The `.items()` method returns a view of a dictionary's key-value pairs as tuples.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "explanation",
                "title": ".items() Method",
                "text": "The `.items()` method returns a view object that displays a list of a dictionary\u2019s key-value tuple pairs.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-15-d2",
                "kind": "example",
                "title": "Using .items()",
                "text": "",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country, city in capitals.items():\n    print(f\"{country=} and {city=} \")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-16",
            "text": "The `in` operator applied to a dictionary checks for the presence of a key, not a value.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-16-d1",
                "kind": "explanation",
                "title": "'in' Operator for Dictionary Keys",
                "text": "When the `in` operator is used with a dictionary, it checks for the presence of a key, not a value.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-16-d2",
                "kind": "example",
                "title": "Checking Key Presence",
                "text": "",
                "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d) # Output: False\nprint('a' in d) # Output: True",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-405a1c9038",
          "exm-f49499c6d8",
          "exm-19033dcb2f",
          "exm-6265aa347e",
          "exm-b7bad1b1ce",
          "exm-ba031912fa",
          "exm-e6b8037e2c",
          "exm-7f6a7c840f",
          "exm-f44278f521",
          "exm-3555baf8ba"
        ]
      }
    },
    {
      "id": "topic-function",
      "topic": "Functions",
      "canonical_topic": "fun example",
      "weeks": [
        1,
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 9,
        "by_exam": {
          "trial_midterm": 4,
          "midterm_2024": 3,
          "extra_practice": 1,
          "midterm_2023": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "*args / passing to function",
        "Function definition and calling",
        "Functions \u2014 basics",
        "Lambda functions",
        "Methods vs functions",
        "Nested functions and function factories",
        "filter function",
        "filter_function",
        "fun_example",
        "function factories / closures",
        "function_calls",
        "function_definition",
        "function_factories",
        "function_factory / closures",
        "len_function",
        "map function",
        "map_function",
        "nested functions / scope",
        "reduce function",
        "reduce_function"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-805233cb66",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Functions \u2014 basics",
            "explanation": "Functions are objects. Defined with def. Called with (). Built-in functions: print, id, len, type, del. Functions can return values. Methods are functions attached to objects.",
            "code_examples": [
              {
                "description": "Simple function",
                "code": "def size(length, width):\n    return length * width\nprint(size(2,3))  # 6"
              }
            ]
          },
          {
            "id": "lec-b5af6f4178",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Function definition and calling",
            "explanation": "def keyword, function name, parameters in parentheses, colon, indented body. Call with round brackets (). Using [] gives TypeError 'not subscriptable'. Using [] on a list with () gives TypeError 'not callable'.",
            "code_examples": [
              {
                "description": "Basic function",
                "code": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)  # 3"
              },
              {
                "description": "Wrong bracket errors",
                "code": "print[1]   # TypeError: 'function' object is not subscriptable\nl1 = [1,2,3]\nl1(1)      # TypeError: 'list' object is not callable"
              }
            ]
          },
          {
            "id": "lec-0a5f25a4f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Lambda functions",
            "explanation": "Anonymous one-line functions. Syntax: lambda params: expression. Equivalent to a regular def but more concise. Most useful with map, filter, reduce, sorted, max.",
            "code_examples": [
              {
                "description": "Lambda basics",
                "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))  # 3\n# Equivalent to:\ndef add_two(x, y):\n    return x + y"
              },
              {
                "description": "map() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))   # [2, 4, 6, 8, 10, 12]\n# Need list() to convert map object to list"
              },
              {
                "description": "filter() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))  # [2, 4, 6] (even numbers)"
              },
              {
                "description": "reduce() with lambda",
                "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))  # 720 (product)\n# reduce with initial value:\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))  # 5"
              },
              {
                "description": "sorted() with key lambda",
                "code": "l1 = ['aaa', 'c', 'baab']\nprint(sorted(l1))                              # ['aaa', 'baab', 'c']\nprint(sorted(l1, key=lambda x: x.count('a'))) # ['c', 'baab', 'aaa']\nprint(sorted(l1, key=len))                    # ['c', 'aaa', 'baab']\n\nd = {'a': 2, 'b': 1}\nprint(max(d.items()))                         # ('b', 1)  \u2190 compares tuples\nprint(max(d.items(), key=lambda x: x[1]))     # ('a', 2)  \u2190 by value"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings \u2014 you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable \u2014 must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT \u2014 captures new string\ns1.upper()       # WRONG \u2014 result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable \u2014 changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          },
          {
            "id": "lec-870bff9b01",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Nested functions and function factories",
            "explanation": "Functions can be defined inside other functions. The inner function is only visible to the outer function. Functions are objects \u2014 a function can return another function (factory pattern).",
            "code_examples": [
              {
                "description": "Function factory",
                "code": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\nadd4 = function_factory(4)\nadd5 = function_factory(5)\nprint(add4(3))  # 7\nprint(add5(3))  # 8"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-4b69d2de00",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 16,
            "week": 3,
            "topic": "map function",
            "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)",
            "code_context": "",
            "options": {
              "A": "[1, 4, 9, 16, 25]",
              "B": "[2, 4, 6, 8, 10]",
              "C": "[1, 2, 3, 4, 5]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "map applies the lambda (x**2) to each element: [1, 4, 9, 16, 25]."
          },
          {
            "id": "exm-42b9531488",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 17,
            "week": 3,
            "topic": "filter function",
            "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5, 6]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)",
            "code_context": "",
            "options": {
              "A": "[1, 3, 5]",
              "B": "[2, 4, 6]",
              "C": "[1, 2, 3, 4, 5, 6]",
              "D": "[]"
            },
            "correct": "B",
            "explanation": "filter keeps elements for which the lambda returns True. Even numbers: [2, 4, 6]."
          },
          {
            "id": "exm-160b2f4876",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 19,
            "week": 3,
            "topic": "function factories / closures",
            "question": "What is the output of the following code?\n\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = make_multiplier(3)\nprint(times3(5))",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "8",
              "C": "3",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "make_multiplier(3) returns a closure that multiplies by 3. times3(5) = 5 * 3 = 15."
          },
          {
            "id": "exm-22f83f65e5",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 23,
            "week": 3,
            "topic": "reduce function",
            "question": "What is the output of the following code?\n\nfrom functools import reduce\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, numbers)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "120",
              "C": "24",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "reduce multiplies left to right: 1*2=2, 2*3=6, 6*4=24, 24*5=120."
          },
          {
            "id": "exm-141dceafbb",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 19,
            "week": 3,
            "topic": "map function",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nresult = list(map(str, lst))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "['1', '2', '3']",
              "C": "['str', 'str', 'str']",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "map(str, lst) converts each integer to string. Result: ['1', '2', '3']."
          },
          {
            "id": "exm-4ed0093860",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 20,
            "week": 3,
            "topic": "filter function",
            "question": "What is the output of the following code?\n\nlst = [0, 1, 2, 0, 3, 0]\nresult = list(filter(None, lst))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[0, 0, 0]",
              "B": "[1, 2, 3]",
              "C": "[0, 1, 2, 0, 3, 0]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "filter(None, lst) keeps truthy values. 0 is falsy, so it filters out all 0s: [1, 2, 3]."
          },
          {
            "id": "exm-7c32aece02",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 22,
            "week": 3,
            "topic": "function factories / closures",
            "question": "What is the output of the following code?\n\ndef counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())\nprint(c())",
            "code_context": "",
            "options": {
              "A": "1\n1\n1",
              "B": "1\n2\n3",
              "C": "0\n1\n2",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "nonlocal allows increment() to modify count in the enclosing scope. Each call increments count: 1, 2, 3."
          },
          {
            "id": "exm-08341d3aa4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 15,
            "week": 3,
            "topic": "nested functions / scope",
            "question": "What is the output of the following code?\n\ndef outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "None",
              "C": "Error",
              "D": "0"
            },
            "correct": "A",
            "explanation": "inner() can access x from the enclosing scope (closure). Prints 10."
          },
          {
            "id": "exm-16556959b9",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 9,
            "week": 3,
            "topic": "*args / passing to function",
            "question": "Assume sum_even_in_list(l1) filters non-integers and sums even integers.\n\nYou want sum_even_integers that accepts a flexible number of arguments.\n\nFor example: sum_even_integers(1,'2', 3.0, 4) should return 4.\n\nWhich of the following function definitions will work as intended?",
            "code_context": "",
            "options": {
              "a": "def sum_even_integers(*args):\n\treturn sum_even_in_list(args)",
              "b": "def sum_even_integers(*args):\n\treturn sum([x for x in args if type(x) == int and x%2 == 0])",
              "c": "def sum_even_integers(*args):\n\tresult = 0\n\tfor x in args:\n\t\tif type(x) == int and x%2 == 0:\n\t\t\tresult += x\n\treturn result",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: *args creates a tuple, sum_even_in_list accepts any iterable so passing a tuple works. b: list comprehension on tuple works fine. c: direct iteration over tuple works. All three produce the same result. Correct: d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-607f841482",
            "week": 1,
            "cell_index": 58,
            "cell_type": "code",
            "topic": "len_function",
            "source": "print(len(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']))\nprint(len(('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')))\nprint(len({'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'}))\nprint(len({1:'A', 2:'B', 3:'C', 4:'D', 5:'E', 6:'F', 7:'G', 8:'H'}))\nprint(len(('ABCDEFGH')))\ntry:\n    print(len(12345678))\nexcept:\n    print ('Built-in len function cannot be applied on integers or floats')\ntry:\n    print(len(True))\nexcept:\n    print ('Built-in len function cannot be applied on booleans or floats')\nprint(len(str(12345678)))",
            "outputs": []
          },
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-09ab40d9b7",
            "week": 3,
            "cell_index": 1,
            "cell_type": "code",
            "topic": "function_definition",
            "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total",
            "outputs": []
          },
          {
            "id": "nb-447009e81a",
            "week": 3,
            "cell_index": 3,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "a = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-3fc221ef7b",
            "week": 3,
            "cell_index": 4,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "print(adder(1,2))",
            "outputs": []
          },
          {
            "id": "nb-e6cb1c0efc",
            "week": 3,
            "cell_index": 6,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "adder[1,2]",
            "outputs": []
          },
          {
            "id": "nb-0941b44178",
            "week": 3,
            "cell_index": 7,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "adder{1,2}",
            "outputs": []
          },
          {
            "id": "nb-45274c22b1",
            "week": 3,
            "cell_index": 10,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "l1 = [1, 2, 3]\nl1(1)",
            "outputs": []
          },
          {
            "id": "nb-aa2ac816b1",
            "week": 3,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "l1 = [1, 2, 3]\nl1{1}",
            "outputs": []
          },
          {
            "id": "nb-12853105fe",
            "week": 3,
            "cell_index": 13,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-59219f177c",
            "week": 3,
            "cell_index": 14,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "n1 = 1\nn2 = 2\ntotal = n1 + n2\na = total\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-eb8335fd0f",
            "week": 3,
            "cell_index": 45,
            "cell_type": "raw",
            "topic": "function_factories",
            "source": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\n\nadd4 = function_factory(4)\nadd5 = function_factory (5)\n\nprint(add4(3))\nprint(add5(3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Functions package reusable code under a single name, defined with `def`. Methods are special functions tied to an object's type, like a string or list. In exams, track how methods on mutable objects (like lists) can change them directly ('in-place'), while methods on immutable objects (like strings) always produce a new value that you must save to a variable."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Trace the output of code that swaps variable values without a temporary variable.",
            "What is the final value of a variable after a function or method call?",
            "Why is my string variable unchanged after calling `.upper()` on it?",
            "Does this method modify the list in-place or return a new list?",
            "Is `my_list = sorted(my_list)` correct or incorrect usage?",
            "What does `my_list.sort()` return? (Answer: `None`)",
            "What is the output after calling the factory twice and using both created functions?",
            "Can the inner function access variables from the outer function's scope?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic Function Definition and Call",
            "code": "def adder(n1, n2):\n    total = n1 + n2\n    return total\n\na = adder(1, 2)\nprint(a)",
            "why": "Defines a function `adder` that takes two arguments, sums them, and returns the total. The return value is stored in `a` and printed.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Incorrect Function Call Syntax",
            "code": "def adder(n1, n2):\n    return n1 + n2\n\nadder[1, 2]",
            "why": "Functions are called with parentheses `()`, not square brackets `[]`. This will result in a TypeError because the function object is not subscriptable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "incorrect",
            "title": "Incorrect List Call Syntax",
            "code": "l1 = [1, 2, 3]\nl1(1)",
            "why": "Lists are subscripted with square brackets `[]` to access elements, not called with parentheses `()`. This will result in a TypeError because the list object is not callable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "len() with various types",
            "code": "print(len(['A', 'B', 'C'])) # List\nprint(len(('A', 'B')))   # Tuple\nprint(len({'A', 'B', 'C', 'D'})) # Set\nprint(len({'a': 1, 'b': 2})) # Dictionary\nprint(len('Hello')) # String",
            "why": "The `len()` function correctly returns the number of items in sequences and collections.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "len() on invalid types",
            "code": "try:\n    print(len(12345))\nexcept TypeError as e:\n    print(e)\n\ntry:\n    print(len(True))\nexcept TypeError as e:\n    print(e)",
            "why": "The `len()` function cannot be directly applied to integers or booleans, resulting in a TypeError.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "map() with Lambda",
            "code": "numbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)",
            "why": "`map()` applies the lambda function to each element of `numbers`, squaring them. The result is converted to a list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "filter() with Lambda",
            "code": "numbers = [1, 2, 3, 4, 5, 6]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)",
            "why": "`filter()` selects elements from `numbers` for which the lambda (checking for evenness) returns `True`. The result is converted to a list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "filter() with None (truthiness)",
            "code": "lst = [0, 1, 2, 0, 3, 0]\nresult = list(filter(None, lst))\nprint(result)",
            "why": "When `None` is passed as the function to `filter()`, it filters out all falsy values (like 0, `None`, empty strings, empty lists).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "reduce() with Lambda",
            "code": "from functools import reduce\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, numbers)\nprint(result)",
            "why": "`reduce()` cumulatively applies the lambda (multiplication) to the elements of `numbers`, resulting in their product.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Function Factory (Closure)",
            "code": "def make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = make_multiplier(3)\nprint(times3(5))",
            "why": "`make_multiplier` returns a nested function `multiplier`. `times3` becomes a closure that remembers `n=3` from its creation, allowing it to multiply by 3.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "Accessing Enclosing Scope (Closure)",
            "code": "def outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
            "why": "The inner function `inner()` forms a closure, accessing the variable `x` from its enclosing scope (`outer()`).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "correct",
            "title": "Using `nonlocal` in Nested Functions",
            "code": "def counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())\nprint(c())",
            "why": "The `nonlocal` keyword allows the `increment()` function to modify the `count` variable defined in its enclosing `counter()` function, rather than creating a new local variable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Method on Immutable Object (Must Capture Return)",
            "code": "s1 = 'UVA Amsterdam'\ns1_upper = s1.upper() # CORRECT: captures new string\nprint(s1_upper)\nprint(s1) # original s1 is unchanged",
            "why": "String methods like `upper()` return a new string. The result must be assigned back to a variable (or a new one) to retain the change, as the original string is immutable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-14",
            "kind": "incorrect",
            "title": "Method on Immutable Object (Lost Return)",
            "code": "s1 = 'UVA Amsterdam'\ns1.upper() # WRONG: result is lost\nprint(s1)",
            "why": "Calling `s1.upper()` creates an uppercase copy, but if the return value is not captured, the original `s1` (being immutable) remains unchanged, and the uppercase string is discarded.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-15",
            "kind": "correct",
            "title": "Method on Mutable Object (In-Place Change)",
            "code": "l1 = [3, 1, 2]\nl1.sort() # changes l1 in place, returns None\nprint(l1)",
            "why": "The `list.sort()` method modifies the list `l1` directly (in place) and returns `None`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-16",
            "kind": "correct",
            "title": "Method on Mutable Object (Returns Value)",
            "code": "l1 = [3, 1, 2]\nindex_of_2 = l1.index(2) # returns index, doesn't change l1\nprint(index_of_2)\nprint(l1)",
            "why": "The `list.index()` method returns the index of the specified element without modifying the original list `l1`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-17",
            "kind": "correct",
            "title": "Flexible Arguments with *args",
            "code": "def sum_even_integers(*args):\n    result = 0\n    for x in args:\n        if type(x) == int and x % 2 == 0:\n            result += x\n    return result\n\nprint(sum_even_integers(1, '2', 3.0, 4, 6))",
            "why": "The `*args` parameter collects all positional arguments into a tuple. The function then iterates through this tuple to filter and sum even integers.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Functions are first-class objects in Python, defined using the `def` keyword, and can be called using parentheses `()`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Define & Call Function",
                "text": "",
                "code": "def greet(name):\n    return f\"Hello, {name}!\"\n\nmessage = greet(\"Alice\")\nprint(message)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Function definitions include the `def` keyword, a function name, parameters in parentheses, a colon, and an indented body.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Function Definition Structure",
                "text": "A Python function definition includes the 'def' keyword, the function name, parameters within parentheses, a colon, and an indented block for the function body.",
                "code": "def adder(n1, n2): # def, name, params, colon\n    total = n1 + n2    # indented body\n    return total",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Functions can return values, which are then assigned to variables or used in expressions.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Function Return Values",
                "text": "",
                "code": "def multiply(a, b):\n    return a * b\n\nresult = multiply(4, 5) # Assign return value to 'result'\nprint(multiply(2, 3) + 1) # Use return value in expression",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Attempting to call a function using square brackets `[]` instead of parentheses `()` results in a TypeError.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "TypeError: Incorrect Call Syntax",
                "text": "Calling a function with square brackets `[]` instead of parentheses `()` will result in a TypeError.",
                "code": "def my_function():\n    pass\n\ntry:\n    my_function[1, 2]\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Built-in functions like `print()`, `id()`, `len()`, `type()`, and `del()` are available for common operations.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Common Built-in Functions",
                "text": "",
                "code": "x = [1, 2, 3]\nprint(f\"Length: {len(x)}\")\nprint(f\"Type: {type(x)}\")\nprint(f\"ID: {id(x)}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "The `len()` function can be applied to sequences (like lists, tuples, strings) and collections (like sets, dictionaries), but not directly to integers or booleans.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "len() Function Usage",
                "text": "`len()` works on sequences and collections, but not direct numeric or boolean types.",
                "code": "print(len([1, 2, 3]))    # List\nprint(len('hello'))     # String\nprint(len({'a': 1, 'b': 2})) # Dictionary\n\ntry:\n    print(len(123))  # TypeError\nexcept TypeError as e:\n    print(f\"Error for int: {e}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Lambda functions are anonymous, single-expression functions defined using the `lambda` keyword and are often used with higher-order functions like `map()`, `filter()`, `reduce()`, `sorted()`, and `max()`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Basic Lambda Function",
                "text": "",
                "code": "add_two = lambda x, y: x + y\nprint(add_two(5, 3)) # Output: 8",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`map()` applies a given function to all items in an input iterable and returns a map object (which can be converted to a list).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "map() with Lambda",
                "text": "",
                "code": "numbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared) # Output: [1, 4, 9, 16, 25]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`filter()` constructs an iterator from elements of an iterable for which a function returns true.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "filter() with Lambda",
                "text": "",
                "code": "numbers = [1, 2, 3, 4, 5, 6]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even) # Output: [2, 4, 6]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "`reduce()` applies a function of two arguments cumulatively to the items of a sequence, from left to right, to reduce the sequence to a single value.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "example",
                "title": "reduce() for Cumulative Operations",
                "text": "Note: `reduce` is in the `functools` module.",
                "code": "from functools import reduce\nnumbers = [1, 2, 3, 4, 5]\nproduct = reduce(lambda x, y: x * y, numbers)\nprint(product) # Output: 120",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "Functions can be defined inside other functions, with the inner function only being visible and accessible within the scope of the outer function.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "example",
                "title": "Nested Function Scope",
                "text": "",
                "code": "def outer():\n    x = 10\n    def inner():\n        print(x) # inner can access x from outer\n    inner()\nouter() # Output: 10",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "A function can return another function, creating a 'function factory' or 'closure' where the returned inner function retains access to variables from its enclosing scope.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "example",
                "title": "Function Factory (Closure)",
                "text": "",
                "code": "def make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = make_multiplier(3)\nprint(times3(5)) # Output: 15",
                "table": null
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "The `nonlocal` keyword allows a nested function to modify variables in its immediately enclosing (non-global) scope.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "example",
                "title": "nonlocal Keyword",
                "text": "",
                "code": "def counter():\n    count = 0\n    def increment():\n        nonlocal count # Allows modifying count in enclosing scope\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c()) # Output: 1\nprint(c()) # Output: 2",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "Methods are functions attached to objects, called using dot notation (`object.method()`).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "example",
                "title": "Calling a Method",
                "text": "Methods are called using dot notation on an object.",
                "code": "my_string = \"hello world\"\nprint(my_string.upper()) # Output: HELLO WORLD",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "When calling a method on an immutable object (e.g., string), the method returns a new value, so the result must be captured by assignment to update the variable.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "example",
                "title": "Immutable Object Methods",
                "text": "Methods on immutable objects (like strings) return a new value. You must reassign the variable to capture the change.",
                "code": "s1 = 'python'\ns1_upper = s1.upper() # New string is returned and captured\nprint(s1)        # Output: python (original unchanged)\nprint(s1_upper)  # Output: PYTHON",
                "table": null
              }
            ]
          },
          {
            "id": "kp-16",
            "text": "Methods on mutable objects (e.g., list) may either change the object in place and return `None` (e.g., `list.sort()`) or return a new value without modifying the object (e.g., `list.index()`).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-16-d1",
                "kind": "explanation",
                "title": "Mutable Object Methods",
                "text": "Some methods on mutable objects (e.g., lists) modify the object in place and return `None`, while others return a new value without modifying the original.",
                "code": "my_list = [3, 1, 2]\nmy_list.sort() # Modifies my_list in place, returns None\nprint(my_list) # Output: [1, 2, 3]\n\nindex_of_2 = my_list.index(2) # Returns a value, does not modify my_list\nprint(index_of_2) # Output: 1",
                "table": null
              }
            ]
          },
          {
            "id": "kp-17",
            "text": "The `*args` syntax allows a function to accept a variable number of non-keyword arguments, which are then received as a tuple.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-17-d1",
                "kind": "example",
                "title": "Variable Number of Arguments (*args)",
                "text": "",
                "code": "def sum_all(*args):\n    total = 0\n    for num in args:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3))    # Output: 6\nprint(sum_all(10, 20, 30, 40)) # Output: 100",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-160b2f4876",
          "exm-7c32aece02",
          "exm-08341d3aa4",
          "lec-8bc2ca06f4",
          "lec-805233cb66",
          "lec-870bff9b01",
          "lec-b5af6f4178",
          "nb-711110ef0a",
          "nb-eb8335fd0f",
          "nb-09ab40d9b7"
        ]
      }
    },
    {
      "id": "topic-dict",
      "topic": "Dictionaries",
      "canonical_topic": "dictionary",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 8,
        "coverage_count": 4,
        "by_exam": {
          "extra_practice": 5,
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        }
      },
      "related_topics": [
        "Dictionaries",
        "Lists vs Dictionaries vs Sets \u2014 ordered/unordered",
        "Looping over dictionaries",
        "dict / in operator",
        "dictionaries / average",
        "dictionaries / indexing",
        "dictionaries / nested dicts",
        "dictionaries / zip / counting",
        "dictionary",
        "dictionary / methods",
        "enumerate / dictionaries / conditions",
        "looping_dicts",
        "dict / average"
      ],
      "trap_patterns": [
        {
          "pattern": "dict 'in' checks KEYS not values",
          "trap": "4 in {1:4, 2:3} \u2192 False (4 is a value, not a key)",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2024"
          ]
        },
        {
          "pattern": "Empty set: {} creates dict, not set",
          "trap": "s = {} \u2192 empty dict. s = set() \u2192 empty set",
          "weeks": [
            2
          ],
          "appears_in_exams": []
        },
        {
          "pattern": "dict to tuple gives keys only",
          "trap": "tuple({1:'a',2:'b'}) \u2192 (1,2) \u2014 only keys, not values or items",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "trial_midterm"
          ]
        },
        {
          "pattern": "for key in dict == for key in dict.keys()",
          "trap": "Looping directly over a dict iterates over keys only",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "midterm_2023"
          ]
        },
        {
          "pattern": "RuntimeError: dictionary changed size during iteration",
          "trap": "Adding or deleting dict entries while iterating over it causes RuntimeError",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' \u2014 this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-c54469d107",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Lists vs Dictionaries vs Sets \u2014 ordered/unordered",
            "explanation": "Lists, tuples, strings are SEQUENCES (ordered). Dicts and sets are NOT sequences (unordered for equality). All are called collections.",
            "code_examples": [
              {
                "description": "Ordering comparison",
                "code": "print([1,2] == [2,1])        # False (ordered)\nprint((1,2) == (2,1))        # False (ordered)\nprint('12' == '21')          # False (ordered)\nprint({1,2} == {2,1})        # True  (unordered)\nprint({1:1,2:2}=={2:2,1:1})  # True  (unordered)"
              }
            ]
          },
          {
            "id": "lec-5ae780c366",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Looping over dictionaries",
            "explanation": ".keys() \u2192 key sequence. .values() \u2192 value sequence. .items() \u2192 sequence of (key, value) tuples. 'for key in dict' is the same as 'for key in dict.keys()'.",
            "code_examples": [
              {
                "description": "Looping over dict",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\n# These two are equivalent:\nfor key in capitals:\nfor key in capitals.keys():"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-d0901c699d",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 4,
            "week": 2,
            "topic": "dictionaries / average",
            "question": "math_scores = {'John': 85, 'Sarah': 92, 'Michael': 78, 'Emma': 90, 'David': 82}\n\nYou want to find and print the names of the students who scored above the average score.\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "average_score = sum(math_scores.values())/len(math_scores)\n\tfor student in math_scores.keys():\n\t\tif math_scores[student] > average_score:\n\t\t\tprint(student)",
              "b": "for student in math_scores:\n\tif math_scores[student] > (sum(math_scores.values())/len(math_scores)):\n\t\tprint(student)",
              "c": "Both code segments will work as intended.",
              "d": "Neither code segment will work as intended."
            },
            "correct": "b",
            "explanation": "Option a has an indentation error (the for loop is indented under the average_score line as if it's a block, but there's no colon). This causes an IndentationError. Option b works correctly. Actually option a depends on whether the indentation shown is a tab after a plain statement \u2014 in Python that's an IndentationError. So only b works. Correct: b."
          },
          {
            "id": "exm-f6de891c85",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 5,
            "week": 2,
            "topic": "dictionaries / zip / counting",
            "question": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\nYou need to create a dictionary called grade_counts that counts the number of students in each grade level.\n\nExpected: {9:3, 10:2, 11:1}\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "grade_counts = {}\nfor grade in grades:\n\tif grade not in grade_counts:\n\t\tgrade_counts[grade] = 0\n\tgrade_counts[grade] += 1",
              "b": "grade_counts = {}\nfor student, grade in zip(students, grades):\n\tif grade in grade_counts:\n\t\tgrade_counts[grade].append(student)\n\telse:\n\t\tgrade_counts[grade] = [student]",
              "c": "Both of the given options will work as intended.",
              "d": "Neither of the given options will work as intended."
            },
            "correct": "a",
            "explanation": "Option a correctly counts grades: initialises to 0 and increments. Produces {9:3, 10:2, 11:1}. Option b creates lists of student names, not counts \u2014 produces {9:['A','C','F'], 10:['B','E'], 11:['D']}, not the required format. Correct: a."
          },
          {
            "id": "exm-fd0aa669b7",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 8,
            "week": 2,
            "topic": "dictionaries / indexing",
            "question": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\n\nWhich of the following lines of code will print True?",
            "code_context": "",
            "options": {
              "a": "print(x['a'][1] * x['b'][0] == x['c'][1])",
              "b": "print(x['b'][0] + x['c'][0] == x['d'][1])",
              "c": "print(x['d'][0] - x['c'][0] == x['a'][1])",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: x['a'][1]=2, x['b'][0]=3, 2*3=6, x['c'][1]=6. True. b: x['b'][0]=3, x['c'][0]=5, 3+5=8, x['d'][1]=8. True. c: x['d'][0]=7, x['c'][0]=5, 7-5=2, x['a'][1]=2. True. All are True, so d is correct."
          },
          {
            "id": "exm-f358fb2d91",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 12,
            "week": 2,
            "topic": "enumerate / dictionaries / conditions",
            "question": "def counter(y):\n\tx = {}\n\tfor index, element in enumerate(y):\n\t\tif index != int(element) and int(element) % 2 == 0:\n\t\t\tx[element] = len(element)\n\treturn x\n\nWhat will this function return when called as:\ncounter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])",
            "code_context": "",
            "options": {
              "a": "{'12345678': 8, '1234': 4, '12': 2, '123456': 6}",
              "b": "{'12345678': 8, '123': 3, '1234': 4, '12345': 5, '12': 2, '6': 1, '1': 1, '123456': 6}",
              "c": "{'123': 3, '12345': 5, '1': 1}",
              "d": "{'12345678': 8, '1': 1, '1234': 4, '12': 2, '6': 1, '123456': 6}"
            },
            "correct": "a",
            "explanation": "index 0: '12345678', int=12345678, index(0)!=12345678 \u2713, even \u2713 \u2192 add, len=8. index 1: '1', int=1, index==int \u2192 skip. index 2: '123', int=123, odd \u2192 skip. index 3: '1234', int=1234, index(3)!=1234 \u2713, even \u2713 \u2192 add, len=4. index 4: '12345', int=12345, odd \u2192 skip. index 5: '12', int=12, index(5)!=12 \u2713, even \u2713 \u2192 add, len=2. index 6: '6', int=6, index(6)==6 \u2192 skip. index 7: '1', int=1, odd \u2192 skip. index 8: '123456', int=123456, index(8)!=123456 \u2713, even \u2713 \u2192 add, len=6. Result: {'12345678':8,'1234':4,'12':2,'123456':6}. Correct: a."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Dictionaries map unique hashable keys to values and support fast key-based lookup. For exam work, track whether code is iterating keys, values, or key-value pairs, and remember that `in` checks keys. For tasks like averages, use `sum(d.values()) / len(d)` and then iterate `d.items()` when filtering by a threshold."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Does `key in d` check keys or values?",
            "What is the difference between `d[key]` and `d.get(key, default)`?",
            "What happens when you access a missing key directly?",
            "How do you iterate over both keys and values at the same time?",
            "What does `list(d)` return for a dictionary?",
            "Why can't a `list` be used as a dictionary key?",
            "Why does deleting keys while iterating raise `RuntimeError`?",
            "How do `d1.update(d2)` and `{**d1, **d2}` differ?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Creating and manipulating dictionaries",
            "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium']) # Accessing a value\ndel(capitals['Belgium']) # Deleting a key-value pair\ncapitals['Netherlands'] = 'Amsterdam' # Adding a new key-value pair\ncapitals.update({'France': 'Paris'}) # Updating/adding multiple key-value pairs\nprint(capitals)",
            "why": "Demonstrates various ways to create, access, add, update, and delete entries in a dictionary.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Checking key membership with 'in'",
            "code": "d = {1: 4, 2: 3}\nprint(1 in d) # True, because 1 is a key\nprint(4 in d) # False, because 4 is a value, not a key",
            "why": "The `in` operator checks for the presence of a key, not a value, in a dictionary.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Dictionary equality ignores order",
            "code": "print({1:1, 2:2} == {2:2, 1:1}) # True\nprint([1,2] == [2,1]) # False (for lists, order matters)",
            "why": "Dictionaries are unordered collections, so their equality comparison does not depend on the order of key-value pairs. Lists, however, are ordered, and their equality comparison does depend on order.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Creating a dictionary from two lists using zip",
            "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares) # Output: {1: 1, 2: 4, 3: 9, 4: 16}",
            "why": "The `zip()` function pairs corresponding elements from two iterables, and `dict()` converts these pairs into key-value entries.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Iterating over dictionary keys, values, and items",
            "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\nfor key in capitals: # Equivalent to for key in capitals.keys()\n    print(key)",
            "why": "Demonstrates different ways to iterate through a dictionary's keys, values, or both, using `.keys()`, `.values()`, `.items()`, and direct iteration.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Finding highest and lowest scores in nested dictionaries",
            "code": "results = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nallscores = []\nfor player_scores in results.values():\n    allscores.extend(player_scores.values())\n\nglobal_max = max(allscores)\nglobal_min = min(allscores)\n\nmax_scorers = []\nmin_scorers = []\nfor player, scores in results.items():\n    for score in scores.values():\n        if score == global_max:\n            max_scorers.append(player)\n        if score == global_min:\n            min_scorers.append(player)\n\nfinal_dict = {global_max: sorted(list(set(max_scorers))), global_min: sorted(list(set(min_scorers)))}\nprint(final_dict)",
            "why": "This code snippet correctly identifies the global maximum and minimum scores across all players' attempts and then constructs a dictionary mapping these scores to the names of players who achieved them.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Counting occurrences of items in a list using a dictionary",
            "code": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\ngrade_counts = {}\nfor grade in grades:\n    if grade not in grade_counts:\n        grade_counts[grade] = 0\n    grade_counts[grade] += 1\nprint(grade_counts) # Output: {9: 3, 10: 2, 11: 1}",
            "why": "This correctly initializes a count for each unique grade encountered and increments it, resulting in a dictionary where keys are grades and values are their frequencies.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Complex dictionary access and manipulation",
            "code": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\nprint(x['a'][1] * x['b'][0] == x['c'][1])\nprint(x['b'][0] + x['c'][0] == x['d'][1])\nprint(x['d'][0] - x['c'][0] == x['a'][1])",
            "why": "This example demonstrates accessing values within nested lists inside a dictionary and performing arithmetic/comparison operations on them.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Calculating average and finding students above average",
            "code": "math_scores = {'John': 85, 'Sarah': 92, 'Michael': 78, 'Emma': 90, 'David': 82}\naverage_score = sum(math_scores.values()) / len(math_scores)\nfor student in math_scores:\n    if math_scores[student] > average_score:\n        print(student)",
            "why": "This code correctly calculates the average score from dictionary values and then iterates through the dictionary keys to find and print students whose scores exceed the average.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Function with dictionary population based on conditions",
            "code": "def counter(y):\n    x = {}\n    for index, element in enumerate(y):\n        if index != int(element) and int(element) % 2 == 0:\n            x[element] = len(element)\n    return x\nprint(counter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456']))",
            "why": "This function iterates through a list, applies specific conditions (index not equal to integer value of element, and integer value is even), and populates a dictionary where keys are the elements and values are their lengths.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "incorrect",
            "title": "Incorrect dictionary iteration unpacking",
            "code": "math_scores = {'John': 85, 'Sarah': 92}\nfor student, score in math_scores:\n    print(student, score)",
            "why": "Iterating a dictionary yields keys; unpacking each key into two variables fails unless iterating over `math_scores.items()`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "incorrect",
            "title": "Incorrectly grouping students by grade instead of counting",
            "code": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\ngrade_counts = {}\nfor student, grade in zip(students, grades):\n    if grade in grade_counts:\n        grade_counts[grade].append(student)\n    else:\n        grade_counts[grade] = [student]\nprint(grade_counts) # Output: {9: ['A', 'C', 'F'], 10: ['B', 'E'], 11: ['D']}",
            "why": "This code snippet creates a dictionary where values are lists of student names for each grade, rather than a count of students per grade, which was the intended task.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "incorrect",
            "title": "Using `tuple()` on a dictionary yields only keys",
            "code": "d = {1:'a', 2:'b'}\nprint(tuple(d)) # Output: (1, 2)",
            "why": "When a dictionary is converted to a tuple (or list), only its keys are included, not its values or key-value pairs.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Dictionaries store data as unordered sets of unique, immutable key-value pairs.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Unordered Nature",
                "text": "Dictionaries are unordered, meaning the order of insertion does not affect their equality.",
                "code": "print({1:1, 2:2} == {2:2, 1:1}) # True",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "explanation",
                "title": "Immutable Keys",
                "text": "Keys must be immutable (hashable). Mutable objects like lists cannot be used as keys.",
                "code": "a = 1\nb = {1:1}\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e) # Output: TypeError: unhashable type: 'dict'",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "The `in` operator checks for the presence of a key in a dictionary, not a value.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Checking for Keys",
                "text": "The 'in' operator checks for the presence of a key, not a value, in a dictionary.",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d) # True (1 is a key)\nprint(4 in d) # False (4 is a value, not a key)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Dictionaries are considered equal if they contain the same key-value pairs, regardless of the order of insertion.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Equality Comparison",
                "text": "Dictionaries are equal if they contain the same key-value pairs, regardless of their order.",
                "code": "dict1 = {1: 1, 2: 2}\ndict2 = {2: 2, 1: 1}\nprint(dict1 == dict2) # True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "An empty dictionary can be created using literal curly braces `{}` or the `dict()` constructor.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Creating Empty Dictionaries",
                "text": "Both curly braces and the dict() constructor create an empty dictionary.",
                "code": "empty_dict1 = {}\nempty_dict2 = dict()\nprint(empty_dict1) # {}\nprint(empty_dict2) # {}",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "explanation",
                "title": "Empty Dict vs. Set",
                "text": "Note that `{}` creates an empty dictionary, not an empty set. To create an empty set, use `set()`.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Dictionary elements can be accessed using square bracket notation with the key.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Accessing Values",
                "text": "Access values using square bracket notation with the corresponding key.",
                "code": "capitals = {'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium']) # Brussels",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "New key-value pairs can be added or existing values updated by assigning a value to a key using square bracket notation.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Adding and Updating",
                "text": "Assigning a value to a key adds a new pair or updates an existing one.",
                "code": "d = {'a': 1, 'b': 2}\nd['c'] = 3 # Add new key-value pair\nd['a'] = 10 # Update existing value\nprint(d) # {'a': 10, 'b': 2, 'c': 3}",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Multiple key-value pairs can be inserted or updated using the `update()` method.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Batch Update with update()",
                "text": "The `update()` method merges a dictionary with new key-value pairs, adding new keys or overwriting existing ones.",
                "code": "squares = {1:1, 2:4}\nsquares.update({3:9, 4:16})\nprint(squares) # {1: 1, 2: 4, 3: 9, 4: 16}",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Key-value pairs can be removed from a dictionary using the `del` statement.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "Deleting Key-Value Pairs",
                "text": "The `del` statement removes a key-value pair from the dictionary.",
                "code": "d = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d) # {'x': 1, 'z': 3}",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "Dictionaries can be constructed from two sequences (e.g., lists) of keys and values using the `zip()` function with the `dict()` constructor.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "Constructing from Sequences",
                "text": "Use `dict(zip(keys, values))` to create a dictionary from two lists.",
                "code": "keys_list = [1, 2, 3]\nvalues_list = [1, 4, 9]\nsquares_dict = dict(zip(keys_list, values_list))\nprint(squares_dict) # {1: 1, 2: 4, 3: 9}",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Looping directly over a dictionary iterates through its keys.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "example",
                "title": "Looping Over Keys",
                "text": "Direct iteration over a dictionary loops through its keys.",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals:\n    print(key)\n# Output:\n# Andorra\n# Belgium",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "The `.keys()` method returns a view object that displays a list of all the keys in the dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "example",
                "title": "Getting All Keys",
                "text": "The `.keys()` method returns a view of all keys. This can be converted to a list.",
                "code": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels'}\nall_keys = list(capitals.keys())\nprint(all_keys) # ['Estonia', 'Belgium']",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "The `.values()` method returns a view object that displays a list of all the values in the dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "example",
                "title": "Getting All Values",
                "text": "The `.values()` method returns a view of all values. This can be converted to a list.",
                "code": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels'}\nall_values = list(capitals.values())\nprint(all_values) # ['Tallinn', 'Brussels']",
                "table": null
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "The `.items()` method returns a view object that displays a list of a dictionary's key-value tuple pairs.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "example",
                "title": "Getting Key-Value Pairs",
                "text": "The `.items()` method returns a view of all key-value pairs as tuples.",
                "code": "capitals = {'France': 'Paris', 'Germany': 'Berlin'}\nall_items = list(capitals.items())\nprint(all_items) # [('France', 'Paris'), ('Germany', 'Berlin')]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "Modifying a dictionary (adding or deleting items) during iteration can cause a `RuntimeError`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "explanation",
                "title": "Avoid Concurrent Modification",
                "text": "Modifying a dictionary (adding or deleting items) while iterating over it can lead to a `RuntimeError`.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "The `len()` function returns the number of key-value pairs in a dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "example",
                "title": "Getting Dictionary Size",
                "text": "The `len()` function returns the number of key-value pairs in the dictionary.",
                "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint(len(d)) # 3",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-3555baf8ba",
          "exm-4cee2500a8",
          "exm-57e3a8ca18",
          "exm-f44278f521",
          "exm-f6de891c85",
          "lec-27dc11e221",
          "lec-5ae780c366",
          "nb-24dbf7c985",
          "exm-d0901c699d",
          "exm-fd0aa669b7"
        ]
      }
    },
    {
      "id": "topic-indexing",
      "topic": "Indexing",
      "canonical_topic": "indexing",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 8,
        "by_exam": {
          "extra_practice": 3,
          "midterm_2024": 2,
          "trial_midterm": 2,
          "midterm_2023": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Indexing",
        "dict / nested indexing",
        "dictionaries / indexing",
        "dictionaries / nested dicts",
        "indexing",
        "indexing / negative",
        "indexing / slicing",
        "indexing / type_conversion",
        "string indexing",
        "type conversion",
        "type conversion / indexing",
        "type_conversion"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-3c6bbdd9be",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Indexing",
            "explanation": "Forward: 0, 1, 2, ... len-1. Backward: -1 (last), -2 (second to last), ..., -len (first). l1[0] == l1[-len(l1)]",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-1b0f40ae76",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 1,
            "week": 1,
            "topic": "indexing / slicing",
            "question": "What is the output of the following code?\n\nx = 'Hello, World!'\nprint(x[-6:-1])",
            "code_context": "",
            "options": {
              "A": "World",
              "B": "orld!",
              "C": "World!",
              "D": "orld"
            },
            "correct": "A",
            "explanation": "x[-6:-1] starts 6 from the end ('W') and goes to 1 from the end (exclusive of '!'). That gives 'World'."
          },
          {
            "id": "exm-db07780cd0",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 3,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nx = '5'\ny = 2\nprint(x * y)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "52",
              "C": "55",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "String * integer repeats the string. '5' * 2 = '55'."
          },
          {
            "id": "exm-5c2740063a",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 4,
            "week": 1,
            "topic": "indexing / negative",
            "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[-2])",
            "code_context": "",
            "options": {
              "A": "20",
              "B": "30",
              "C": "40",
              "D": "50"
            },
            "correct": "C",
            "explanation": "lst[-2] is the second-to-last element: 40."
          },
          {
            "id": "exm-edec745151",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 5,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nprint(int('42') + float('3.5'))",
            "code_context": "",
            "options": {
              "A": "45",
              "B": "45.5",
              "C": "'423.5'",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "int('42')=42, float('3.5')=3.5. 42 + 3.5 = 45.5."
          },
          {
            "id": "exm-14f703ef57",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 4,
            "week": 1,
            "topic": "string indexing",
            "question": "What is the output of the following code?\n\ns = 'Python'\nprint(s[1:4])",
            "code_context": "",
            "options": {
              "A": "Pyt",
              "B": "yth",
              "C": "ytho",
              "D": "ython"
            },
            "correct": "B",
            "explanation": "s[1:4] gives characters at indices 1, 2, 3: 'y', 't', 'h' = 'yth'."
          },
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-fd0aa669b7",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 8,
            "week": 2,
            "topic": "dictionaries / indexing",
            "question": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\n\nWhich of the following lines of code will print True?",
            "code_context": "",
            "options": {
              "a": "print(x['a'][1] * x['b'][0] == x['c'][1])",
              "b": "print(x['b'][0] + x['c'][0] == x['d'][1])",
              "c": "print(x['d'][0] - x['c'][0] == x['a'][1])",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: x['a'][1]=2, x['b'][0]=3, 2*3=6, x['c'][1]=6. True. b: x['b'][0]=3, x['c'][0]=5, 3+5=8, x['d'][1]=8. True. c: x['d'][0]=7, x['c'][0]=5, 7-5=2, x['a'][1]=2. True. All are True, so d is correct."
          },
          {
            "id": "exm-bd5df4659c",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 11,
            "week": 1,
            "topic": "type conversion / indexing",
            "question": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\n\nWhat is the output of the following code snippet?\n\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
            "code_context": "",
            "options": {
              "a": "SyntaxError",
              "b": "IndexError: list index out of range",
              "c": "False",
              "d": "True"
            },
            "correct": "d",
            "explanation": "x[2] = (1,2). x[2][0]=1, x[2][1]=2. 1+2=3. float(3)=3.0. type(3.0)=float. x[-2]=3.0 (index 5). type(3.0)=float. float==float \u2192 True."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-8ea9af8f8b",
            "week": 1,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(int('123'))\nprint(float('123'))\n\nprint(str(123))\nprint(float(123))\n\nprint(int(123.0))\nprint(str(123.0))",
            "outputs": []
          },
          {
            "id": "nb-c488bc51d9",
            "week": 1,
            "cell_index": 24,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "integer_list = [1, 2, 3, 1]\nletter_list = ['a', 'b', 'c', 'd']\nprint(set(integer_list))\nprint(tuple(integer_list))\nprint(dict(zip(letter_list, integer_list)))\n\ninteger_tuple = (1, 2, 3, 1)\nletter_tuple = ('a', 'b', 'c', 'd')\nprint(set(integer_tuple))\nprint(list(integer_tuple))\nprint(dict(zip(letter_tuple, integer_tuple)))\n\ninteger_set = {1, 2, 3}\nletter_set = {'a', 'b', 'c'}\nprint(list(integer_set))\nprint(tuple(letter_set))\nprint(dict(zip(integer_set, letter_set)))\n\nd_1 = {1: 'c', 2: 'b', 3: 'a'}\nprint(list(d_1))\nprint(tuple(d_1))\nprint(set(d_1))",
            "outputs": []
          },
          {
            "id": "nb-a8e98f1319",
            "week": 1,
            "cell_index": 60,
            "cell_type": "code",
            "topic": "indexing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6] == 'G')\nprint(l1[6] == l1[-2])\nprint(l1[7] == 'H')\nprint(l1[7] == l1[-1])\nprint(l1[len(l1)-1] == l1[-1])\nprint(l1[len(l1)])",
            "outputs": []
          },
          {
            "id": "nb-b60399a503",
            "week": 2,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1 + True, 1.0 + False, True + False)",
            "outputs": []
          },
          {
            "id": "nb-01f6077d4d",
            "week": 2,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1==1.0, 1.0 == True, 0 == False)",
            "outputs": []
          },
          {
            "id": "nb-3f066f26aa",
            "week": 2,
            "cell_index": 106,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print ('1' * 2, '1' * True, '1' * False)",
            "outputs": []
          },
          {
            "id": "nb-a358f49009",
            "week": 2,
            "cell_index": 114,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print ('1' + 2)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-3bd8e4f40b",
            "week": 2,
            "cell_index": 117,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(str(1) == '1')\nprint(int('1') == 1)",
            "outputs": []
          },
          {
            "id": "nb-614c69b0f2",
            "week": 2,
            "cell_index": 118,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(float('1') == 1.0)\nprint(float('1.0') == 1.0)  \nprint(tuple([1,2,3]) == (1,2,3))  \nprint(tuple({1:3, 2:4}) == (1,2))  \nprint(dict([(1,3), (2,4)]) == {1: 3, 2:4})",
            "outputs": []
          },
          {
            "id": "nb-4a7fe9bef0",
            "week": 2,
            "cell_index": 119,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(int('1a') == 1)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-66deb9932d",
            "week": 2,
            "cell_index": 120,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(dict([1, 2]))\nexcept Exception as e:\n    print(e)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Indexing allows you to access individual elements in ordered data types like lists, tuples, and strings. Python uses zero-based indexing, where the first element is at index 0. Negative indexing provides a convenient way to access elements from the end of the sequence, where -1 is the last element. Slicing, using the `[start:stop]` syntax, extracts a portion of a sequence, but it's crucial to remember that the eleme"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What error occurs if you use an index that is too large? (`IndexError`)",
            "How do you get the last N elements of a sequence?",
            "What is the index of the first element?",
            "What is the index of the last element?",
            "What does the slice `s[1:4]` include?",
            "What does `my_list[-1]` return?",
            "In a complex expression, what is the data type after multiple indexing and conversion steps?",
            "What is the output of multiplying a string by an integer (e.g., `'5' * 2`)?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic String Slicing with Positive Indices",
            "code": "s = 'Python'\nprint(s[1:4])",
            "why": "The slice `[1:4]` extracts characters from index 1 up to (but not including) index 4, which are 'y', 't', and 'h'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "List Indexing with Negative Index",
            "code": "lst = [10, 20, 30, 40, 50]\nprint(lst[-2])",
            "why": "`lst[-2]` accesses the second-to-last element in the list, which is 40.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Nested Data Structure Indexing (Dictionary of Lists)",
            "code": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\nprint(x['a'][1] * x['b'][0] == x['c'][1])",
            "why": "`x['a'][1]` is 2, `x['b'][0]` is 3, and `x['c'][1]` is 6. The expression `2 * 3 == 6` evaluates to `True`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Tuple Indexing and Type Comparison in a List",
            "code": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
            "why": "`x[2]` is the tuple `(1, 2)`. `x[2][0] + x[2][1]` evaluates to `1 + 2 = 3`. `float(3)` is `3.0`, so `type(float(x[2][0] + x[2][1]))` is `float`. `x[-2]` is `3.0`, which also has a type of `float`. Therefore, `float == float` is `True`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "IndexError from Out-of-Bounds Indexing",
            "code": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\ntry:\n    print(l1[len(l1)])\nexcept IndexError as e:\n    print(f\"Caught expected error: {e}\")",
            "why": "The length of `l1` is 8, meaning valid indices range from 0 to 7. Attempting to access `l1[8]` (an index equal to the list's length) results in an `IndexError`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Forward indexing in Python sequences starts at 0 for the first element and proceeds incrementally up to `length - 1` for the last element.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Basic Forward Indexing",
                "text": "",
                "code": "my_list = ['a', 'b', 'c']\nprint(my_list[0])",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "explanation",
                "title": "First Element Equivalence",
                "text": "The first element can be accessed using index 0 or by using negative indexing with the length of the sequence.",
                "code": "l1 = ['A', 'B', 'C']\nprint(l1[0] == l1[-len(l1)])",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Backward (negative) indexing in Python sequences starts at -1 for the last element and decrements to `-length` for the first element.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Basic Negative Indexing",
                "text": "",
                "code": "lst = [10, 20, 30, 40, 50]\nprint(lst[-2])",
                "table": null
              },
              {
                "id": "kp-2-d2",
                "kind": "example",
                "title": "Last Element Access",
                "text": "",
                "code": "s = 'Python'\nprint(s[-1])",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Slicing a sequence using the syntax `[start:end]` extracts elements from the `start` index up to, but not including, the `end` index.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Basic Slicing",
                "text": "Slicing extracts elements from `start` up to, but not including, `end`.",
                "code": "s = 'Python'\nprint(s[1:4]) # Output: yth",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Negative Slicing",
                "text": "Negative indices can also be used for slicing.",
                "code": "x = 'Hello, World!'\nprint(x[-6:-1]) # Output: World",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Attempting to access an index that is equal to or greater than the length of a sequence will result in an `IndexError`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "IndexError Demonstration",
                "text": "Accessing an index equal to or greater than the sequence length causes an IndexError.",
                "code": "my_list = ['a', 'b', 'c']\ntry:\n    print(my_list[len(my_list)])\nexcept IndexError as e:\n    print(e) # Output: list index out of range",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Elements within nested data structures, such as lists inside dictionaries or tuples inside lists, are accessed sequentially using multiple indexing or key-access operations.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "List within Dictionary",
                "text": "Accessing an item in a list that is a value in a dictionary.",
                "code": "my_dict = {'a': [1, 2], 'b': [3, 4]}\nprint(my_dict['a'][1]) # Output: 2",
                "table": null
              },
              {
                "id": "kp-5-d2",
                "kind": "example",
                "title": "Tuple within List",
                "text": "Accessing an item in a tuple that is an element of a list.",
                "code": "my_list = ['str', [1], (10, 20), {}]\nprint(my_list[2][0]) # Output: 10",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-1b0f40ae76",
          "exm-14f703ef57",
          "exm-5c2740063a",
          "exm-fd0aa669b7",
          "exm-db07780cd0",
          "exm-edec745151",
          "exm-f44278f521",
          "lec-3c6bbdd9be",
          "nb-a8e98f1319",
          "nb-8ea9af8f8b"
        ]
      }
    },
    {
      "id": "topic-scope",
      "topic": "Scope",
      "canonical_topic": "scope",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 6,
        "by_exam": {
          "midterm_2023": 2,
          "trial_midterm": 2,
          "extra_practice": 1,
          "midterm_2024": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Global and local scope",
        "nested functions / scope",
        "scope",
        "scope / UnboundLocalError",
        "scope / global",
        "scope / local_global"
      ],
      "trap_patterns": [
        {
          "pattern": "UnboundLocalError",
          "trap": "If a name appears on the left side of assignment ANYWHERE in a function, Python treats it as local THROUGHOUT the function body \u2014 even before the assignment line",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-b2f1496ec5",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Global and local scope",
            "explanation": "Local names: defined inside a function (parameter names + any assignment inside). Only known inside the function. Global names: defined outside any function, known everywhere EXCEPT when a same-named local exists (local dominates). Python makes names local at call time, BEFORE executing the body \u2014 so if you assign to a name ANYWHERE in a function, that name is local throughout the function (even before the assignment line). Use 'global' keyword to override (but avoid it).",
            "code_examples": [
              {
                "description": "Local name not accessible outside",
                "code": "def adder(n1, n2):\n    return n1 + n2\nadder(1, 2)\nprint(n1)  # NameError: name 'n1' is not defined"
              },
              {
                "description": "UnboundLocalError trap \u2014 local shadows global even before assignment",
                "code": "def main(a):\n    b = b      # ERROR: Python sees b assigned in function -> local\n    return a   # but local b has no value yet\nb = 1\nprint(main(1))  # UnboundLocalError"
              },
              {
                "description": "global keyword",
                "code": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)  # 2"
              },
              {
                "description": "Better pattern: avoid global",
                "code": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)  # 2"
              },
              {
                "description": "Mutable parameter is the SAME object",
                "code": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')  # The sum of [] = 15 !!!\n# l1 is empty because l2 and l1 refer to the SAME list object"
              },
              {
                "description": "Fix: copy mutable arg at start of function",
                "code": "def adder(l2):\n    l2 = l2[:]   # make a copy\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-aa69b4e771",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 11,
            "week": 3,
            "topic": "scope / global",
            "question": "What is the output of the following code?\n\nx = 10\ndef modify():\n    x = 20\n    print(x)\nmodify()\nprint(x)",
            "code_context": "",
            "options": {
              "A": "20\n20",
              "B": "10\n10",
              "C": "20\n10",
              "D": "10\n20"
            },
            "correct": "C",
            "explanation": "Inside modify(), x = 20 creates a local variable. Printing inside gives 20. After the call, global x is still 10."
          },
          {
            "id": "exm-a67a786ae7",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 12,
            "week": 3,
            "topic": "scope / UnboundLocalError",
            "question": "What is the output of the following code?\n\nx = 5\ndef func():\n    print(x)\n    x = 10\nfunc()",
            "code_context": "",
            "options": {
              "A": "5",
              "B": "10",
              "C": "UnboundLocalError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Because x is assigned inside func(), Python treats x as local throughout the function. Printing x before assignment raises UnboundLocalError."
          },
          {
            "id": "exm-4ae24a0d6a",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 13,
            "week": 3,
            "topic": "scope / UnboundLocalError",
            "question": "What is the output of the following code?\n\ny = 100\ndef func():\n    y += 1\n    return y\nprint(func())",
            "code_context": "",
            "options": {
              "A": "101",
              "B": "100",
              "C": "UnboundLocalError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "y += 1 makes y local to func(). But y hasn't been assigned locally before this line, causing UnboundLocalError."
          },
          {
            "id": "exm-f176c9e9e4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 9,
            "week": 3,
            "topic": "scope / global",
            "question": "What is the output of the following code?\n\ncount = 0\ndef increment():\n    global count\n    count += 1\n\nincrement()\nincrement()\nprint(count)",
            "code_context": "",
            "options": {
              "A": "0",
              "B": "1",
              "C": "2",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "The global keyword lets increment() modify the global count. After two calls, count = 2."
          },
          {
            "id": "exm-08341d3aa4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 15,
            "week": 3,
            "topic": "nested functions / scope",
            "question": "What is the output of the following code?\n\ndef outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "None",
              "C": "Error",
              "D": "0"
            },
            "correct": "A",
            "explanation": "inner() can access x from the enclosing scope (closure). Prints 10."
          },
          {
            "id": "exm-04e24a073b",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 2,
            "week": 3,
            "topic": "scope / global",
            "question": "val = 2\ndef func():\n    val = 3\n    print(val)\nfunc()\nprint(val)\n\nWhich of the following code snippets produces the same output as the above code snippet?",
            "code_context": "",
            "options": {
              "a": "val1 = 2\ndef func1():\n    val1 = val1 + 1\n    print(val1)\nfunc1()\nprint(val1)",
              "b": "val2 = 2\ndef func2():\n    global val2\n    val2 = val2 + 1\n    print(val2)\nfunc2()\nprint(val2)",
              "c": "val3 = 2\ndef func3():\n    val3 = 3\n    def innerfunc():\n        val3 = 2\n        print(val3)\n    print(val3)\nfunc3()\nprint(val3)",
              "d": "val4 = 2\ndef func4():\n    val4 = 3\n    def innerfunc():\n        val4 = 2\n        print(val4)\n    print(val4)\nfunc4()\ninnerfunc()"
            },
            "correct": "c",
            "explanation": "Original output: 3, 2. Option a: UnboundLocalError (val1 used before local assignment). Option b: global val2 modified to 3, print 3, then print val2=3. Output: 3,3. Option c: func3 creates local val3=3, prints 3. Global val3=2 unchanged, prints 2. Output: 3,2. Matches! Option d: innerfunc() called outside func4 scope \u2014 NameError. Correct: c."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-59b3d2b2bb",
            "week": 3,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "scope",
            "source": "del (n1, n2)\ndef adder(n1, n2):\n    return n1 + n2\nadder (1,2)\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-4151cecd5a",
            "week": 3,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-ae24f910b8",
            "week": 3,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    global n1\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-642af3f147",
            "week": 3,
            "cell_index": 31,
            "cell_type": "code",
            "topic": "scope",
            "source": "def main (a):\n    b = b\n    return a\nb = 1\nprint(main (1))",
            "outputs": []
          },
          {
            "id": "nb-6de5d86509",
            "week": 3,
            "cell_index": 32,
            "cell_type": "code",
            "topic": "scope",
            "source": "def main (a):\n    global b\n    b = b\n    return a\nb = 1\nprint(main (1))",
            "outputs": []
          },
          {
            "id": "nb-2b221f0928",
            "week": 3,
            "cell_index": 34,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-a8920b5b9d",
            "week": 3,
            "cell_index": 35,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Scope refers to the region of code where a variable is accessible. Variables defined inside a function are `local` to that function. If you assign a value to a variable within a function, Python automatically considers it a local variable for the entire function's scope. This can lead to an `UnboundLocalError` if you try to read that variable before the line where it's assigned, even if a global variable of the same"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "If a local and global variable share a name, which one is used inside the function?",
            "How can a function modify a variable that was defined outside of it?",
            "What is the value of the global variable after the function call?",
            "What is the difference between a local and global variable?",
            "Why did my program raise an `UnboundLocalError`?",
            "Are function parameters local or global?",
            "What is the difference between changing a global (`global x; x=0`) and mutating a global (`my_list.append(1)`)?",
            "What is the output of code that prints a variable both inside and outside a function where it is reassigned?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Local variable shadows global variable",
            "code": "x = 10\ndef modify():\n    x = 20\n    print(x)\nmodify()\nprint(x)",
            "why": "Inside modify(), 'x = 20' creates a local variable 'x'. The 'print(x)' inside the function outputs 20. After the function call, the global 'x' remains unchanged and 'print(x)' outside the function outputs 10.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "UnboundLocalError due to local assignment rule",
            "code": "x = 5\ndef func():\n    print(x)\n    x = 10\nfunc()",
            "why": "Because 'x' is assigned inside func(), Python treats 'x' as a local variable throughout the entire function. Attempting to 'print(x)' before it has been assigned a local value raises an UnboundLocalError.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "incorrect",
            "title": "UnboundLocalError with augmented assignment",
            "code": "y = 100\ndef func():\n    y += 1\n    return y\nprint(func())",
            "why": "The operation 'y += 1' implies an assignment, making 'y' local to 'func()'. However, 'y' is used (to retrieve its value for addition) before it has been locally assigned, causing an UnboundLocalError.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Modifying global variable using 'global' keyword",
            "code": "count = 0\ndef increment():\n    global count\n    count += 1\nincrement()\nincrement()\nprint(count)",
            "why": "The 'global count' statement explicitly tells Python that the 'count' inside 'increment()' refers to the global variable. Each call to 'increment()' successfully modifies the global 'count'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Accessing variables from an enclosing scope (closure)",
            "code": "def outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\nouter()",
            "why": "The nested function 'inner()' forms a closure, allowing it to access 'x' from its enclosing function's scope ('outer()'), even though 'x' is not global or local to 'inner()'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Differentiating local vs. global with same names",
            "code": "val = 2\ndef func():\n    val = 3\n    print(val)\nfunc()\nprint(val)",
            "why": "Inside 'func()', 'val = 3' creates a local variable 'val' which is printed (3). The global 'val' remains 2 and is printed after the function call. This demonstrates local variables shadowing global ones.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "How 'global' prevents UnboundLocalError for a variable used before local assignment",
            "code": "b = 1\ndef main(a):\n    global b\n    b = b\n    return a\nprint(main(1))\nprint(b)",
            "why": "Despite 'b = b' appearing as an assignment, the 'global b' declaration ensures that both sides of the assignment refer to the global 'b'. Thus, it reads the global 'b' (1) and reassigns it to global 'b', avoiding an UnboundLocalError.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "incorrect",
            "title": "NameError for local function parameter outside scope",
            "code": "def adder(n1, n2):\n    return n1 + n2\nadder(1, 2)\nprint(n1)",
            "why": "Function parameters 'n1' and 'n2' are local to 'adder()'. Attempting to access 'n1' outside the function's scope results in a NameError.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Recommended pattern: returning values instead of using 'global'",
            "code": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)",
            "why": "Instead of using 'global', the function takes 'n1' as an argument, modifies it locally, and returns the new value, which is then explicitly reassigned to the variable 'a' in the global scope. This is generally preferred for clarity and avoiding side effects.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "incorrect",
            "title": "Trap: Unintended modification of mutable arguments",
            "code": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')",
            "why": "When 'l1' (a list) is passed to 'adder()' as 'l2', both variables refer to the same list object in memory. The 'l2.pop()' operations modify the original list 'l1', leaving it empty after the function call.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "Preventing mutable argument modification by copying",
            "code": "def adder(l2):\n    l2 = l2[:] # Make a shallow copy of the list\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')",
            "why": "By creating a shallow copy of the input list ('l2 = l2[:]') at the beginning of the function, all subsequent modifications ('l2.pop()') happen only on the copy, preserving the original list 'l1' outside the function.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Assignment to a variable inside a function, without using the 'global' keyword, creates a new local variable that does not affect any global variable of the same name.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Local variable hides global",
                "text": "Assignment inside a function, without 'global', creates a new local variable. The global variable of the same name remains unaffected.",
                "code": "x = 10\ndef modify():\n    x = 20\n    print(x) # Prints 20 (local x)\nmodify()\nprint(x) # Prints 10 (global x unchanged)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "If a variable is assigned to anywhere within a function, Python treats that variable as local throughout the entire function, and attempting to access its value before the assignment will result in an 'UnboundLocalError'.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "UnboundLocalError",
                "text": "If a variable is assigned to anywhere in a function, Python treats it as local throughout. Accessing it before assignment leads to 'UnboundLocalError'.",
                "code": "x = 5\ndef func():\n    print(x) # Causes UnboundLocalError\n    x = 10\nfunc()",
                "table": null
              },
              {
                "id": "kp-2-d2",
                "kind": "explanation",
                "title": "Python's Local Scope Rule",
                "text": "Python determines a variable's scope (local or global) at compile time. If a variable is assigned inside a function, it's local for the entire function, even before the assignment line is executed.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The 'global' keyword must be used inside a function to explicitly indicate that an assignment is intended to modify a global variable, rather than creating a new local one.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Using 'global' keyword",
                "text": "To modify a global variable from inside a function, you must explicitly declare it using the 'global' keyword.",
                "code": "count = 0\ndef increment():\n    global count\n    count += 1\nincrement()\nincrement()\nprint(count) # Prints 2",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Nested functions can access variables from their immediately enclosing, non-global scopes (this is known as a closure).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Closures (Nested Functions)",
                "text": "Nested functions (inner functions) can access variables from their enclosing (outer, non-global) function's scope. This forms a closure.",
                "code": "def outer():\n    x = 10\n    def inner():\n        print(x) # inner() accesses x from outer()'s scope\n    inner()\nouter() # Prints 10",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Function parameters are always local to the function they are defined in.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Function parameters are local",
                "text": "Any parameters passed to a function are treated as local variables within that function's scope and cannot be accessed from outside.",
                "code": "def adder(n1, n2):\n    return n1 + n2\n\nadder(1, 2)\n# print(n1) # NameError: name 'n1' is not defined",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Modifying a mutable object (such as a list) passed as an argument to a function will affect the original object outside the function, as both variables refer to the same object in memory.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Mutable argument side effects",
                "text": "When a mutable object (like a list or dictionary) is passed as an argument, modifications to it inside the function affect the original object outside, as both refer to the same object in memory.",
                "code": "def modify_list(lst_arg):\n    lst_arg.append(4)\n    print(f\"Inside function: {lst_arg}\")\n\nmy_list = [1, 2, 3]\nmodify_list(my_list)\nprint(f\"Outside function: {my_list}\")\n# Output:\n# Inside function: [1, 2, 3, 4]\n# Outside function: [1, 2, 3, 4]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "To prevent unintended external modification of mutable arguments, create a copy of the mutable object inside the function.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Preventing mutable argument modification",
                "text": "To prevent a function from altering the original mutable object passed as an argument, create an explicit copy of the object inside the function.",
                "code": "def modify_list_safe(lst_arg):\n    local_list = list(lst_arg) # Create a copy of the list\n    local_list.append(4)\n    print(f\"Inside function: {local_list}\")\n\nmy_list = [1, 2, 3]\nmodify_list_safe(my_list)\nprint(f\"Outside function: {my_list}\")\n# Output:\n# Inside function: [1, 2, 3, 4]\n# Outside function: [1, 2, 3]",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-f176c9e9e4",
          "exm-a67a786ae7",
          "exm-4ae24a0d6a",
          "exm-aa69b4e771",
          "exm-08341d3aa4",
          "lec-b2f1496ec5",
          "nb-ae24f910b8",
          "nb-4151cecd5a",
          "nb-2b221f0928",
          "nb-a8920b5b9d"
        ]
      }
    },
    {
      "id": "topic-dictionarie-list-ordered-sets-unordered",
      "topic": "Sets",
      "canonical_topic": "sets",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 6,
        "by_exam": {
          "midterm_2023": 2,
          "midterm_2024": 2,
          "extra_practice": 1,
          "trial_midterm": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Dictionaries",
        "Lists vs Dictionaries vs Sets \u2014 ordered/unordered",
        "Sets",
        "dictionaries",
        "lists",
        "lists / sets / duplicates",
        "sets"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' \u2014 this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-c54469d107",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Lists vs Dictionaries vs Sets \u2014 ordered/unordered",
            "explanation": "Lists, tuples, strings are SEQUENCES (ordered). Dicts and sets are NOT sequences (unordered for equality). All are called collections.",
            "code_examples": [
              {
                "description": "Ordering comparison",
                "code": "print([1,2] == [2,1])        # False (ordered)\nprint((1,2) == (2,1))        # False (ordered)\nprint('12' == '21')          # False (ordered)\nprint({1,2} == {2,1})        # True  (unordered)\nprint({1:1,2:2}=={2:2,1:1})  # True  (unordered)"
              }
            ]
          },
          {
            "id": "lec-a3e5177371",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Sets",
            "explanation": "Unordered collection of unique values. Empty set MUST be set() \u2014 {} creates empty dict. Elements must be immutable. No indexing. Methods: .add(), .remove(), .update().",
            "code_examples": [
              {
                "description": "Set operations",
                "code": "countries = set()           # empty set (NOT {})\ncountries = {'Andorra', 'Belgium'}\nprint({1,2,2} == {2,1})     # True (duplicates ignored)\nprint(len({1,2,2}))         # 2\ncountries.remove('Andorra')\ncountries.add('Greece')\ncountries.update({'Spain', 'Italy'})"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-35a84b1549",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 8,
            "week": 2,
            "topic": "sets",
            "question": "What is the output of the following code?\n\ns = {1, 2, 3, 2, 1}\nprint(len(s))",
            "code_context": "",
            "options": {
              "A": "5",
              "B": "3",
              "C": "2",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Sets do not allow duplicates. {1,2,3,2,1} has 3 unique elements."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-989ce43b0f",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 6,
            "week": 2,
            "topic": "lists",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[1, 2, 3, 4]",
              "B": "[1, 2, 3, 4]\n[1, 2, 3, 4]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "lst[:] creates a shallow copy. Modifying lst2 does not affect lst. lst stays [1,2,3], lst2 becomes [1,2,3,4]."
          },
          {
            "id": "exm-925d0ec004",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 1,
            "week": 2,
            "topic": "lists / sets / duplicates",
            "question": "Suppose you have the following function:\n\ndef func1(l1):\n    return len(list(l1))==len(set(l1))\n\nWhich of the functions below returns the same values as the function above, if we call it in any of the following ways?\n\nfunc1(l1 = [1,2,3])\nfunc1(l1 = [1,2,2])\nfunc1(l1 = (1,2,2))",
            "code_context": "",
            "options": {
              "a": "def func1(l1):\n    counter = 0\n    for element in l1:\n        if l1.count(element)>1:\n            counter += 1\n    return (counter == 0)",
              "b": "def func1(l1):\n    counter = []\n    for element in l1:\n        if element in l1[l1.index(element)+1:]:\n            counter.append(element)\n    return (len(counter) == 0)",
              "c": "Neither function returns the same values.",
              "d": "Both functions return the same values."
            },
            "correct": "d",
            "explanation": "Option a: for (1,2,2), tuple has no .count() \u2014 wait, actually tuples DO have .count(). For [1,2,2]: element 2 has count>1 so counter=2, returns False. Original returns False. But for a tuple (1,2,2): tuple has .count(), works. But option b: l1[l1.index(element)+1:] \u2014 tuples support slicing and indexing too. Let's re-examine: for a tuple (1,2,2), both a and b should work the same. Actually option a counts ALL duplicated elements (counts 2 twice for [1,2,2]), making counter=2, so counter==0 is False. Original is False too. Both match. For option b applied to tuple: l1[l1.index(element)+1:] works for tuples too. Actually both a and b return same values as original. Correct: d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Dictionaries store data in `key:value` pairs, offering fast lookups using keys. Keys must be unique and of an immutable type (like strings or numbers), while values can be anything. A crucial concept is that the `in` operator checks for membership in the keys, not the values. Unlike lists, dictionaries are considered unordered; the order of elements does not affect equality comparisons."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How can you get a list of all keys or all values from a dictionary?",
            "What happens if you try to use a list as a dictionary key?",
            "Is `{'a': 1, 'b': 2}` equal to `{'b': 2, 'a': 1}`? Why?",
            "How do you add or update an item in a dictionary?",
            "Does `x in my_dict` check keys, values, or both?",
            "What is the output of `len()` on a dictionary?",
            "What is the result of converting a list with repeated elements to a set?",
            "Does `set('banana')` produce `{'banana'}` or `{'b', 'a', 'n'}`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Dictionary Key Membership Check",
            "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint('b' in d)",
            "why": "The 'in' operator correctly checks for the presence of 'b' as a key in the dictionary, which evaluates to True.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Dictionary Value Membership Check with 'in'",
            "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint(1 in d)",
            "why": "The 'in' operator checks only for keys in a dictionary. Since '1' is a value and not a key, the expression evaluates to False.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Adding and Updating Dictionary Items",
            "code": "d = {'a': 1, 'b': 2}\nd['c'] = 3\nd['a'] = 10\nprint(d)",
            "why": "Assigning a value to a new key adds it to the dictionary; assigning to an existing key updates its value.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Deleting Dictionary Items",
            "code": "d = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "why": "The `del` statement removes the key-value pair associated with the specified key ('y').",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Getting Dictionary Length",
            "code": "d = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "why": "`len()` returns the total number of key-value pairs (items) in the dictionary.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Set Uniqueness and Length",
            "code": "s = {1, 2, 3, 2, 1}\nprint(len(s))",
            "why": "Sets automatically eliminate duplicate elements. The resulting set `{1, 2, 3}` has a length of 3.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Creating Empty Set vs. Empty Dictionary",
            "code": "empty_set = set()\nempty_dict = {}\nprint(f\"Empty set type: {type(empty_set)}\")\nprint(f\"Empty dict type: {type(empty_dict)}\")",
            "why": "`set()` is used to create an empty set, whereas `{}` creates an empty dictionary by default.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "incorrect",
            "title": "Using Mutable Object as Dictionary Key",
            "code": "a = 1\nb = {1:1} # A dictionary is a mutable object\ntry:\n    my_dict = {b:a}\nexcept TypeError as e:\n    print(e)",
            "why": "Dictionary keys must be immutable (hashable). Attempting to use a mutable object like another dictionary as a key raises a `TypeError`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Dictionary Equality (Order-Insensitive)",
            "code": "d1 = {1:1, 2:2}\nd2 = {2:2, 1:1}\nprint(d1 == d2)",
            "why": "Dictionaries compare as equal if they contain the same key-value pairs, irrespective of the order of definition.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "List Equality (Order-Sensitive)",
            "code": "l1 = [1, 2]\nl2 = [2, 1]\nprint(l1 == l2)",
            "why": "Lists are ordered sequences; their equality comparison considers both elements and their order.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "Checking for Duplicates using Sets",
            "code": "def has_duplicates(items):\n    return len(items) != len(set(items))\n\nprint(has_duplicates([1, 2, 3]))\nprint(has_duplicates([1, 2, 2]))",
            "why": "Converting a collection to a set removes duplicates. If the length of the set is less than the original collection, duplicates were present.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "correct",
            "title": "Creating a Dictionary from Zipped Lists",
            "code": "keys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nmy_dict = dict(zip(keys, values))\nprint(my_dict)",
            "why": "`zip()` pairs corresponding elements from `keys` and `values` lists, and `dict()` converts these pairs into key-value entries.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Basic Set Operations",
            "code": "my_set = {'apple', 'banana'}\nmy_set.add('orange')\nmy_set.remove('banana')\nmy_set.update({'grape', 'kiwi'})\nprint(my_set)",
            "why": "Demonstrates adding a single element with `.add()`, removing an existing element with `.remove()`, and adding multiple elements from an iterable with `.update()`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Dictionaries are collections that store data as unordered key-value pairs.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Dictionary Creation & Access",
                "text": "",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "explanation",
                "title": "Empty Dictionaries",
                "text": "An empty dictionary can be created using curly braces or the dict() constructor.",
                "code": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Dictionary keys must be unique and immutable (hashable).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Immutable Keys",
                "text": "Dictionary keys must be hashable. Immutable types (numbers, strings, tuples) work as keys. Mutable types (lists, other dictionaries) cannot be used as keys.",
                "code": "a = 1\nb = {1:1}\nprint({a:b}) # Works: 1 is immutable\ntry:\n    print({b:a}) # Fails: b is a dict (mutable)\nexcept Exception as e:\n    print(e)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The 'in' operator checks for key existence in a dictionary, not value existence.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "'in' Operator Checks Keys",
                "text": "",
                "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint('a' in d) # True\nprint(1 in d)  # False (1 is a value, not a key)\nprint('d' in d) # False",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Items can be added or updated in a dictionary using direct assignment (`dict[key] = value`) or the `.update()` method.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Add/Update with Assignment",
                "text": "",
                "code": "capitals = {'Belgium': 'Brussels'}\ncapitals['Netherlands'] = 'Amsterdam' # Add new key-value\ncapitals['Belgium'] = 'BXL' # Update existing key's value\nprint(capitals)",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Add/Update with .update()",
                "text": "",
                "code": "squares = {1:1, 2:4}\nsquares.update({3:9, 4:16}) # Add multiple new pairs\nsquares.update({2:5, 1:1}) # Update existing, add new if not present\nprint(squares)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "The `del` statement removes a key-value pair from a dictionary using its key.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "`del` Statement",
                "text": "",
                "code": "d = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`len(dict)` returns the number of key-value pairs in a dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Getting Dictionary Size",
                "text": "",
                "code": "d = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Dictionaries are unordered for equality comparison, meaning the order of key-value pairs does not affect their equality.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Unordered Equality",
                "text": "",
                "code": "d1 = {1:1, 2:2}\nd2 = {2:2, 1:1}\nprint(d1 == d2)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "The methods `.keys()`, `.values()`, and `.items()` return dynamic views of a dictionary's keys, values, and key-value tuples, respectively.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "Dictionary Views",
                "text": "",
                "code": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels'}\nprint(list(capitals.keys()))   # ['Estonia', 'Belgium']\nprint(list(capitals.values())) # ['Tallinn', 'Brussels']\nprint(list(capitals.items()))  # [('Estonia', 'Tallinn'), ('Belgium', 'Brussels')]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "Sets are unordered collections that store only unique, immutable values.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "explanation",
                "title": "Unique, Immutable Elements",
                "text": "Sets store only unique values, and elements must be immutable (hashable).",
                "code": "s = {1, 2, 3, 2, 1}\nprint(s) # Output: {1, 2, 3}",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Sets automatically eliminate duplicate elements upon creation or addition.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "example",
                "title": "Duplicate Elimination",
                "text": "",
                "code": "s = {1, 2, 3, 2, 1}\nprint(len(s)) # Length is 3 due to duplicates being removed",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "To create an empty set, `set()` must be used; empty curly braces `{}` create an empty dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "example",
                "title": "Empty Set vs. Empty Dict",
                "text": "",
                "code": "empty_set = set()      # Correct way to create an empty set\nempty_dict = {}        # Creates an empty dictionary, NOT a set\nprint(type(empty_set))\nprint(type(empty_dict))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "Set elements cannot be accessed by index because sets are unordered.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "explanation",
                "title": "No Indexing for Sets",
                "text": "Since sets are unordered, individual elements cannot be accessed using an index or slicing.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "Common set methods include `.add()`, `.remove()`, and `.update()` for modifying set contents.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "example",
                "title": "Set Modification Methods",
                "text": "",
                "code": "countries = {'Andorra', 'Belgium'}\ncountries.add('Greece')          # Add a single element\ncountries.remove('Andorra')      # Remove an element\ncountries.update({'Spain', 'Italy'}) # Add multiple elements\nprint(countries)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "Lists, tuples, and strings are ordered sequences, meaning the order of their elements is significant for equality comparisons.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "example",
                "title": "Ordered Sequence Comparison",
                "text": "",
                "code": "print([1,2] == [2,1])  # False (order matters for lists)\nprint((1,2) == (2,1))  # False (order matters for tuples)\nprint('12' == '21')    # False (order matters for strings)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "Converting a list or tuple to a set and comparing its length to the original is an efficient way to check for duplicate elements.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "explanation",
                "title": "Check for Duplicates with Sets",
                "text": "Converting a sequence to a set removes duplicates. Comparing its length to the original can detect duplicates.",
                "code": "my_list_with_dupes = [1, 2, 2, 3]\nmy_list_no_dupes = [1, 2, 3]\n\ndef has_duplicates(l):\n    return len(l) != len(set(l))\n\nprint(has_duplicates(my_list_with_dupes)) # True\nprint(has_duplicates(my_list_no_dupes))  # False",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-35a84b1549",
          "exm-3555baf8ba",
          "exm-4cee2500a8",
          "exm-925d0ec004",
          "lec-c54469d107",
          "lec-a3e5177371",
          "lec-27dc11e221",
          "nb-24dbf7c985",
          "nb-59478a0652"
        ]
      }
    },
    {
      "id": "topic-args-star",
      "topic": "*args",
      "canonical_topic": "*arg",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 5,
        "coverage_count": 4,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 2
        }
      },
      "related_topics": [
        "*args",
        "*args / **kwargs",
        "*args / function design",
        "*args / passing to function",
        "Keyword arguments and **kwargs",
        "Methods vs functions",
        "args_star",
        "fun_example",
        "keyword args / **kwargs",
        "*args \u2014 undefined number of positional arguments"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-521c0f3bef",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Keyword arguments and **kwargs",
            "explanation": "Arguments can be passed by name (keyword). **kwargs collects undefined keyword arguments into a dict. Order in function definition: positional, *args, keyword-with-defaults, **kwargs.",
            "code_examples": [
              {
                "description": "Keyword arguments",
                "code": "def calc(first, second, third, fourth, fifth, sixth):\n    return first + 2*second + 3*third + 4*fourth + 5*fifth + 6*sixth\nprint(calc(fifth=2, third=4, fourth=1, sixth=5, second=2, first=3))  # 63"
              },
              {
                "description": "**kwargs",
                "code": "def calc(**kwargs):\n    return kwargs['first'] + 2*kwargs['second'] + 3*kwargs['third']\nprint(calc(third=4, second=2, first=3))"
              },
              {
                "description": "Mixed: positional + *args + **kwargs",
                "code": "def calc(first, second, *args, **kwargs):\n    return first + second*2 + args[0]*3 + args[1]*4 + 5*kwargs['fifth'] + 6*kwargs['sixth']\nprint(calc(3, 2, 4, 1, sixth=5, fifth=2))  # 63"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings \u2014 you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable \u2014 must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT \u2014 captures new string\ns1.upper()       # WRONG \u2014 result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable \u2014 changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          },
          {
            "id": "lec-db6665e15a",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "*args \u2014 undefined number of positional arguments",
            "explanation": "Prefixing a parameter with * makes Python collect all extra positional arguments into a tuple named args. Can mix with defined parameters: def f(n1, n2, *args) \u2014 Python fills n1,n2 first then collects remainder into args.",
            "code_examples": [
              {
                "description": "*args usage",
                "code": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
              },
              {
                "description": "Mix defined and *args",
                "code": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-16556959b9",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 9,
            "week": 3,
            "topic": "*args / passing to function",
            "question": "Assume sum_even_in_list(l1) filters non-integers and sums even integers.\n\nYou want sum_even_integers that accepts a flexible number of arguments.\n\nFor example: sum_even_integers(1,'2', 3.0, 4) should return 4.\n\nWhich of the following function definitions will work as intended?",
            "code_context": "",
            "options": {
              "a": "def sum_even_integers(*args):\n\treturn sum_even_in_list(args)",
              "b": "def sum_even_integers(*args):\n\treturn sum([x for x in args if type(x) == int and x%2 == 0])",
              "c": "def sum_even_integers(*args):\n\tresult = 0\n\tfor x in args:\n\t\tif type(x) == int and x%2 == 0:\n\t\t\tresult += x\n\treturn result",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: *args creates a tuple, sum_even_in_list accepts any iterable so passing a tuple works. b: list comprehension on tuple works fine. c: direct iteration over tuple works. All three produce the same result. Correct: d."
          },
          {
            "id": "exm-fda16bbeb3",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 14,
            "week": 3,
            "topic": "*args / **kwargs",
            "question": "What is the output of the following code?\n\ndef func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\n\nfunc(1, 2, 3, 4, x=5, y=6)",
            "code_context": "",
            "options": {
              "A": "1 2 (3, 4) {'x': 5, 'y': 6}",
              "B": "1 2 [3, 4] {'x': 5, 'y': 6}",
              "C": "1 2 3 4 5 6",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "a=1, b=2, args=(3,4) as tuple, kwargs={'x':5,'y':6} as dict."
          },
          {
            "id": "exm-1e574c41d3",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 17,
            "week": 3,
            "topic": "*args",
            "question": "What is the output of the following code?\n\ndef func(*args):\n    print(type(args))\n\nfunc(1, 2, 3)",
            "code_context": "",
            "options": {
              "A": "<class 'list'>",
              "B": "<class 'tuple'>",
              "C": "<class 'dict'>",
              "D": "<class 'set'>"
            },
            "correct": "B",
            "explanation": "*args collects positional arguments as a tuple."
          },
          {
            "id": "exm-b0d0a64cde",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 14,
            "week": 3,
            "topic": "*args",
            "question": "What is the output of the following code?\n\ndef func(*args):\n    return sum(args)\n\nprint(func(1, 2, 3, 4, 5))",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "(1, 2, 3, 4, 5)",
              "C": "[1, 2, 3, 4, 5]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "*args collects all positional arguments as a tuple. sum((1,2,3,4,5)) = 15."
          },
          {
            "id": "exm-11949e2fb1",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 22,
            "week": 3,
            "topic": "keyword args / **kwargs",
            "question": "What is the output of the following code?\n\ndef greet(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\ngreet(name='Alice', age=30)",
            "code_context": "",
            "options": {
              "A": "name: Alice\nage: 30",
              "B": "Alice: name\n30: age",
              "C": "{'name': 'Alice', 'age': 30}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "**kwargs collects keyword arguments as a dict. Iterating items() gives key-value pairs: name: Alice, age: 30."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-181e9ccd25",
            "week": 3,
            "cell_index": 38,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "outputs": []
          },
          {
            "id": "nb-a5fa1fde61",
            "week": 3,
            "cell_index": 39,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(l1):\n    result = 0\n    for number in l1:\n        result += number  \n    return result\nprint(adder([1, 2, 3, 4, 5]))",
            "outputs": []
          },
          {
            "id": "nb-3e6522622c",
            "week": 3,
            "cell_index": 40,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "`*args` collects extra positional arguments into a tuple, and `**kwargs` collects extra keyword arguments into a dictionary. In exam questions, bind required positional parameters first, then track where remaining positional values and named values are collected. This makes function signatures flexible but easy to misread when calls mix styles."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What happens if you call a function that accepts `**kwargs` with no keyword arguments?",
            "Can a function have both regular parameters and `*args`? What is the correct order?",
            "What is the correct parameter order for `a`, `*args`, `b=1`, and `**kwargs`?",
            "What happens if you call a function with `*args` with no extra arguments?",
            "How can you loop through all the key-value pairs passed via `**kwargs`?",
            "Is the name `args` required, or can you use another name like `*nums`?",
            "How can you use `**` to unpack a dictionary when calling a function?",
            "What is the data type of the `kwargs` variable inside the function?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic `*args` usage to sum numbers",
            "code": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "why": "The `*args` parameter collects all positional arguments (1, 2, 3, 4, 5) into a tuple, which is then iterated to calculate their sum.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Identifying the type of `*args`",
            "code": "def func(*args):\n    print(type(args))\nfunc(1, 2, 3)",
            "why": "This demonstrates that arguments collected by `*args` are always stored as a tuple inside the function.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Mixing `*args` with defined positional arguments",
            "code": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "why": "The first two positional arguments (1 and 2) are assigned to `n1` and `n2`, respectively, while the remaining positional arguments (3, 4, 5) are collected into the `args` tuple.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Combined usage of fixed arguments, `*args`, and `**kwargs`",
            "code": "def func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\nfunc(1, 2, 3, 4, x=5, y=6)",
            "why": "This shows how positional arguments `1` and `2` are assigned to `a` and `b`, `3` and `4` are collected into the `args` tuple, and keyword arguments `x=5` and `y=6` are collected into the `kwargs` dictionary.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Processing `*args` tuple using a list comprehension",
            "code": "def sum_even_integers(*args):\n    # *args collects arguments into a tuple.\n    # This demonstrates processing the collected arguments using a list comprehension.\n    return sum([x for x in args if isinstance(x, int) and x % 2 == 0])\nprint(sum_even_integers(1, '2', 3.0, 4))",
            "why": "The `args` tuple is processed to filter for integers and then sum only the even ones, demonstrating tuple iteration via list comprehension.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Processing `*args` tuple using a direct for loop",
            "code": "def sum_even_integers(*args):\n    # *args collects arguments into a tuple.\n    # This demonstrates processing the collected arguments using a for loop.\n    result = 0\n    for x in args:\n        if isinstance(x, int) and x % 2 == 0:\n            result += x\n    return result\nprint(sum_even_integers(1, '2', 3.0, 4))",
            "why": "The `args` tuple is directly iterated over in a for loop to filter for integers and sum only the even ones, showcasing manual iteration of the collected arguments.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The `*args` parameter collects all extra positional arguments passed to a function into a tuple.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Type of *args",
                "text": "`*args` collects arguments into a tuple, allowing functions to accept a variable number of positional arguments.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "example",
                "title": "Using *args to sum numbers",
                "text": "",
                "code": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`*args` can be combined with explicitly defined positional parameters, which are filled first, and the remaining positional arguments are collected by `*args`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Mixing positional arguments and *args",
                "text": "",
                "code": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))",
                "table": null
              },
              {
                "id": "kp-2-d2",
                "kind": "explanation",
                "title": "Order of argument processing",
                "text": "When `*args` is combined with explicit parameters, Python first fills the explicit parameters in order, then collects any remaining positional arguments into the `*args` tuple.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The correct order for function parameters is positional arguments, followed by `*args`, then keyword-only arguments with defaults, and finally `**kwargs`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "table",
                "title": "Parameter order template",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Segment",
                    "Example"
                  ],
                  "rows": [
                    [
                      "Positional params",
                      "def f(a, b, ...)"
                    ],
                    [
                      "*args",
                      "def f(a, b, *args, ...)"
                    ],
                    [
                      "Keyword-only params",
                      "def f(a, *args, c=0, ...)"
                    ],
                    [
                      "**kwargs",
                      "def f(a, *args, c=0, **kwargs)"
                    ]
                  ]
                }
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Valid signature and call",
                "text": "",
                "code": "def f(a, b, *args, c=0, **kwargs):\n    return a, b, args, c, kwargs\n\nprint(f(1, 2, 3, 4, c=5, x=6))\n# (1, 2, (3, 4), 5, {'x': 6})",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "The `**kwargs` parameter collects all extra keyword arguments passed to a function into a dictionary.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Collecting Keyword Arguments with **kwargs",
                "text": "The `**kwargs` parameter collects all extra keyword arguments passed to a function into a dictionary, where keys are argument names and values are their corresponding argument values.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Using **kwargs",
                "text": "",
                "code": "def greet(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\ngreet(name='Alice', age=30)",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-fda16bbeb3",
          "exm-1e574c41d3",
          "exm-16556959b9",
          "exm-11949e2fb1",
          "exm-b0d0a64cde",
          "lec-521c0f3bef",
          "nb-3e6522622c",
          "lec-db6665e15a",
          "lec-8bc2ca06f4",
          "nb-711110ef0a"
        ]
      }
    },
    {
      "id": "topic-slicing",
      "topic": "Slicing",
      "canonical_topic": "slicing",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 5,
        "by_exam": {
          "trial_midterm": 2,
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Slicing",
        "Slicing / mutability",
        "Slicing negative step",
        "indexing / slicing",
        "slicing",
        "slicing / negative step",
        "slicing / negative_step",
        "slicing / strings",
        "strings"
      ],
      "trap_patterns": [
        {
          "pattern": "Negative slicing with step=-2",
          "trap": "l[::-2] starts from last element going backwards with step 2. l[::2][::-1] first takes every other starting from 0, then reverses \u2014 different result",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "extra_practice"
          ]
        },
        {
          "pattern": "range() and slicing both exclusive at stop",
          "trap": "range(1,10,3)\u2192[1,4,7] not including 10; l[2:7] goes up to but not including index 7",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        },
        {
          "pattern": "Slicing creates a NEW object",
          "trap": "l2=l1 vs l2=l1[:] \u2014 l2=l1 shares the SAME object, slicing creates independent copy",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023",
            "midterm_2024",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8b4915c558",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing",
            "explanation": "Syntax: seq[start:end:step]. Start is inclusive, end is NOT inclusive. Defaults: start=0, end=len, step=1. Negative step goes from right to left. Slicing always creates a NEW object of the same type.",
            "code_examples": [
              {
                "description": "Basic slicing examples",
                "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[7])       # 8\nprint(l1[-1])      # 8\nprint(l1[-5:5])    # [4, 5]\nprint(l1[:-5])     # [1, 2, 3]"
              },
              {
                "description": "Negative step",
                "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[5:1:-2])  # [6, 4]\nprint(l1[5::-1])   # [6, 5, 4, 3, 2, 1]\nprint(l1[:1:-1])   # [8, 7, 6, 5, 4, 3]\nprint(l1[1:5:-2])  # [] (already past end)"
              },
              {
                "description": "Slice reversal",
                "code": "l1 = [1, 2, 3, 4]\nprint(l1[::-1])    # [4, 3, 2, 1]"
              },
              {
                "description": "Slicing creates new object \u2014 key exam trap",
                "code": "l1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)  # True False (l3 is independent copy)"
              },
              {
                "description": "Changing a list slice vs index",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nl1[1:2] = [1, 1]      # replaces element at index 1 with two elements\nprint(l1)             # [1, 1, 1, 3, 4, 5, 6]\n\nl1 = [1, 2, 3, 4, 5, 6]\nl1[1] = [1, 1]        # replaces element at index 1 with a list\nprint(l1)             # [1, [1, 1], 3, 4, 5, 6]"
              },
              {
                "description": "Slicing strings and tuples",
                "code": "t1 = (1, 2, 3)\nprint(t1[1:])          # (2, 3)\ns1 = 'uva Amsterdam'\nprint(s1[5:-3:2])      # 'mtr'"
              },
              {
                "description": "Changing string/tuple (must create new object)",
                "code": "s1 = 'uva Amsterdam'\n# s1[6] = 's'  # ERROR\ns1 = s1[:6] + 's' + s1[7:]\nprint(s1)  # works\n\nt1 = (1, 4, 3)\n# t1[1] = 2  # ERROR\nt1 = t1[:1] + (2,) + t1[2:]\nprint(t1)  # works"
              }
            ]
          },
          {
            "id": "leq-d9ed64b435",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing / mutability",
            "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)",
            "options": {},
            "correct": null,
            "explanation": ""
          },
          {
            "id": "leq-eb2d6e90d2",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing negative step",
            "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nprint(l1[::-1])",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [
          {
            "id": "exm-1b0f40ae76",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 1,
            "week": 1,
            "topic": "indexing / slicing",
            "question": "What is the output of the following code?\n\nx = 'Hello, World!'\nprint(x[-6:-1])",
            "code_context": "",
            "options": {
              "A": "World",
              "B": "orld!",
              "C": "World!",
              "D": "orld"
            },
            "correct": "A",
            "explanation": "x[-6:-1] starts 6 from the end ('W') and goes to 1 from the end (exclusive of '!'). That gives 'World'."
          },
          {
            "id": "exm-1c9f7b4c79",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 4,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\nx = [0, 1, 2, 3, 4, 5]\nprint(x[1:5:2])",
            "code_context": "",
            "options": {
              "A": "[1, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[0, 2, 4]",
              "D": "[1, 2]"
            },
            "correct": "A",
            "explanation": "x[1:5:2] starts at index 1, stops before index 5, step 2. Gives elements at indices 1 and 3: [1, 3]."
          },
          {
            "id": "exm-90abd89ecf",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 3,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\ns = 'abcdef'\nprint(s[2:5])",
            "code_context": "",
            "options": {
              "A": "bcd",
              "B": "cde",
              "C": "cdef",
              "D": "bcde"
            },
            "correct": "B",
            "explanation": "s[2:5] gives characters at indices 2,3,4: 'c','d','e' = 'cde'."
          },
          {
            "id": "exm-d71c297b9e",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 2,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[::2])",
            "code_context": "",
            "options": {
              "A": "[10, 30, 50]",
              "B": "[20, 40]",
              "C": "[10, 20, 30, 40, 50]",
              "D": "[50, 30, 10]"
            },
            "correct": "A",
            "explanation": "lst[::2] takes every other element starting from index 0: [10, 30, 50]."
          },
          {
            "id": "exm-451a3ff1d3",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 6,
            "week": 1,
            "topic": "slicing / negative step",
            "question": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nWhich of the following lines of code will NOT create a list with the name subset, and the value [10, 8, 6, 4, 2]?",
            "code_context": "",
            "options": {
              "a": "subset = numbers[-1::-2]",
              "b": "subset = numbers[::-2]",
              "c": "subset = numbers[::-1][::2]",
              "d": "subset = numbers[::2][::-1]"
            },
            "correct": "d",
            "explanation": "a: starts at -1 (10), step -2: [10,8,6,4,2]. Correct. b: [::-2] starts at last (10), step -2: [10,8,6,4,2]. Correct. c: [::-1] reverses to [10,9,8,7,6,5,4,3,2,1], then [::2] takes every 2nd: [10,8,6,4,2]. Correct. d: [::2] gives [1,3,5,7,9], then [::-1] reverses: [9,7,5,3,1]. This does NOT give [10,8,6,4,2]. Correct answer (the one that does NOT work): d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-3f9cf37bbb",
            "week": 1,
            "cell_index": 62,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6:5])\nprint(l1[6:6])\nprint(l1[6:7])\nprint(l1[6:7] == l1[6])\nprint(l1[6:7][0] == l1[6])\nprint(l1[6:7] == list(l1[6]))",
            "outputs": []
          },
          {
            "id": "nb-1a515da900",
            "week": 1,
            "cell_index": 63,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[1:17])\nprint(l1[16:17])\nprint(l1[:6])\nprint(l1[6:])\nprint(l1[:6] + l1[6:] == l1)\nprint(l1[:] == l1)\nprint(l1[:] is l1)",
            "outputs": []
          },
          {
            "id": "nb-be3698c98e",
            "week": 1,
            "cell_index": 64,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[0:6:2])\nprint(l1[1:6:1] == l1[1:6])\nprint(l1[1:6:1] == l1[1:6:])\nprint(l1[0:6:2] == l1[:6:2])\nprint(l1[2:len(l1):2] == l1[2::2])\nprint(l1[0:len(l1):1] == l1[::])",
            "outputs": []
          },
          {
            "id": "nb-15c3c8bffd",
            "week": 1,
            "cell_index": 65,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['a', 'b']\nl2 = l1\nl2[-1] = 'c'\nprint(l1 == l3)\nl3 = l1[::]\nl3[-1] = 'c'\nprint(l1 == l3)",
            "outputs": []
          },
          {
            "id": "nb-9ccea86971",
            "week": 1,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "strings",
            "source": "print(\"This is a string\")\nprint('This is another string')",
            "outputs": []
          },
          {
            "id": "nb-fac92dad98",
            "week": 1,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"",
            "outputs": []
          },
          {
            "id": "nb-2dd9891d55",
            "week": 1,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a,b)",
            "outputs": []
          },
          {
            "id": "nb-046b3572aa",
            "week": 1,
            "cell_index": 83,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Slicing extracts a portion of a sequence like a list or string using the `[start:stop:step]` syntax. The `start` index is inclusive, while the `stop` index is exclusive. Pay close attention to the direction when the `step` is negative, as it reverses traversal from right to left. Remember that slicing always produces a new object, which is a key distinction from direct assignment (`l2 = l1` vs. `l2 = l1[:]`)."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the result of a slice where the start index is greater than the stop index with a positive step?",
            "Explain the difference between a shallow copy `[:]` and a direct assignment `=`.",
            "What happens if you use a negative step, like `my_list[5:1:-1]`?",
            "How do you reverse a string using slicing?",
            "What is the output of `my_list[1:5]`?",
            "What does `my_list[::2]` do?",
            "How do you get the last three elements of a list in their original order vs reverse order?",
            "What are the default `start` and `stop` values when the step is negative?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic String Slicing",
            "code": "s = 'abcdef'\nprint(s[2:5])",
            "why": "The slice `s[2:5]` extracts characters from index 2 up to (but not including) index 5, resulting in 'cde'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Negative Indexing in String Slicing",
            "code": "x = 'Hello, World!'\nprint(x[-6:-1])",
            "why": "The slice `x[-6:-1]` starts 6 characters from the end ('W') and goes up to (but not including) the last character ('!'), yielding 'World'.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "List Slicing with Start, End, and Step",
            "code": "x = [0, 1, 2, 3, 4, 5]\nprint(x[1:5:2])",
            "why": "The slice `x[1:5:2]` starts at index 1, goes up to (but not including) index 5, taking every second element. This results in elements at indices 1 and 3: `[1, 3]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "List Slicing with Default Start and End, Custom Step",
            "code": "lst = [10, 20, 30, 40, 50]\nprint(lst[::2])",
            "why": "The slice `lst[::2]` uses default start (0) and end (length of list) and takes every second element, producing `[10, 30, 50]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Full List Reversal using Negative Step",
            "code": "l1 = [1, 2, 3, 4]\nprint(l1[::-1])",
            "why": "A step of `-1` without specified start or end reverses the entire list, resulting in `[4, 3, 2, 1]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Negative Step with Explicit Start and End",
            "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[5:1:-2])",
            "why": "The slice `l1[5:1:-2]` starts at index 5 (value 6), moves towards index 1 (exclusive) with a step of -2. This selects elements at index 5 and 3, yielding `[6, 4]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Empty Slice When Start >= End (Positive Step)",
            "code": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6:5])",
            "why": "When the `start` index (6) is greater than the `end` index (5) and the step is positive, the slice results in an empty list `[]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Slicing Beyond Bounds",
            "code": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[1:17])",
            "why": "Slicing beyond the actual length of the sequence does not raise an error; the end index is clipped to the sequence's length. Here, it slices from index 1 to the end, resulting in `['B', 'C', 'D', 'E', 'F', 'G', 'H']`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Slicing Creates a New Object vs. Reference Copy",
            "code": "l1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)",
            "why": "`l2 = l1` creates a reference, so `l2` points to the same list as `l1`. `l3 = l1[:]` creates a new shallow copy. When `l1[-1]` is changed, `l2` reflects this change, but `l3` remains the original copy. Thus, `l1 == l2` is `True`, but `l2 == l3` is `False`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Checking Object Identity of Sliced Copy",
            "code": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[:] is l1)",
            "why": "The `is` operator checks if two variables refer to the exact same object in memory. `l1[:]` creates a new object (a copy), so it is not the same object as `l1`, hence `False`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "List Slice Assignment (Replacing Elements)",
            "code": "l1 = [1, 2, 3, 4, 5, 6]\nl1[1:2] = [10, 11] # replaces element at index 1 with two new elements\nprint(l1)",
            "why": "Assigning to a slice `l1[1:2]` replaces the element at index 1 with the elements `[10, 11]`, expanding the list to `[1, 10, 11, 3, 4, 5, 6]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "correct",
            "title": "List Index Assignment (Replacing with an Object)",
            "code": "l1 = [1, 2, 3, 4, 5, 6]\nl1[1] = [10, 11] # replaces element at index 1 with a list\nprint(l1)",
            "why": "Assigning to a single index `l1[1]` replaces the element at that position with the entire assigned object (`[10, 11]`), resulting in `[1, [10, 11], 3, 4, 5, 6]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Modifying Immutable Strings via Slicing (Creating New String)",
            "code": "s1 = 'uva Amsterdam'\n# s1[6] = 's' # This line would cause an error: 'str' object does not support item assignment\ns1 = s1[:6] + 's' + s1[7:]\nprint(s1)",
            "why": "Strings are immutable; direct assignment to an index (`s1[6] = 's'`) is not allowed. To 'change' a string, new string objects must be created by concatenating slices of the original string and the new character, resulting in `'uva AmSteram'`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-14",
            "kind": "correct",
            "title": "Achieving Reversed Even Numbers from End",
            "code": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nsubset = numbers[-1::-2]\nprint(subset)",
            "why": "The slice `numbers[-1::-2]` starts from the last element (index -1, value 10) and proceeds backwards with a step of -2, selecting `[10, 8, 6, 4, 2]`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-15",
            "kind": "incorrect",
            "title": "Incorrect Method for Reversed Even Numbers from End",
            "code": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nsubset = numbers[::2][::-1]\nprint(subset)",
            "why": "This expression first performs `numbers[::2]`, which selects elements at even indices `[1, 3, 5, 7, 9]`. Then, `[::-1]` reverses this *intermediate* list to `[9, 7, 5, 3, 1]`, which is not the desired `[10, 8, 6, 4, 2]`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Slicing in Python uses the syntax `sequence[start:end:step]`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Basic Slicing Syntax",
                "text": "Slicing uses `sequence[start:end:step]`. All parts are optional.",
                "code": "my_list = [0, 1, 2, 3, 4, 5]\nprint(my_list[1:5:2]) # Output: [1, 3]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "The `start` index is inclusive, and the `end` index is exclusive in slicing.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Inclusive Start, Exclusive End",
                "text": "The `start` index is included in the slice, but the `end` index is not. The slice goes up to, but does not include, the element at `end`.",
                "code": "s = 'abcdef'\nprint(s[2:5]) # Output: 'cde' (elements at indices 2, 3, 4)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Default values for slicing are `start=0`, `end=len(sequence)`, and `step=1`; any can be omitted.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Omitting Start/End for Full Copy",
                "text": "When `start` and `end` are omitted, and `step` is default (1), the entire sequence is copied.",
                "code": "my_list = [10, 20, 30]\nprint(my_list[::]) # Output: [10, 20, 30]",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Omitting Start/End with Custom Step",
                "text": "You can use a custom `step` while omitting `start` and `end` to process the entire sequence with that step.",
                "code": "lst = [10, 20, 30, 40, 50]\nprint(lst[::2]) # Output: [10, 30, 50]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "A negative `step` value reverses the direction of slicing, moving from right to left.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Reversing with Negative Step",
                "text": "A negative `step` reverses the order of elements in the slice. `[::-1]` is a common idiom to reverse a sequence entirely.",
                "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[::-1]) # Output: [8, 7, 6, 5, 4, 3, 2, 1]\nprint(l1[5:1:-2]) # Output: [6, 4]",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Negative Indices",
                "text": "Negative indices count from the end of the sequence (-1 is the last element, -2 is the second to last, etc.). They can be used for `start` or `end`.",
                "code": "x = 'Hello, World!'\nprint(x[-6:-1]) # Output: 'World'",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Slicing always creates a new object (a shallow copy) of the same type as the original sequence.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Slicing Creates a New Object",
                "text": "Slicing always returns a *new* object, which is a shallow copy of the specified portion of the original sequence. It is not a view into the original.",
                "code": "original_list = [1, 2, 3]\nnew_slice = original_list[::]\nprint(original_list is new_slice) # Output: False\nnew_slice.append(4)\nprint(original_list) # Output: [1, 2, 3]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Strings and tuples are immutable, so operations appearing to 'change' them via slicing actually result in new string or tuple objects.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Slicing on Strings",
                "text": "Slicing operations on strings (or tuples) always produce a *new* string (or tuple) object. The original object remains unchanged.",
                "code": "s = 'hello'\ns_slice = s[1:4]\nprint(s_slice) # Output: 'ell'\nprint(s is s_slice) # Output: False (distinct objects)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Assigning to a slice (e.g., `list[start:end] = new_elements`) replaces elements within that range, potentially changing the list's length.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "Assignment to a Slice",
                "text": "Assigning an iterable to a slice replaces the elements within that range. If the assigned iterable has a different length than the slice it's replacing, the list's total length will adjust accordingly.",
                "code": "my_list = [1, 2, 3, 4, 5]\nmy_list[1:3] = [10, 11, 12] # Replaces [2, 3] with [10, 11, 12]\nprint(my_list) # Output: [1, 10, 11, 12, 4, 5]\n\nmy_list = ['a', 'b', 'c']\nmy_list[1:] = [] # Removes elements from index 1 to end\nprint(my_list) # Output: ['a']",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Slicing indices that extend beyond the sequence's actual bounds do not raise an error but are automatically adjusted to the sequence's limits.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "Slicing Beyond Bounds",
                "text": "Python does not raise an `IndexError` if slice indices extend beyond the sequence's actual length. Out-of-bounds indices are simply adjusted to the sequence's limits.",
                "code": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[1:17]) # Output: ['B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[:100]) # Output: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "If `start` is greater than or equal to `end` (with a positive `step`), the slice will be empty.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "explanation",
                "title": "Empty Slices from Invalid Ranges",
                "text": "If `start` is greater than or equal to `end` (with a positive `step`), or if the `step` moves past the `end` index without encountering elements, the resulting slice will be empty.",
                "code": "my_list = [1, 2, 3, 4]\nprint(my_list[3:1]) # Output: []\nprint(my_list[2:2]) # Output: []",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Different combinations of negative step slicing can yield different results (e.g., `seq[::-2]` vs `seq[::2][::-1]`).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "example",
                "title": "Complex Negative Step Slicing",
                "text": "Combining slices, especially with negative steps, can lead to different results depending on the order of operations. Understand what each slicing operation does independently.",
                "code": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# All three produce [10, 8, 6, 4, 2]\nsubset_a = numbers[-1::-2]\nsubset_b = numbers[::-2]\nsubset_c = numbers[::-1][::2]\n\n# This produces [9, 7, 5, 3, 1]\nsubset_d = numbers[::2][::-1]\n\nprint(f\"A: {subset_a}\") # A: [10, 8, 6, 4, 2]\nprint(f\"D: {subset_d}\") # D: [9, 7, 5, 3, 1]",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-451a3ff1d3",
          "exm-1c9f7b4c79",
          "exm-d71c297b9e",
          "exm-90abd89ecf",
          "exm-1b0f40ae76",
          "lec-8b4915c558",
          "nb-3f9cf37bbb",
          "nb-15c3c8bffd",
          "nb-1a515da900",
          "leq-eb2d6e90d2"
        ]
      }
    },
    {
      "id": "topic-condition-falsy-truthy",
      "topic": "Conditions and Boolean Logic",
      "canonical_topic": "conditions boolean logic",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 4,
        "coverage_count": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 2,
          "trial_midterm": 1
        }
      },
      "related_topics": [
        "Boolean operators",
        "Conditional statements and expressions",
        "Conditions and boolean operators \u2014 precedence",
        "Truthy and Falsy",
        "conditional_expression",
        "conditions",
        "conditions / boolean",
        "conditions / conditional expression",
        "conditions / precedence",
        "conditions / truthy falsy",
        "conditions / truthy_falsy",
        "conditions_precedence",
        "truthy / falsy",
        "truthy_falsy",
        "Comparison operators",
        "comparison_operators"
      ],
      "trap_patterns": [
        {
          "pattern": "Boolean operator precedence: not > and > or",
          "trap": "a==1 or a==2 and b==1 or b==2 is evaluated as a==1 or (a==2 and b==1) or b==2",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "midterm_2023",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-2f353ad9dc",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Boolean operators",
            "explanation": "x and y: True only if both True. x or y: False only if both False. not x: inverts. NOTE: && and || are Python operators but do something different (bitwise). Precedence: 'not' first, then 'and', then 'or'. Use parentheses to avoid confusion.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\nprint(a==1 or a==2 and b==1 or b==2)  # True (WRONG: and binds tighter)\nprint((a==1 or a==2) and (b==1 or b==2))  # False (CORRECT)"
              }
            ]
          },
          {
            "id": "lec-ce8d642b40",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Conditional statements and expressions",
            "explanation": "if/elif/else. One if at start, at most one else at end, unlimited elif in between. Indentation is critical \u2014 all code in a block must have same indentation. Conditional expression (ternary): value_if_true if condition else value_if_false.",
            "code_examples": [
              {
                "description": "if/elif/else structure",
                "code": "if condition_1:\n    expression_1\nelif condition_2:\n    expression_2\n    expression_3\nelse:\n    expression_4"
              },
              {
                "description": "Conditional expression (ternary)",
                "code": "# Statement form:\nif a > 0:\n    b = a\nelse:\n    b = 0\n# Expression form:\nb = a if a > 0 else 0\n# Even simpler:\nb = max(0, a)"
              }
            ]
          },
          {
            "id": "lec-d7fa16c039",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Conditions and boolean operators \u2014 precedence",
            "explanation": "Precedence (high to low): comparisons \u2192 not \u2192 and \u2192 or. Use parentheses to be explicit. 'in' checks membership in sequence/set/dict-keys.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\n# WRONG: Python evaluates 'and' before 'or'\nprint(a==1 or a==2 and b==1 or b==2)     # True (unexpected)\n# CORRECT: use brackets\nprint((a==1 or a==2) and (b==1 or b==2)) # False"
              },
              {
                "description": "Inclusion check \u2014 'in' operator",
                "code": "print(1 in [1,2,3])    # True\nprint(1 in (1,2,3))    # True\nprint('1' in '123')    # True (substring)\nprint(1 in {1:4, 2:3}) # True (checks keys)\nprint(4 in {1:4, 2:3}) # False (4 is value, not key)\nprint(1 in {1,2,3})    # True"
              }
            ]
          },
          {
            "id": "lec-0fb3921997",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Truthy and Falsy",
            "explanation": "In conditions, Python auto-converts to bool. Falsy: [], (), {}, set(), '', 0, 0.0, range(0), None. Truthy: everything else (non-empty collections, non-zero numbers).",
            "code_examples": [
              {
                "description": "Falsy values",
                "code": "# All evaluate to False in a condition:\n[]    # empty list\n()    # empty tuple\n{}    # empty dict\nset() # empty set\n''    # empty string\n0     # zero int\n0.0   # zero float"
              }
            ]
          },
          {
            "id": "lec-f1ca9d62f9",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Comparison operators",
            "explanation": "==, !=, >, <, >=, <=. Always return True or False. Comparing floats can be tricky: 1.1+2.2 != 3.3 in Python due to floating-point precision. String/tuple/list comparison is element-by-element left to right; first differing element decides; if equal length and no differences, they are equal; shorter sequence is 'less than' longer if all elements match up to shorter length.",
            "code_examples": [
              {
                "description": "Float precision issue",
                "code": "print(1.1 + 2.2 == 3.3)  # False"
              },
              {
                "description": "List/tuple comparison",
                "code": "print([1, 2, 3] < [1, 2, 3, 0])  # True (shorter is less)\nprint([2] < [1, 2, 3, 0])        # False (2 > 1 at index 0)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-f280f69ab8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 7,
            "week": 2,
            "topic": "conditions / truthy falsy",
            "question": "What is the output of the following code?\n\nx = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')",
            "code_context": "",
            "options": {
              "A": "truthy",
              "B": "falsy",
              "C": "0",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "0 is falsy in Python. The else branch executes, printing 'falsy'."
          },
          {
            "id": "exm-163328662e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 9,
            "week": 2,
            "topic": "conditions / conditional expression",
            "question": "What is the output of the following code?\n\nx = 7\nresult = 'odd' if x % 2 != 0 else 'even'\nprint(result)",
            "code_context": "",
            "options": {
              "A": "even",
              "B": "odd",
              "C": "7",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "7 % 2 = 1 != 0, so result = 'odd'."
          },
          {
            "id": "exm-ac7c608999",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 12,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following expressions evaluates to True?",
            "code_context": "",
            "options": {
              "A": "bool([])",
              "B": "bool(0)",
              "C": "bool('')",
              "D": "bool([0])"
            },
            "correct": "D",
            "explanation": "A list with one element [0] is truthy even though the element itself is falsy. [], 0, and '' are all falsy."
          },
          {
            "id": "exm-6f4723b001",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 8,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following values is truthy in Python?",
            "code_context": "",
            "options": {
              "A": "0",
              "B": "''",
              "C": "[]",
              "D": "' '"
            },
            "correct": "D",
            "explanation": "A string with at least one space is truthy. 0, empty string, and empty list are all falsy."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-42ed2c546b",
            "week": 2,
            "cell_index": 53,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(3 > 2)",
            "outputs": []
          },
          {
            "id": "nb-067af65884",
            "week": 2,
            "cell_index": 55,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(True and True,   True or True)\nprint(True and False,  True or False)\nprint(False and True,  False or True)\nprint(False and False, False or False)",
            "outputs": []
          },
          {
            "id": "nb-e50e4bec92",
            "week": 2,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(not True) \nprint(not False)",
            "outputs": []
          },
          {
            "id": "nb-fd93961a89",
            "week": 2,
            "cell_index": 59,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(True and True or False and False)\nprint((True and True) or (False and False))",
            "outputs": []
          },
          {
            "id": "nb-8706fdaa04",
            "week": 2,
            "cell_index": 61,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "print(True or True and False or False)\nprint((True or True) and (False or False))",
            "outputs": []
          },
          {
            "id": "nb-d218099c8c",
            "week": 2,
            "cell_index": 63,
            "cell_type": "code",
            "topic": "conditions",
            "source": "a = 3\nif a > 1 and a < 5:\n    print('a between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-6cf4db433f",
            "week": 2,
            "cell_index": 65,
            "cell_type": "code",
            "topic": "conditions",
            "source": "a = 3\nif 5 > a > 1:\n    print('a between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-01f68c2b97",
            "week": 2,
            "cell_index": 67,
            "cell_type": "code",
            "topic": "conditions",
            "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-0f0d71f802",
            "week": 2,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "a=1\nb=3\nprint(a==1 or a==2 and b==1 or b==2)",
            "outputs": []
          },
          {
            "id": "nb-85aa6dad86",
            "week": 2,
            "cell_index": 71,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "a=1\nb=3\nprint((a==1 or a==2) and (b==1 or b==2))",
            "outputs": []
          },
          {
            "id": "nb-eebf273aa8",
            "week": 2,
            "cell_index": 74,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5) \nprint(a)\n\nif a > 0:\n    b = a\nelse:\n    b = 0\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-a54cf6c386",
            "week": 2,
            "cell_index": 75,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = a if a > 0 else 0\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-fc57853175",
            "week": 2,
            "cell_index": 77,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = max(a, 0)\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-33c2cdb26d",
            "week": 2,
            "cell_index": 108,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [[], (), {}, set(), '', 0, 0.0, range(0)] \nfor x in l1:\n    print (f'{x} is {\"Truthy\" if x else \"Falsy\"}')",
            "outputs": []
          },
          {
            "id": "nb-0e0cf74816",
            "week": 2,
            "cell_index": 110,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:\n    total += l1[0]\n    del l1[0]\nprint(total)",
            "outputs": []
          },
          {
            "id": "nb-05300174f2",
            "week": 1,
            "cell_index": 46,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print(3 == 2)\nprint(3 > 3)\nprint(3 < 4)\nprint(3 >= 2)\nprint(3 <= 3)\nprint(3 != 4)",
            "outputs": []
          },
          {
            "id": "nb-71e169e949",
            "week": 1,
            "cell_index": 47,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print(1.1, 2.2, 1.1 + 2.2 == 3.3)",
            "outputs": []
          },
          {
            "id": "nb-ee7017d81c",
            "week": 1,
            "cell_index": 50,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print([1, 2, 3] < [1, 2, 3, 0])\nprint([2] < [1, 2, 3, 0])\nprint((1, 2, 3, 0) < (1, 2, 3))\nprint((2,) >= (1, 2, 3, 0))\nprint('abc' < 'abc ')\nprint('b' < 'abc ')\nprint('123' < '123 ')\nprint('2' < '123 ')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Condition evaluation in Python combines truthy/falsy rules, comparison operators, and boolean operators (`not`, `and`, `or`). In exam tracing, first evaluate comparisons, then apply boolean precedence (`not` before `and` before `or`) unless parentheses override it. Remember that empty values (`0`, `''`, `[]`, `{}`, `None`) are falsy, while non-empty values are truthy."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Does a list containing a falsy element (e.g., `[0]`) evaluate to True or False?",
            "Is an empty string (`''`) truthy or a string with a space (`' '`)?",
            "Will an empty dictionary or list trigger the `if` or `else` path?",
            "Which of the following values is truthy or falsy?",
            "How is `None` evaluated in a conditional check?",
            "What is the output of this `if/else` block?",
            "When is it better to use a full `if/else` statement instead of a ternary?",
            "Convert a simple `if/else` block to a conditional expression."
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Identifying a Falsy Integer",
            "code": "x = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')",
            "why": "The integer 0 is a falsy value in Python, causing the 'else' branch to execute.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Identifying Truthy Collections",
            "code": "print(bool([0])) # A list with an element is truthy\nprint(bool(' ')) # A string with a space is truthy",
            "why": "Non-empty collections like `[0]` and non-empty strings like `' '` are considered truthy in Python, even if their contents might be falsy.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Common Falsy Values",
            "code": "falsy_values = [[], (), {}, set(), '', 0, 0.0, range(0), None]\nfor x in falsy_values:\n    print(f'{x} is {\"Truthy\" if x else \"Falsy\"}')",
            "why": "This code demonstrates various types of values that Python considers falsy in a boolean context.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Conditional Expression (Ternary Operator)",
            "code": "x = 7\nresult = 'odd' if x % 2 != 0 else 'even'\nprint(result)",
            "why": "The conditional expression assigns 'odd' to `result` because `x % 2 != 0` evaluates to `True` for `x = 7`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Basic If-Else Statement",
            "code": "from random import randint\na = randint(0,5)\nprint(f\"Random value: {a}\")\nif a > 1 and a < 5:\n    print('a between 2 and 4 (inclusive)')\nelse:\n    print('a not between 2 and 4 (inclusive)')",
            "why": "This demonstrates a basic `if/else` structure, where one block executes based on the condition `a > 1 and a < 5`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Conditional Assignment using Ternary Operator",
            "code": "from random import randint\na = randint(-5,5)\nprint(f\"Value of a: {a}\")\nb = a if a > 0 else 0\nprint(f\"Value of b: {b}\")",
            "why": "This example uses the ternary operator to assign `a` to `b` if `a` is positive, otherwise assigns `0`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Boolean `and`, `or` Truth Table",
            "code": "print(f'True and True: {True and True}')\nprint(f'True or True: {True or True}')\nprint(f'True and False: {True and False}')\nprint(f'True or False: {True or False}')\nprint(f'False and True: {False and True}')\nprint(f'False or True: {False or True}')\nprint(f'False and False: {False and False}')\nprint(f'False or False: {False or False}')",
            "why": "This code illustrates the fundamental behavior of the `and` and `or` boolean operators with all possible `True`/`False` combinations.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Boolean `not` Operator",
            "code": "print(f'not True: {not True}')\nprint(f'not False: {not False}')",
            "why": "The `not` operator inverts the boolean value of its operand.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "incorrect",
            "title": "Boolean Precedence Trap",
            "code": "a = 1\nb = 3\n# This expression evaluates as: a==1 or (a==2 and b==1) or b==2\nprint(a==1 or a==2 and b==1 or b==2)",
            "why": "Due to operator precedence (`and` before `or`), this expression evaluates to `True or False or True`, which results in `True`. Without parentheses, the evaluation order can be unexpected.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Clarifying Boolean Precedence with Parentheses",
            "code": "a = 1\nb = 3\nprint((a==1 or a==2) and (b==1 or b==2))",
            "why": "Parentheses are used to group `(a==1 or a==2)` and `(b==1 or b==2)`, ensuring the `or` operations are evaluated first, then their results combined by `and`. This results in `True and False`, which is `False`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "Basic Comparison Operators",
            "code": "print(f'3 == 2: {3 == 2}')\nprint(f'3 > 3: {3 > 3}')\nprint(f'3 < 4: {3 < 4}')\nprint(f'3 >= 2: {3 >= 2}')\nprint(f'3 <= 3: {3 <= 3}')\nprint(f'3 != 4: {3 != 4}')",
            "why": "This shows the direct boolean results of various common comparison operators.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "incorrect",
            "title": "Floating-Point Precision Issue in Comparison",
            "code": "print(f'1.1 + 2.2 == 3.3: {1.1 + 2.2 == 3.3}')",
            "why": "Due to the inherent limitations of floating-point representation, `1.1 + 2.2` does not precisely equal `3.3`, leading to a `False` result.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Chained Comparison",
            "code": "a = 3\nif 5 > a > 1:\n    print('a is between 2 and 4 (inclusive)')",
            "why": "Python allows chained comparisons like `5 > a > 1`, which is equivalent to `5 > a and a > 1`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-14",
            "kind": "correct",
            "title": "'in' Operator for Membership Check",
            "code": "print(f'1 in [1,2,3]: {1 in [1,2,3]}')\nprint(f'1 in {{1:4, 2:3}}: {1 in {1:4, 2:3}}') # Checks dictionary keys\nprint(f'4 in {{1:4, 2:3}}: {4 in {1:4, 2:3}}') # 4 is a value, not a key",
            "why": "The `in` operator correctly identifies membership for elements in lists and keys in dictionaries.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-15",
            "kind": "correct",
            "title": "Sequence Comparison (Lists)",
            "code": "print(f'[1, 2, 3] < [1, 2, 3, 0]: {[1, 2, 3] < [1, 2, 3, 0]}')\nprint(f'[2] < [1, 2, 3, 0]: {[2] < [1, 2, 3, 0]}')",
            "why": "This demonstrates sequence comparison rules: the first example is True because the first list is shorter but matches the beginning of the second. The second example is False because the first differing element (2 vs 1) makes the first list greater.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Python automatically converts values to boolean for conditions, treating certain values as falsy and others as truthy.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Implicit Boolean Conversion",
                "text": "Python automatically evaluates values as True or False in conditional contexts. Understanding which values are 'falsy' (evaluate to False) and which are 'truthy' (evaluate to True) is crucial.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Falsy values in Python include empty collections (lists [], tuples (), dictionaries {}, sets set()), empty strings (''), zero numbers (integers 0, floats 0.0), range(0), and None.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "table",
                "title": "Common Falsy Values",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Type",
                    "Example"
                  ],
                  "rows": [
                    [
                      "Empty List",
                      "[]"
                    ],
                    [
                      "Empty Tuple",
                      "()"
                    ],
                    [
                      "Empty Dictionary",
                      "{}"
                    ],
                    [
                      "Empty Set",
                      "set()"
                    ],
                    [
                      "Empty String",
                      "''"
                    ],
                    [
                      "Zero Integer",
                      "0"
                    ],
                    [
                      "Zero Float",
                      "0.0"
                    ],
                    [
                      "Empty Range",
                      "range(0)"
                    ],
                    [
                      "None Type",
                      "None"
                    ]
                  ]
                }
              },
              {
                "id": "kp-2-d2",
                "kind": "example",
                "title": "Falsy in Action",
                "text": "",
                "code": "x = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')\n# Output: falsy",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Any value not explicitly defined as falsy, such as non-empty collections or non-zero numbers, is considered truthy in Python.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "explanation",
                "title": "Truthiness Rule",
                "text": "If a value is not explicitly listed as falsy, it is considered truthy. This includes non-empty collections and non-zero numbers, even if they contain falsy elements.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Truthiness Example",
                "text": "",
                "code": "bool([0]) # Evaluates to True because the list is not empty\nbool(' ') # Evaluates to True because the string is not empty",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Conditional statements (if/elif/else) control program flow based on the truthiness of conditions.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Flow Control",
                "text": "Conditional statements (if, elif, else) direct program execution based on the truthiness of expressions.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Basic Conditional",
                "text": "",
                "code": "a = 3\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse:\n    print('a not between 2 and 5')\n# Output depends on 'a', for a=3: 'a between 2 and 5'",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Indentation is critical in Python; all code within a conditional block must maintain the same indentation level.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "explanation",
                "title": "Indentation Defines Blocks",
                "text": "Python uses indentation to delineate code blocks. All statements within an `if`, `elif`, or `else` block must have the same level of indentation.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "A conditional block begins with an 'if' statement, can include zero or more 'elif' statements, and may conclude with at most one 'else' statement.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "explanation",
                "title": "Conditional Structure",
                "text": "A standard conditional structure begins with an `if`, can have zero or more `elif` (else if) clauses, and may optionally end with a single `else` clause.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Python supports a conditional expression (ternary operator) formatted as `value_if_true if condition else value_if_false` for concise assignments.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Ternary Operator (Conditional Expression)",
                "text": "",
                "code": "x = 7\nresult = 'odd' if x % 2 != 0 else 'even'\nprint(result)\n# Output: odd",
                "table": null
              },
              {
                "id": "kp-7-d2",
                "kind": "explanation",
                "title": "Concise Assignment",
                "text": "The ternary operator provides a compact way to assign a value based on a condition, replacing a simple `if/else` block for assignment.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-7-d3",
                "kind": "example",
                "title": "Ternary vs. If/Else",
                "text": "",
                "code": "# if/else statement form:\n# if a > 0: b = a\n# else: b = 0\n\n# Ternary expression form:\nb = a if a > 0 else 0",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Python's boolean operators are `and`, `or`, and `not`, used to combine or modify boolean conditions.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "explanation",
                "title": "Boolean Operators Overview",
                "text": "Python uses `and`, `or`, and `not` to combine or invert boolean conditions. These are distinct from bitwise operators `&&` and `||` in other languages.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "The `and` operator evaluates to `True` only if both operands are `True`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "table",
                "title": "`and` Operator Truth Table",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Operand 1",
                    "Operand 2",
                    "Result (Operand 1 and Operand 2)"
                  ],
                  "rows": [
                    [
                      "True",
                      "True",
                      "True"
                    ],
                    [
                      "True",
                      "False",
                      "False"
                    ],
                    [
                      "False",
                      "True",
                      "False"
                    ],
                    [
                      "False",
                      "False",
                      "False"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "The `or` operator evaluates to `False` only if both operands are `False`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "table",
                "title": "`or` Operator Truth Table",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Operand 1",
                    "Operand 2",
                    "Result (Operand 1 or Operand 2)"
                  ],
                  "rows": [
                    [
                      "True",
                      "True",
                      "True"
                    ],
                    [
                      "True",
                      "False",
                      "True"
                    ],
                    [
                      "False",
                      "True",
                      "True"
                    ],
                    [
                      "False",
                      "False",
                      "False"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "The `not` operator inverts the boolean value of its operand.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "example",
                "title": "`not` Operator",
                "text": "",
                "code": "print(not True)   # Output: False\nprint(not False)  # Output: True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "Boolean operator precedence in Python is `not` (highest), followed by `and`, and then `or` (lowest), with comparison operators having higher precedence than boolean operators.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "explanation",
                "title": "Operator Precedence",
                "text": "Comparisons are evaluated first, then `not`, then `and`, and finally `or`. This order is crucial for correctly interpreting complex expressions.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-12-d2",
                "kind": "table",
                "title": "Boolean Precedence (High to Low)",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Operator Type",
                    "Operators"
                  ],
                  "rows": [
                    [
                      "Comparisons",
                      "==, !=, <, >, <=, >="
                    ],
                    [
                      "Negation",
                      "not"
                    ],
                    [
                      "Conjunction",
                      "and"
                    ],
                    [
                      "Disjunction",
                      "or"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "Parentheses should be used to explicitly control the order of evaluation in complex boolean expressions, overriding default precedence and enhancing readability.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "example",
                "title": "Using Parentheses to Control Order",
                "text": "Parentheses clarify the order of evaluation, making complex boolean expressions more readable and preventing precedence traps.",
                "code": "a=1; b=3\n# Without parentheses (precedence trap):\n# print(a==1 or a==2 and b==1 or b==2) # True (unexpected if you thought 'or' binds first)\n\n# With parentheses (correct logic):\nprint((a==1 or a==2) and (b==1 or b==2)) # False",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "Comparison operators (`==`, `!=`, `>`, `<`, `>=`, `<=`) always evaluate to either `True` or `False`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "explanation",
                "title": "Comparison Operators Result",
                "text": "Comparison operators always yield a boolean `True` or `False` value, representing the outcome of the comparison.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-14-d2",
                "kind": "example",
                "title": "Basic Comparisons",
                "text": "",
                "code": "print(3 == 2)  # False\nprint(3 < 4)   # True\nprint(3 != 4)  # True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "Due to floating-point precision, comparing float numbers for exact equality using `==` can sometimes yield unexpected `False` results.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "example",
                "title": "Floating-Point Precision Issue",
                "text": "Direct equality comparison (`==`) of floating-point numbers can be unreliable due to how they are represented in binary.",
                "code": "print(1.1 + 2.2 == 3.3) # Output: False (unexpected but common)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-16",
            "text": "Python allows chained comparisons, such as `x < y < z`, which is equivalent to `x < y and y < z`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-16-d1",
                "kind": "example",
                "title": "Chained Comparisons",
                "text": "Python allows chaining comparison operators, which is syntactic sugar for combining multiple comparisons with `and`.",
                "code": "x = 3\n# Chained comparison:\nif 1 < x < 5:\n    print('x is between 1 and 5') # Output: x is between 1 and 5\n\n# Equivalent to:\n# if 1 < x and x < 5:",
                "table": null
              }
            ]
          },
          {
            "id": "kp-17",
            "text": "The `in` operator checks for membership of a value within sequences (like lists, tuples, strings) or for the presence of a key in dictionaries.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-17-d1",
                "kind": "example",
                "title": "`in` Operator for Membership",
                "text": "The `in` operator efficiently checks if an item is present within a sequence (like a list, tuple, or string) or if a key exists in a dictionary.",
                "code": "print(1 in [1,2,3])    # True\nprint('a' in 'apple')  # True\nprint(1 in {1: 'one', 2: 'two'}) # True (checks keys)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-18",
            "text": "When comparing sequences (strings, lists, tuples), Python performs an element-by-element comparison from left to right; the first differing element determines the result, and a shorter sequence is considered 'less than' a longer one if all elements match up to the shorter length.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-18-d1",
                "kind": "example",
                "title": "Sequence Comparison",
                "text": "Sequences are compared element by element. The comparison stops at the first differing element. If one sequence is a prefix of another, the shorter one is considered 'less'.",
                "code": "print([1, 2, 3] < [1, 2, 3, 0]) # True (shorter prefix is less)\nprint([2] < [1, 2, 3, 0])    # False (2 is not < 1)\nprint('abc' < 'abc ')        # True ('abc' is shorter prefix)",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-6f4723b001",
          "exm-f280f69ab8",
          "exm-ac7c608999",
          "exm-163328662e",
          "lec-0fb3921997",
          "lec-ce8d642b40",
          "lec-d7fa16c039",
          "lec-2f353ad9dc",
          "nb-33c2cdb26d",
          "nb-6cf4db433f"
        ]
      }
    },
    {
      "id": "topic-argument-default",
      "topic": "Default Arguments and Mutable Defaults",
      "canonical_topic": "default arguments mutable defaults",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 4,
        "coverage_count": 2,
        "by_exam": {
          "midterm_2024": 2,
          "trial_midterm": 2
        }
      },
      "related_topics": [
        "Default arguments",
        "Mutable default argument",
        "default arguments / mutable defaults",
        "default args / mutable defaults",
        "mutable args",
        "mutable args / side effects",
        "mutable_args",
        "mutable_default",
        "mutable_defaults"
      ],
      "trap_patterns": [
        {
          "pattern": "Mutable default argument",
          "trap": "def f(lst=[]): \u2014 the [] is created ONCE at def time and persists across calls. Fix: use None and create inside function",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8f250614a1",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Default arguments",
            "explanation": "Default values are part of the function HEADER (not the call). When argument is omitted, the default is used. Keyword args in a call use =. CRITICAL: mutable defaults are evaluated ONCE at def time \u2014 never use mutable defaults; use None instead.",
            "code_examples": [
              {
                "description": "Default value",
                "code": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3))       # 6 (uses default second=2)\nprint(multiplier(3, 3))    # 9\nprint(multiplier(2, second=3))  # 6"
              },
              {
                "description": "Mutable default BUG",
                "code": "def main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [2, 3] \u2190 BUG: l1 persists!"
              },
              {
                "description": "Mutable default FIX \u2014 use None",
                "code": "def main(addition, l1=None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [3]  \u2190 correct"
              }
            ]
          },
          {
            "id": "leq-a9a97c880c",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Mutable default argument",
            "question": "What is the result of:\ndef main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))\nprint(main(3))",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [
          {
            "id": "exm-d2e7fd42c3",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 16,
            "week": 3,
            "topic": "default args / mutable defaults",
            "question": "What is the output of the following code?\n\ndef func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))\nprint(func(3, []))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[3]",
              "C": "[1]\n[1, 2]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "func(1) and func(2) share the default list: [1] then [1,2]. func(3,[]) uses a fresh list: [3]."
          },
          {
            "id": "exm-245b0664c1",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 23,
            "week": 3,
            "topic": "mutable args / side effects",
            "question": "What is the output of the following code?\n\ndef double_list(lst):\n    lst = [x * 2 for x in lst]\n    return lst\n\nmy_list = [1, 2, 3]\nresult = double_list(my_list)\nprint(my_list)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[2, 4, 6]",
              "B": "[2, 4, 6]\n[2, 4, 6]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "Inside the function, lst = [...] rebinds the local name to a new list. my_list is not modified. result is [2,4,6]."
          },
          {
            "id": "exm-72aaa9b4b7",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 13,
            "week": 3,
            "topic": "default arguments / mutable defaults",
            "question": "What is the output of the following code?\n\ndef add_item(item, lst=[]):\n    lst.append(item)\n    return lst\n\nprint(add_item(1))\nprint(add_item(2))\nprint(add_item(3))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[1, 2, 3]",
              "C": "[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "The default list [] is created once when the function is defined and shared across all calls. Each call appends to the same list."
          },
          {
            "id": "exm-88bc6a52d4",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 20,
            "week": 3,
            "topic": "mutable args",
            "question": "What is the output of the following code?\n\ndef append_to(element, to):\n    to.append(element)\n    return to\n\nmy_list = []\nresult1 = append_to(1, my_list)\nresult2 = append_to(2, my_list)\nprint(result1)\nprint(result2)",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]",
              "B": "[1]\n[1, 2]",
              "C": "[1, 2]\n[1, 2]",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "Both result1 and result2 refer to the same list my_list. After both calls, my_list = [1, 2], so both prints show [1, 2]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-a6c56752fc",
            "week": 3,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "mutable_args",
            "source": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
            "outputs": []
          },
          {
            "id": "nb-de31c2de52",
            "week": 3,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "mutable_args",
            "source": "def adder(l2):\n    l2 = l2[:]\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
            "outputs": []
          },
          {
            "id": "nb-6725133dff",
            "week": 3,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_defaults",
            "source": "def main (addition, l1 = []):\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
            "outputs": []
          },
          {
            "id": "nb-d69134ce72",
            "week": 3,
            "cell_index": 57,
            "cell_type": "code",
            "topic": "mutable_defaults",
            "source": "def main (addition, l1 = None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Default parameters are evaluated once at function definition time. If a default is mutable (like `[]` or `{}`), updates persist across calls and create shared state bugs. A safe pattern is `param=None` followed by creating a new object inside the function when needed.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the output after calling the function multiple times with a mutable default argument?",
            "How do you correctly and safely initialize an empty list as a default inside a function?",
            "At what point is the default argument's value evaluated: when the function is defined, or when it's called?",
            "Why does `def my_func(a=1, b):` cause a `SyntaxError`?",
            "If a function is `def f(x, y=2):`, how do you call it providing a value only for `x`?",
            "What is the value of a variable that is assigned the result of a function call?",
            "What is the output of the second and third calls to this function?",
            "Explain why the list appears to 'remember' items from previous calls."
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic Default Argument Usage",
            "code": "def multiplier(first, second=2):\n    return first * second\n\nprint(multiplier(3))         # Expected: 6 (uses default second=2)\nprint(multiplier(3, 3))      # Expected: 9 (overrides default)\nprint(multiplier(2, second=3)) # Expected: 6 (overrides default with keyword arg)",
            "why": "This demonstrates how non-mutable default arguments are used when omitted in a function call or can be explicitly overridden, either positionally or by keyword.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Mutable Default Argument Trap: List Persistence",
            "code": "def func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1)) # First call\nprint(func(2)) # Second call",
            "why": "The default list `[]` is created only once when the `func` function is defined. Both calls to `func(1)` and `func(2)` modify and share this *same* list instance, causing the list to persist its state across calls, leading to an unexpected output of `[1, 2]` for the second call.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Handling Mutable Defaults with None",
            "code": "def main(addition, l1=None):\n    if l1 is None:\n        l1 = [] # A new list is created only if no list is provided\n    l1.append(addition)\n    return l1\n\nprint(main(2)) # Expected: [2]\nprint(main(3)) # Expected: [3]",
            "why": "Using `None` as the default and then conditionally initializing `l1` to a new list inside the function ensures that a fresh, independent list is used for each call where the `l1` argument is omitted, preventing state persistence and unexpected side effects.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Modifying a Passed Mutable Argument",
            "code": "def append_to(element, to_list):\n    to_list.append(element)\n    return to_list\n\nmy_list = []\nresult1 = append_to(1, my_list)\nresult2 = append_to(2, my_list)\n\nprint(result1) # Expected: [1, 2]\nprint(result2) # Expected: [1, 2]",
            "why": "When a mutable object (`my_list`) is passed as an argument (`to_list`), changes made to it within the function (e.g., `to_list.append(element)`) are reflected in the original object outside the function. Both `result1` and `result2` refer to the same modified `my_list`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Rebinding Local Variable vs. Modifying Original Object",
            "code": "def double_list(lst):\n    lst = [x * 2 for x in lst] # Rebinds the local 'lst' to a new list\n    return lst\n\nmy_list = [1, 2, 3]\nresult = double_list(my_list)\n\nprint(my_list) # Expected: [1, 2, 3] (original list unchanged)\nprint(result)  # Expected: [2, 4, 6] (new list returned)",
            "why": "Inside `double_list`, the statement `lst = [...]` creates a *new* list object and rebinds the local variable `lst` to this new object. The original `my_list` object, passed as an argument, remains unaffected, while `result` holds the newly created list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Overriding Mutable Default with a New Object in Call",
            "code": "def func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))     # Uses the persistent default list\nprint(func(3, [])) # Provides a new empty list for this call",
            "why": "The first call to `func(1)` uses the persistent default list, causing its state to be modified. However, the second call `func(3, [])` explicitly provides a new empty list `[]` as an argument, ensuring it receives a fresh mutable object for that specific invocation, isolating its state from the shared default.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Default values for function arguments are evaluated once when the function is defined, not on each subsequent call.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Default Evaluation",
                "text": "Default argument values are determined only once when the function is defined, not each time the function is called. This can lead to unexpected behavior with mutable defaults.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "example",
                "title": "Default Argument Evaluation",
                "text": "",
                "code": "def func(x, y=10):\n    return x + y\nprint(func(5)) # y is 10\ndef func_redefined(x, y=20):\n    return x + y\nprint(func(5)) # y is still 10, func_redefined's default doesn't affect func",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Mutable objects (e.g., lists, dictionaries) used as default arguments will persist and be shared across all function calls that do not explicitly provide that argument, leading to unexpected behavior.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Mutable Default Pitfall",
                "text": "Using a mutable object (like a list) as a default argument means all calls without explicitly providing that argument will share the *same* list, leading to persistent changes.",
                "code": "def add_to_list(item, data_list=[]):\n    data_list.append(item)\n    return data_list\n\nprint(add_to_list(1)) # Output: [1]\nprint(add_to_list(2)) # Output: [1, 2] - The same list from the first call is modified.\nprint(add_to_list(3, [])) # Output: [3] - A new list is provided, so it's not affected.",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "To avoid issues with mutable default arguments, use `None` as the default value and initialize the mutable object inside the function body if `None` is received.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Correcting Mutable Defaults",
                "text": "To prevent shared mutable defaults, use `None` as the default and initialize the mutable object inside the function only if `None` was received.",
                "code": "def add_to_list_safe(item, data_list=None):\n    if data_list is None:\n        data_list = []\n    data_list.append(item)\n    return data_list\n\nprint(add_to_list_safe(1)) # Output: [1]\nprint(add_to_list_safe(2)) # Output: [2] - A new list is created each time.",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "If a mutable object is passed as an argument to a function and modified within that function, the changes are visible to the caller outside the function.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "In-Function Modification",
                "text": "When a mutable object is passed as an argument and modified directly (e.g., using `append()`, `del`), the changes are reflected in the original object outside the function.",
                "code": "def modify_list_in_place(lst):\n    lst.append(4)\n    return lst\n\nmy_original_list = [1, 2, 3]\nreturned_list = modify_list_in_place(my_original_list)\nprint(f\"Original list after call: {my_original_list}\") # Output: Original list after call: [1, 2, 3, 4]\nprint(f\"Returned list: {returned_list}\") # Output: Returned list: [1, 2, 3, 4]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Reassigning a local variable within a function to a new object (e.g., `lst = [new_items]`) does not modify the original object passed as an argument; it only rebinds the local variable name to a new object.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Rebinding vs. Modifying",
                "text": "If a local variable inside a function is *reassigned* to a new object (e.g., `lst = new_list`), it creates a new local reference and does not modify the original object passed into the function.",
                "code": "def rebind_list(lst):\n    lst = [5, 6, 7] # This creates a new local list, 'lst' now refers to it.\n    return lst\n\nmy_list_outside = [1, 2, 3]\nnew_list_ref = rebind_list(my_list_outside)\nprint(f\"Original list outside: {my_list_outside}\") # Output: Original list outside: [1, 2, 3] (unmodified)\nprint(f\"New list reference: {new_list_ref}\") # Output: New list reference: [5, 6, 7]",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-72aaa9b4b7",
          "lec-8f250614a1",
          "exm-88bc6a52d4",
          "exm-d2e7fd42c3",
          "exm-245b0664c1",
          "nb-a6c56752fc",
          "nb-de31c2de52",
          "leq-a9a97c880c",
          "nb-6725133dff",
          "nb-d69134ce72"
        ]
      }
    },
    {
      "id": "topic-enumerate",
      "topic": "Enumerate",
      "canonical_topic": "enumerate",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "For-loops",
        "enumerate",
        "enumerate / dictionaries / conditions",
        "enumerate()",
        "for loops / enumerate",
        "for_loop / enumerate",
        "for_loops"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) \u2014 second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          },
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used \u2014 use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-09e753703b",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 10,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nlst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
            "code_context": "",
            "options": {
              "A": "0 a\n1 b\n2 c",
              "B": "1 a\n2 b\n3 c",
              "C": "a 1\nb 2\nc 3",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "enumerate(lst, start=1) begins counting at 1. Output: 1 a, 2 b, 3 c."
          },
          {
            "id": "exm-b7bad1b1ce",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 8,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
            "code_context": "",
            "options": {
              "A": "0 apple\n1 banana\n2 cherry",
              "B": "1 apple\n2 banana\n3 cherry",
              "C": "apple 0\nbanana 1\ncherry 2",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "enumerate starts at 0 by default and yields (index, value) pairs."
          },
          {
            "id": "exm-f358fb2d91",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 12,
            "week": 2,
            "topic": "enumerate / dictionaries / conditions",
            "question": "def counter(y):\n\tx = {}\n\tfor index, element in enumerate(y):\n\t\tif index != int(element) and int(element) % 2 == 0:\n\t\t\tx[element] = len(element)\n\treturn x\n\nWhat will this function return when called as:\ncounter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])",
            "code_context": "",
            "options": {
              "a": "{'12345678': 8, '1234': 4, '12': 2, '123456': 6}",
              "b": "{'12345678': 8, '123': 3, '1234': 4, '12345': 5, '12': 2, '6': 1, '1': 1, '123456': 6}",
              "c": "{'123': 3, '12345': 5, '1': 1}",
              "d": "{'12345678': 8, '1': 1, '1234': 4, '12': 2, '6': 1, '123456': 6}"
            },
            "correct": "a",
            "explanation": "index 0: '12345678', int=12345678, index(0)!=12345678 \u2713, even \u2713 \u2192 add, len=8. index 1: '1', int=1, index==int \u2192 skip. index 2: '123', int=123, odd \u2192 skip. index 3: '1234', int=1234, index(3)!=1234 \u2713, even \u2713 \u2192 add, len=4. index 4: '12345', int=12345, odd \u2192 skip. index 5: '12', int=12, index(5)!=12 \u2713, even \u2713 \u2192 add, len=2. index 6: '6', int=6, index(6)==6 \u2192 skip. index 7: '1', int=1, odd \u2192 skip. index 8: '123456', int=123456, index(8)!=123456 \u2713, even \u2713 \u2192 add, len=6. Result: {'12345678':8,'1234':4,'12':2,'123456':6}. Correct: a."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "`enumerate()` adds a counter to a sequence, allowing a `for` loop to access both the index and the value of each item simultaneously. The syntax is `for index, value in enumerate(sequence)`. By default, the index starts at 0, but you can change this with a second argument, like `enumerate(sequence, start=1)`. Output questions hinge on tracking the start value and the correct assignment of index and value variables."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Predicting the index of a specific element in the sequence.",
            "Swapping the `index` and `value` variables in the loop.",
            "What is the output of this loop using `enumerate()`?",
            "Forgetting that the default start index is 0, not 1.",
            "What is the default starting value for the index?",
            "How do you change the starting index to 1?",
            "In `for idx, val in enumerate(data):`, what does `idx` represent?",
            "By default, what is the first index that `enumerate()` returns?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Enumerate with default starting index",
            "code": "fruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
            "why": "`enumerate()` automatically provides indices starting from 0, paired with the corresponding values.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Enumerate with a custom starting index",
            "code": "lst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
            "why": "The `start=1` argument causes `enumerate()` to begin indexing from 1 instead of the default 0.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "incorrect",
            "title": "Manual indexing without enumerate",
            "code": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "why": "Manually managing the index is more verbose and error-prone compared to using `enumerate()`, which handles index tracking automatically.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Complex conditional logic using enumerate",
            "code": "def counter(y):\n    x = {}\n    for index, element in enumerate(y):\n        if index != int(element) and int(element) % 2 == 0:\n            x[element] = len(element)\n    return x\n\nresult = counter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])\nprint(result)",
            "why": "The `enumerate` function allows simultaneous access to both the index and the element, facilitating complex conditional checks like comparing the index to the integer value of the element and checking parity.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The `enumerate()` function provides an index alongside the value when iterating through a sequence.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Core Functionality",
                "text": "`enumerate()` streamlines iteration by pairing each item in a sequence with its corresponding index.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "example",
                "title": "Basic Usage",
                "text": "",
                "code": "fruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "By default, `enumerate()` starts counting indices from 0 and yields (index, value) pairs.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Default 0-based Indexing",
                "text": "By default, `enumerate()` starts counting from 0, returning (index, value) tuples.",
                "code": "fruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)\n# Expected output:\n# 0 apple\n# 1 banana\n# 2 cherry",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The starting index can be customized by providing a `start` argument to the `enumerate()` function.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Custom Start Index",
                "text": "Use the `start` argument to begin indexing from a number other than 0.",
                "code": "lst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)\n# Expected output:\n# 1 a\n# 2 b\n# 3 c",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-b7bad1b1ce",
          "exm-09e753703b",
          "exm-f358fb2d91",
          "lec-ca6bf752eb",
          "lec-1a2667a070",
          "nb-6d22b8d418"
        ]
      }
    },
    {
      "id": "topic-lambda-sorted",
      "topic": "Lambda",
      "canonical_topic": "lambda",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Lambda functions",
        "Methods vs functions",
        "filter / lambda",
        "fun_example",
        "lambda",
        "lambda / map",
        "lambda / reduce",
        "lambda / sorted",
        "sorted / lambda"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-0a5f25a4f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Lambda functions",
            "explanation": "Anonymous one-line functions. Syntax: lambda params: expression. Equivalent to a regular def but more concise. Most useful with map, filter, reduce, sorted, max.",
            "code_examples": [
              {
                "description": "Lambda basics",
                "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))  # 3\n# Equivalent to:\ndef add_two(x, y):\n    return x + y"
              },
              {
                "description": "map() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))   # [2, 4, 6, 8, 10, 12]\n# Need list() to convert map object to list"
              },
              {
                "description": "filter() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))  # [2, 4, 6] (even numbers)"
              },
              {
                "description": "reduce() with lambda",
                "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))  # 720 (product)\n# reduce with initial value:\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))  # 5"
              },
              {
                "description": "sorted() with key lambda",
                "code": "l1 = ['aaa', 'c', 'baab']\nprint(sorted(l1))                              # ['aaa', 'baab', 'c']\nprint(sorted(l1, key=lambda x: x.count('a'))) # ['c', 'baab', 'aaa']\nprint(sorted(l1, key=len))                    # ['c', 'aaa', 'baab']\n\nd = {'a': 2, 'b': 1}\nprint(max(d.items()))                         # ('b', 1)  \u2190 compares tuples\nprint(max(d.items(), key=lambda x: x[1]))     # ('a', 2)  \u2190 by value"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings \u2014 you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable \u2014 must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT \u2014 captures new string\ns1.upper()       # WRONG \u2014 result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable \u2014 changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-fcf6f31262",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 15,
            "week": 3,
            "topic": "lambda",
            "question": "What is the output of the following code?\n\ndouble = lambda x: x * 2\nprint(double(5))",
            "code_context": "",
            "options": {
              "A": "25",
              "B": "10",
              "C": "52",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "The lambda multiplies its argument by 2. double(5) = 5 * 2 = 10."
          },
          {
            "id": "exm-9ac62bbb4e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 18,
            "week": 3,
            "topic": "lambda",
            "question": "What is the output of the following code?\n\nf = lambda x, y: x if x > y else y\nprint(f(3, 7))",
            "code_context": "",
            "options": {
              "A": "3",
              "B": "7",
              "C": "10",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "3 > 7 is False, so the lambda returns y = 7."
          },
          {
            "id": "exm-17c4e4022d",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 12,
            "week": 3,
            "topic": "lambda / sorted",
            "question": "What is the output of the following code?\n\npairs = [(1, 3), (2, 1), (3, 2)]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nprint(sorted_pairs)",
            "code_context": "",
            "options": {
              "A": "[(1, 3), (2, 1), (3, 2)]",
              "B": "[(2, 1), (3, 2), (1, 3)]",
              "C": "[(3, 2), (2, 1), (1, 3)]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Sorted by second element (x[1]): 1 < 2 < 3. Result: [(2,1), (3,2), (1,3)]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-b257dde94b",
            "week": 3,
            "cell_index": 59,
            "cell_type": "code",
            "topic": "lambda",
            "source": "multiply_and_double = lambda x, y: 2*x*y  \nprint(multiply_and_double(1,3))",
            "outputs": []
          },
          {
            "id": "nb-64fa3cf49c",
            "week": 3,
            "cell_index": 60,
            "cell_type": "code",
            "topic": "lambda",
            "source": "def multiply_and_double(x,y):\n    return 2*x*y\nprint(multiply_and_double(1,3))",
            "outputs": []
          },
          {
            "id": "nb-ead5baf6cb",
            "week": 3,
            "cell_index": 62,
            "cell_type": "code",
            "topic": "lambda",
            "source": "print((lambda x, y: 2*x*y)(4, 3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "A 'lambda' function is a small, one-line anonymous function defined using the 'lambda' keyword. It's restricted to a single expression and is most useful when you need a short-lived function for a simple task, like providing a 'key' for sorting. The 'sorted()' function can take a 'lambda' as its key argument to specify a custom sorting logic, for instance, to sort a list of tuples based on the second element of each"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the difference between 'list.sort()' and 'sorted(list)'?",
            "Rewrite this lambda function using a standard 'def' statement.",
            "What will be the output of 'sorted()' using this lambda key?",
            "Sort a list of dictionaries by a specific value.",
            "Can a lambda function contain an 'if/else'?",
            "What does this lambda function return?",
            "What happens if you use `map` on lists of unequal length with a two-argument lambda?",
            "Write a `lambda` with `map` to get the first letter of each string in a list."
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic Lambda Assignment and Call",
            "code": "double = lambda x: x * 2\nprint(double(5))",
            "why": "This demonstrates assigning a lambda function to a variable and calling it with an argument, resulting in the evaluation of its single expression.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Lambda with Conditional Expression",
            "code": "f = lambda x, y: x if x > y else y\nprint(f(3, 7))",
            "why": "This example shows how to use a conditional expression within a lambda function to return one of two values based on a condition.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Sorting a List of Tuples by Second Element using Lambda Key",
            "code": "pairs = [(1, 3), (2, 1), (3, 2)]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nprint(sorted_pairs)",
            "why": "Illustrates a common use case of lambda functions as the 'key' argument in `sorted()` to specify a custom sorting criteria, here by the second element of each tuple.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Lambda with Multiple Arguments",
            "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))",
            "why": "Demonstrates defining a lambda function that accepts and processes multiple input parameters.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Using Lambda with map()",
            "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))",
            "why": "Shows how `map()` applies a lambda function to each item of an iterable, transforming them, and the need to convert the map object to a list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Using Lambda with filter()",
            "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))",
            "why": "Demonstrates `filter()` using a lambda function to select items from an iterable based on a boolean condition (here, filtering for even numbers).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Using Lambda with functools.reduce()",
            "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x * y, l1))",
            "why": "Illustrates how `reduce()` iteratively applies a lambda function to accumulate a single result from an iterable (here, calculating the product).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Using Lambda with max() for Custom Key",
            "code": "d = {'a': 2, 'b': 1}\nprint(max(d.items(), key=lambda x: x[1]))",
            "why": "Demonstrates using a lambda as the `key` argument for `max()` to find the item with the maximum value based on a specific element or attribute (here, the dictionary value).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Immediately Invoked Lambda Expression",
            "code": "print((lambda x, y: 2 * x * y)(4, 3))",
            "why": "Shows a lambda function being defined and called in a single statement, without intermediate assignment to a variable.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Lambda functions are anonymous, single-expression functions defined on one line.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Definition",
                "text": "Lambda functions are indeed anonymous, one-line functions that do not require a `def` keyword.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "The syntax for a lambda function is `lambda parameters: expression`, where the expression's result is implicitly returned.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Basic Syntax",
                "text": "The result of the expression is implicitly returned.",
                "code": "lambda parameters: expression",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Lambda functions can be assigned to variables and then invoked like regular functions.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Assigning to a Variable",
                "text": "",
                "code": "double = lambda x: x * 2\nprint(double(5)) # Output: 10",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Multi-argument assignment",
                "text": "",
                "code": "multiply_and_double = lambda x, y: 2 * x * y\nprint(multiply_and_double(1, 3)) # Output: 6",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Lambda functions can be invoked immediately after definition without being assigned to a variable.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Immediate Invocation",
                "text": "",
                "code": "print((lambda x, y: 2 * x * y)(4, 3)) # Output: 24",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Lambda functions are frequently used as arguments to higher-order functions like `map`, `filter`, `reduce`, `sorted`, and `max` for concise custom logic.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Using with `map()`",
                "text": "",
                "code": "l1 = [1, 2, 3]\nmapped_list = list(map(lambda x: x * 2, l1))\nprint(mapped_list) # Output: [2, 4, 6]",
                "table": null
              },
              {
                "id": "kp-5-d2",
                "kind": "example",
                "title": "Using with `filter()`",
                "text": "",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nfiltered_list = list(filter(lambda x: not x % 2, l1))\nprint(filtered_list) # Output: [2, 4, 6]",
                "table": null
              },
              {
                "id": "kp-5-d3",
                "kind": "example",
                "title": "Using with `sorted()`",
                "text": "Sorts a list of tuples based on the second element of each tuple.",
                "code": "pairs = [(1, 3), (2, 1), (3, 2)]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nprint(sorted_pairs) # Output: [(2, 1), (3, 2), (1, 3)]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Lambda functions can incorporate conditional expressions (e.g., `x if condition else y`) within their single expression.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Conditional Logic",
                "text": "This lambda returns the larger of the two arguments `x` and `y`.",
                "code": "f = lambda x, y: x if x > y else y\nprint(f(3, 7)) # Output: 7",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Functions like `map()` and `filter()` return iterators, which often need to be explicitly converted to a list or other collection type to view their contents.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "Iterator Conversion",
                "text": "Functions like `map` and `filter` return iterator objects. To view or use their contents as a list, you must explicitly convert them, typically using `list()`.",
                "code": "data = [1, 2, 3]\nmapped_iterator = map(lambda x: x*2, data)\nprint(mapped_iterator) # Output: <map object at ...>\nprint(list(mapped_iterator)) # Output: [2, 4, 6]",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-fcf6f31262",
          "exm-9ac62bbb4e",
          "exm-17c4e4022d",
          "lec-0a5f25a4f4",
          "nb-b257dde94b",
          "nb-ead5baf6cb",
          "nb-64fa3cf49c"
        ]
      }
    },
    {
      "id": "topic-immutable-mutable",
      "topic": "mutable_immutable",
      "canonical_topic": "immutable mutable",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Mutable vs immutable types",
        "mutable / immutable",
        "mutable_immutable"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-874b4592ee",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Mutable vs immutable types",
            "explanation": "Immutable: int, float, str, bool, tuple. Mutable: list, dict, set. The value of a mutable object CAN be changed in-place. The value of an immutable object CANNOT be changed \u2014 a new object must be created.",
            "code_examples": [
              {
                "description": "List is mutable \u2014 can change element in place",
                "code": "l1 = [1, 2, 3]\nprint(l1)      # [1, 2, 3]\nl1[2] = 4\nprint(l1)      # [1, 2, 4]"
              },
              {
                "description": "Tuple is immutable \u2014 assigning to index raises TypeError",
                "code": "t1 = (1, 2, 3)\nt1[2] = 4\n# TypeError: 'tuple' object does not support item assignment"
              },
              {
                "description": "String reassignment creates a NEW object, not mutation",
                "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)  # False \u2014 different object"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-368b3a2107",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[4, 1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "y = x makes y point to the same list object. Appending to y also modifies x since they reference the same list."
          },
          {
            "id": "exm-132fbfd043",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 3,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "Which of the following is immutable in Python?\n\na) list\nb) dict\nc) tuple\nd) set",
            "code_context": "",
            "options": {
              "A": "list",
              "B": "dict",
              "C": "tuple",
              "D": "set"
            },
            "correct": "C",
            "explanation": "Tuples are immutable \u2014 their elements cannot be changed after creation. Lists, dicts, and sets are mutable."
          },
          {
            "id": "exm-a1a45e4e9f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nt = (1, 2, 3)\nt[0] = 10",
            "code_context": "",
            "options": {
              "A": "(10, 2, 3)",
              "B": "(1, 2, 3)",
              "C": "TypeError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Tuples are immutable. Attempting to assign to an index raises TypeError."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-c93a09bd31",
            "week": 1,
            "cell_index": 52,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-489da644f8",
            "week": 1,
            "cell_index": 54,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-0e4cc47d59",
            "week": 1,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Mutable objects (lists, dictionaries, sets) can be changed in-place after they are created. Immutable objects (integers, floats, strings, tuples) cannot. When you assign a mutable variable to another (e.g., `list_b = list_a`), both variables point to the exact same object in memory. Therefore, modifying the object through one variable will be visible through the other.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Which of the following data types is immutable: list, dict, tuple, set?",
            "If `y = x` and `x` is a list, what happens to `x` if you append an element to `y`?",
            "Why does attempting to change an element in a tuple (e.g., `my_tuple[0] = 5`) raise a `TypeError`?",
            "What is the difference between `x = x + [4]` and `x.append(4)` for a list `x`?",
            "Does `x = y` create a copy of a list or just a new reference?",
            "How does reassignment (`x = 15`) differ from mutation (`x[0] = 15`)?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "In-place modification of a list (mutable)",
            "code": "l1 = [1, 2, 3]\nl1[2] = 4\nprint(l1)\n# Expected output: [1, 2, 4]",
            "why": "Lists are mutable, allowing their elements to be changed directly without creating a new list object.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Shared references with mutable objects",
            "code": "x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)\n# Expected output: [1, 2, 3, 4]",
            "why": "When 'y = x', both variables point to the same list object in memory. Any modification to the list through 'y' is reflected in 'x' because they share the same underlying object.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Reassignment of immutable types creates new objects",
            "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)\n\nvar_int = 100\nid1_int = id(var_int)\nvar_int = 110\nid2_int = id(var_int)\nprint(id1_int == id2_int)\n# Expected output:\n# False\n# False",
            "why": "Immutable objects like strings and integers cannot be changed. When a variable referencing an immutable object is 'modified', a new object is created with the new value, and the variable is reassigned to point to this new object, resulting in a different memory ID.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "In-place modification of mutable types retains object ID",
            "code": "var_list = [100, 110]\nid1_list = id(var_list)\nvar_list[0] = 120\nvar_list.append(130)\nid2_list = id(var_list)\nprint(id1_list == id2_list)\n\nvar_dict = {'first': 100, 'second': '110'}\nid1_dict = id(var_dict)\nvar_dict['first'] = 120\nid2_dict = id(var_dict)\nprint(id1_dict == id2_dict)\n\nvar_set = {1, '2', 3}\nid1_set = id(var_set)\nvar_set.remove(3)\nvar_set.add(4)\nid2_set = id(var_set)\nprint(id1_set == id2_set)\n# Expected output:\n# True\n# True\n# True",
            "why": "Mutable objects (lists, dictionaries, sets) can be modified without changing their memory address. Operations like element assignment, appending, or adding/removing items do not create a new object.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "Attempting to modify an immutable tuple",
            "code": "t = (1, 2, 3)\ntry:\n    t[0] = 10\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n# Expected output: Error: 'tuple' object does not support item assignment",
            "why": "Tuples are immutable, meaning their elements cannot be changed after the tuple is created. Attempting to assign a new value to an index raises a TypeError.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Immutable types in Python include integers, floats, strings, booleans, and tuples.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "table",
                "title": "Common Types Overview",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Type",
                    "Mutability"
                  ],
                  "rows": [
                    [
                      "int, float, str, bool, tuple",
                      "Immutable"
                    ],
                    [
                      "list, dict, set",
                      "Mutable"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Mutable types in Python include lists, dictionaries, and sets.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "table",
                "title": "Common mutable types",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Type",
                    "Example mutation"
                  ],
                  "rows": [
                    [
                      "list",
                      "lst.append(4)"
                    ],
                    [
                      "dict",
                      "d[\"k\"] = 10"
                    ],
                    [
                      "set",
                      "s.add(5)"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The value of a mutable object can be changed in-place without altering its memory identity.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Mutable In-place Change",
                "text": "Modifying a mutable object's content does not change its memory address.",
                "code": "my_list = [1, 2, 3]\noriginal_id = id(my_list)\nmy_list[0] = 99\nprint(my_list) # Output: [99, 2, 3]\nprint(id(my_list) == original_id) # Output: True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "When multiple variables reference the same mutable object, modifications through one variable affect all others.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Shared Mutable References",
                "text": "When two variables reference the same mutable object, changes through one affect both.",
                "code": "x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x) # Output: [1, 2, 3, 4]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "The value of an immutable object cannot be changed after creation; any operation appearing to modify it actually creates and assigns a new object.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Immutable Reassignment",
                "text": "Operations on immutable objects like strings create a new object, changing its memory address.",
                "code": "my_str = \"hello\"\noriginal_id = id(my_str)\nmy_str = my_str + \" world\"\nprint(my_str) # Output: hello world\nprint(id(my_str) == original_id) # Output: False",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Attempting to modify an immutable object, such as assigning to a tuple index, will raise a TypeError.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "TypeError for Immutable Modification",
                "text": "Attempting to change an immutable object (e.g., tuple element) will raise a TypeError.",
                "code": "my_tuple = (1, 2, 3)\ntry:\n    my_tuple[0] = 10\nexcept TypeError as e:\n    print(e) # Output: 'tuple' object does not support item assignment",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-368b3a2107",
          "exm-132fbfd043",
          "exm-a1a45e4e9f",
          "lec-874b4592ee"
        ]
      }
    },
    {
      "id": "topic-immutable-mutable-name",
      "topic": "Names",
      "canonical_topic": "name",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Mutable vs immutable types",
        "Names / variable naming rules",
        "mutable / immutable",
        "mutable_immutable",
        "mutable_immutable / names",
        "names"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-874b4592ee",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Mutable vs immutable types",
            "explanation": "Immutable: int, float, str, bool, tuple. Mutable: list, dict, set. The value of a mutable object CAN be changed in-place. The value of an immutable object CANNOT be changed \u2014 a new object must be created.",
            "code_examples": [
              {
                "description": "List is mutable \u2014 can change element in place",
                "code": "l1 = [1, 2, 3]\nprint(l1)      # [1, 2, 3]\nl1[2] = 4\nprint(l1)      # [1, 2, 4]"
              },
              {
                "description": "Tuple is immutable \u2014 assigning to index raises TypeError",
                "code": "t1 = (1, 2, 3)\nt1[2] = 4\n# TypeError: 'tuple' object does not support item assignment"
              },
              {
                "description": "String reassignment creates a NEW object, not mutation",
                "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)  # False \u2014 different object"
              }
            ]
          },
          {
            "id": "lec-054707f60d",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Names / variable naming rules",
            "explanation": "Names can consist of letters (upper/lower), digits, and underscores. Names CANNOT start with a digit. Names ARE case-sensitive (name_1 != Name_1). Avoid Python reserved words (e.g., don't name a variable 'sorted', 'list', 'print').",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-368b3a2107",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[4, 1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "y = x makes y point to the same list object. Appending to y also modifies x since they reference the same list."
          },
          {
            "id": "exm-a1a45e4e9f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nt = (1, 2, 3)\nt[0] = 10",
            "code_context": "",
            "options": {
              "A": "(10, 2, 3)",
              "B": "(1, 2, 3)",
              "C": "TypeError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Tuples are immutable. Attempting to assign to an index raises TypeError."
          },
          {
            "id": "exm-132fbfd043",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 3,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "Which of the following is immutable in Python?\n\na) list\nb) dict\nc) tuple\nd) set",
            "code_context": "",
            "options": {
              "A": "list",
              "B": "dict",
              "C": "tuple",
              "D": "set"
            },
            "correct": "C",
            "explanation": "Tuples are immutable \u2014 their elements cannot be changed after creation. Lists, dicts, and sets are mutable."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-7465f041cc",
            "week": 1,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "names",
            "source": "var_1 = 100\nvar_2 = var_1\nvar_3 = var_2\nvar_4 = var_1\nprint(id(var_1), id(var_2), id(var_3), id(var_4))\nprint(id(var_1) == id(var_2) == id(var_3) == id(var_4))\nprint(var_1 is var_2 is var_3 is var_4)",
            "outputs": []
          },
          {
            "id": "nb-632dd37679",
            "week": 1,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "names",
            "source": "var_1 = 100\nprint(id(var_1))\nvar_1 = 200\nprint(id(var_1))\ndel(var_1)\nprint(id(var_1))",
            "outputs": []
          },
          {
            "id": "nb-c93a09bd31",
            "week": 1,
            "cell_index": 52,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-489da644f8",
            "week": 1,
            "cell_index": 54,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-0e4cc47d59",
            "week": 1,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Variable names are references to objects in memory. When you execute `y = x`, both names now point to the same object. If this object is mutable (like a list), modifying it via `y` (e.g., `y.append(4)`) will also change what `x` sees. If the object is immutable (like an int), reassigning `y` (e.g., `y = 15`) simply makes `y` point to a new object, leaving `x` unaffected and still pointing to its original object."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How can you create a true, independent copy of a list instead of just a new reference?",
            "After `x = 100`, if you run `x = 200`, does the original object `100` get modified?",
            "If `y = x` where `x` is an integer, what happens to `x` when you run `y = y + 1`?",
            "If `list_b = list_a`, do `list_a` and `list_b` refer to the same object?",
            "What is the difference between the `is` operator and the `==` operator?",
            "Why might `a == b` be True while `a is b` is False for two lists?",
            "What happens if I create a variable called `list = [1, 2]`?",
            "Why do I get a `TypeError: 'list' object is not callable`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Modifying a mutable object through an alias",
            "code": "x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "why": "`y = x` makes `y` reference the same list object as `x`; appending to `y` modifies the shared list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Attempting to modify an immutable tuple",
            "code": "t = (1, 2, 3)\nt[0] = 10",
            "why": "Tuples are immutable, so assigning to an index raises a `TypeError`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "In-place modification of a mutable list",
            "code": "l1 = [1, 2, 3]\nprint(l1) # [1, 2, 3]\nl1[2] = 4\nprint(l1) # [1, 2, 4]",
            "why": "Lists are mutable, allowing elements to be changed in place without changing the object's identity.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "String reassignment creates a new object",
            "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id) # False",
            "why": "Reassigning a string variable creates a new string object and a new identity, rather than modifying the original in-place.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Multiple names referencing the same immutable integer object",
            "code": "var_1 = 100\nvar_2 = var_1\nvar_3 = var_2\nvar_4 = var_1\nprint(id(var_1), id(var_2), id(var_3), id(var_4))\nprint(id(var_1) == id(var_2) == id(var_3) == id(var_4))\nprint(var_1 is var_2 is var_3 is var_4)",
            "why": "For some immutable objects like integers, Python may optimize by having multiple names refer to the same object if their values are identical, which can be checked with `id()` and the `is` operator.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Object ID changes upon variable re-assignment",
            "code": "var_1 = 100\nprint(id(var_1))\nvar_1 = 200\nprint(id(var_1))\ndel(var_1)\n# print(id(var_1)) # This line would cause a NameError as var_1 is deleted",
            "why": "Reassigning an integer variable creates a new object with a new `id`. `del` removes the name binding, making the object inaccessible by that name.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Object ID changes for reassigned immutable types",
            "code": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2) # False\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2) # False\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2) # False\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2) # False",
            "why": "For immutable types (int, float, str, bool), changing their 'value' means creating a new object and reassigning the name to it, thus the object's identity (id) changes.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Object ID remains the same for in-place mutable type modifications",
            "code": "var_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2) # True\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2) # True\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2) # True",
            "why": "For mutable types (list, dict, set), operations that modify the object's content in place (e.g., item assignment, append, add, remove) do not change the object's identity (id).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "incorrect",
            "title": "Attempt to modify an element of an immutable tuple and check ID",
            "code": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
            "why": "Tuples are immutable; attempting to assign a new value to an index will raise a `TypeError`, preventing the code from proceeding to check `id2` and complete the comparison.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Handling TypeError when attempting to modify an immutable tuple",
            "code": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
            "why": "This code demonstrates catching the `TypeError` caused by attempting to modify an immutable tuple. The object's identity (id) remains the same because no modification or re-assignment occurs successfully.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "When one variable is assigned to another that references a mutable object, both variables point to the same object, and modifications through one variable affect the other.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Shared Reference Example",
                "text": "When a mutable object is assigned to another variable, both variables reference the same object. Modifications through one variable affect the other.",
                "code": "x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)\n# Output: [1, 2, 3, 4]",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "explanation",
                "title": "Object Identity",
                "text": "The `id()` function can be used to confirm that multiple variables refer to the same object in memory.",
                "code": "var_1 = [100]\nvar_2 = var_1\nprint(id(var_1) == id(var_2))\n# Output: True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Tuples are immutable, meaning their elements cannot be changed after creation.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Tuple Immutability",
                "text": "Attempting to change an element of a tuple results in a TypeError.",
                "code": "t = (1, 2, 3)\nt[0] = 10\n# Output: TypeError: 'tuple' object does not support item assignment",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Lists, dictionaries, and sets are mutable, allowing in-place modification of their elements.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "In-place List Modification",
                "text": "Lists are mutable and can be modified in-place.",
                "code": "l1 = [1, 2, 3]\nl1[2] = 4\nprint(l1)\n# Output: [1, 2, 4]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Immutable types in Python include int, float, str, bool, and tuple.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Common Immutable Types",
                "text": "Integers, floats, strings, booleans, and tuples are fundamental immutable types in Python. Their values cannot be changed after creation.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Mutable types in Python include list, dict, and set.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "explanation",
                "title": "Common Mutable Types",
                "text": "Lists, dictionaries, and sets are core mutable types, allowing their contents to be altered after they are initialized.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Changing the value of a mutable object occurs in-place without altering its object identity (id).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Mutable Object Identity",
                "text": "Modifying a mutable object in-place does not change its memory address (object ID).",
                "code": "my_list = [1, 2]\nid1 = id(my_list)\nmy_list.append(3)\nid2 = id(my_list)\nprint(id1 == id2)\n# Output: True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Changing the value of an immutable object requires creating a new object and reassigning the name to it, resulting in a new object identity (id).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Immutable Object Identity",
                "text": "Reassigning an immutable type like an integer or string creates a new object in memory, changing its object ID.",
                "code": "my_int = 100\nid1 = id(my_int)\nmy_int = 110\nid2 = id(my_int)\nprint(id1 == id2)\n# Output: False",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Variable names can consist of letters (upper/lower case), digits, and underscores.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "explanation",
                "title": "Valid Naming Characters",
                "text": "Variable names in Python can include lowercase letters (a-z), uppercase letters (A-Z), digits (0-9), and underscores (_).",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "Variable names cannot start with a digit.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "Invalid vs valid identifiers",
                "text": "Names cannot begin with a digit; use a leading letter or underscore.",
                "code": "# invalid: starts with a digit\n# 2value = 10\n\nvalue2 = 10\n_value = 20\nprint(value2, _value)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Python variable names are case-sensitive.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "explanation",
                "title": "Case-Sensitivity",
                "text": "Python treats variable names as case-sensitive. `myVar` and `myvar` are considered two distinct variables.",
                "code": "myVar = 10\nmyvar = 20\nprint(myVar, myvar)\n# Output: 10 20",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "Avoid using Python reserved words as variable names to prevent conflicts and errors.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "explanation",
                "title": "Avoiding Reserved Words",
                "text": "Do not use Python's reserved keywords (e.g., `list`, `print`, `for`, `if`) as variable names to prevent unexpected behavior or errors.",
                "code": "",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-368b3a2107",
          "lec-874b4592ee",
          "lec-054707f60d",
          "nb-7465f041cc",
          "nb-632dd37679"
        ]
      }
    },
    {
      "id": "topic-return",
      "topic": "Return / None",
      "canonical_topic": "return / none",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Implicit return \u2014 None",
        "Return statement",
        "global / return None",
        "multiple_returns",
        "return / None",
        "return / None / global",
        "return statement",
        "return_statement"
      ],
      "trap_patterns": [
        {
          "pattern": "Implicit return None",
          "trap": "Function without return statement, or where return is not reached, returns None. print(func()) will print None.",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        },
        {
          "pattern": "map/filter return iterables, not lists",
          "trap": "list(map(lambda x: x*2, l)) \u2014 must wrap in list(). Without it: <map object at 0x...>",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-c2c935e354",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Implicit return \u2014 None",
            "explanation": "If a function reaches the end without a return statement, Python returns None automatically. This is bad practice but you must know it. Test with: if a != None:  or  if a is not None:",
            "code_examples": [
              {
                "description": "Implicit None return",
                "code": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)  # Returns None (no return hit)\nprint(a)           # None"
              }
            ]
          },
          {
            "id": "lec-7ac5f34762",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Return statement",
            "explanation": "Returns a value to the caller. If you don't capture the return value it's lost. A function leaves no traces \u2014 local names are gone after function ends. Common error: using print() instead of return in homework functions.",
            "code_examples": [
              {
                "description": "Returning a tuple (multiple values)",
                "code": "def powers(n1):\n    return n1 ** 2, n1 ** 3  # returns a tuple\npower2, power3 = powers(3)\nprint(power2, power3)  # 9 27"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-9352bcbef8",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 14,
            "week": 3,
            "topic": "return / None",
            "question": "What is the output of the following code?\n\ndef func(x):\n    if x > 0:\n        return x\n\nprint(func(-1))",
            "code_context": "",
            "options": {
              "A": "-1",
              "B": "0",
              "C": "None",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "func(-1): condition x>0 is False, function falls through without a return statement and implicitly returns None."
          },
          {
            "id": "exm-06f3293a1e",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 10,
            "week": 3,
            "topic": "return statement",
            "question": "What is the output of the following code?\n\ndef func():\n    return 1, 2, 3\n\nresult = func()\nprint(type(result))",
            "code_context": "",
            "options": {
              "A": "<class 'list'>",
              "B": "<class 'tuple'>",
              "C": "<class 'int'>",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Returning multiple values with commas creates a tuple. type(result) is tuple."
          },
          {
            "id": "exm-63fab512ff",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 7,
            "week": 3,
            "topic": "return / None / global",
            "question": "def multiply(num1, num2):\n\tglobal result\n\tresult = num1 * num2\n\nprint(multiply(2, 3))\nprint(result)",
            "code_context": "",
            "options": {
              "a": "6\n6",
              "b": "None\n6",
              "c": "6\nNone",
              "d": "None\nNone"
            },
            "correct": "b",
            "explanation": "multiply() has no return statement, so it returns None. print(multiply(2,3)) prints None. But inside, global result is set to 6. print(result) prints 6. Output: None, 6."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-f2dcb6af3e",
            "week": 3,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    total = n1 + n2\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-fcd5ecd9a3",
            "week": 3,
            "cell_index": 17,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)\nif a != None:\n    print ('The result is: ' + a)\nelse:\n    print ('Wrong numbers')",
            "outputs": []
          },
          {
            "id": "nb-659c693cdd",
            "week": 3,
            "cell_index": 18,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    return n1 + n2\na = adder(1,2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-4e869348fc",
            "week": 3,
            "cell_index": 19,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\na = powers(3)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-af7cb6892e",
            "week": 3,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\npower2, power3 = powers(3)\nprint(power2, power3)",
            "outputs": []
          },
          {
            "id": "nb-20730924fb",
            "week": 3,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "multiple_returns",
            "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        return n1+n2\n    return n1*n2\nprint(calculator())",
            "outputs": []
          },
          {
            "id": "nb-1551629e6c",
            "week": 3,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "multiple_returns",
            "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        result = n1+n2\n    else:\n        result = n1 * n2\n    return result    \nprint(calculator())",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "A function can modify a global variable using the `global` keyword but still return `None` if it lacks an explicit `return` statement. Exam questions test this by printing the function call (which shows `None`) and then printing the modified global variable. You must track both the function's return value and its side-effect on the global state."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "In a function with an `if/else`, if only the `if` block has a `return`, what does the `else` path return?",
            "What `TypeError` might occur if a function that sometimes returns `None` is used in an expression?",
            "If a function modifies a global variable but has no `return`, what does `print(func())` show?",
            "What is the sequence of outputs for printing the function call, then the global variable?",
            "What happens if you forget the `global` keyword when trying to change a global variable?",
            "What is the return value of a method like `list.sort()` that modifies a list in-place?",
            "Can a function both modify a global variable and return a completely different value?",
            "If `my_func()` implicitly returns `None`, what is the output of `print(my_func())`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "incorrect",
            "title": "Implicit None when conditional return is not reached",
            "code": "def func_conditional_return(x):\n    if x > 0:\n        return x\nresult = func_conditional_return(-1)\nprint(result)",
            "why": "The condition `x > 0` is false for `x = -1`, so the `return x` statement is never executed. Since no other `return` statement is encountered, the function implicitly returns `None`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Implicit None when no explicit return statement is present",
            "code": "def func_no_return(a, b):\n    c = a + b\n    # No return statement\nresult = func_no_return(1, 2)\nprint(result)",
            "why": "The function `func_no_return` completes its execution without any explicit `return` statement. Therefore, Python implicitly returns `None`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Returning multiple values as a tuple and unpacking them",
            "code": "def get_multiple_values():\n    return 10, \"hello\", True\n\nresult = get_multiple_values()\nprint(f\"Result type: {type(result)}\")\nprint(f\"Result value: {result}\")\n\n# Unpacking the tuple directly into variables\nnum, text, boolean = get_multiple_values()\nprint(f\"Unpacked - Number: {num}, Text: {text}, Boolean: {boolean}\")",
            "why": "When a function specifies multiple values separated by commas in its `return` statement, Python automatically groups these values into a `tuple`. This tuple can be assigned to a single variable or unpacked into multiple variables directly.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Basic explicit return of a computed value",
            "code": "def add_numbers(a, b):\n    sum_val = a + b\n    return sum_val\n\nresult = add_numbers(5, 3)\nprint(f\"The sum is: {result}\")",
            "why": "The `return sum_val` statement explicitly sends the value of `sum_val` (8) back to the caller, where it is assigned to the `result` variable and then printed.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "Ignoring a function's return value",
            "code": "def create_message(name):\n    return f\"Hello, {name}!\"\n\ncreate_message(\"Alice\") # The return value is not captured\n# print(message) # This line would cause a NameError as 'message' was never assigned\nprint(\"Function called, but its return value was not stored.\")",
            "why": "Even though `create_message` returns a string, the caller does not assign this return value to any variable. Consequently, the returned data is immediately lost and cannot be accessed or used later in the program.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Explicitly checking for a `None` return value",
            "code": "def safe_divide(numerator, denominator):\n    if denominator == 0:\n        return None # Explicitly return None on error condition\n    return numerator / denominator\n\nresult1 = safe_divide(10, 2)\nif result1 is not None:\n    print(f\"Division result (10/2): {result1}\")\nelse:\n    print(\"Error: Division by zero occurred.\")\n\nresult2 = safe_divide(10, 0)\nif result2 is not None:\n    print(f\"Division result (10/0): {result2}\")\nelse:\n    print(\"Error: Division by zero occurred.\")",
            "why": "When a function may return `None` under specific circumstances (e.g., an invalid input or error), it is important to explicitly check if the returned value `is not None` to handle these scenarios gracefully and avoid potential `TypeError` exceptions in subsequent operations.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "If a function completes execution without encountering an explicit `return` statement, or if a conditional `return` path is not taken, it implicitly returns the `None` object.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Implicit None Return",
                "text": "If a function finishes execution without an explicit `return` statement being hit, Python automatically returns `None`.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "example",
                "title": "Conditional Return & Implicit None",
                "text": "If a condition for a return is not met, the function can implicitly return None.",
                "code": "def func(x):\n    if x > 0:\n        return x\nprint(func(-1)) # Output: None",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "A `return` statement sends a value back to the function's caller, terminating the function's execution at that point.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Basic Return Value",
                "text": "A `return` statement sends a value back to where the function was called and ends the function's execution.",
                "code": "def add(a, b):\n    return a + b\nresult = add(5, 3)\nprint(result) # Output: 8",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "When a function returns multiple values separated by commas, Python automatically packages these values into a single `tuple`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "explanation",
                "title": "Multiple Returns as Tuple",
                "text": "When you return multiple values separated by commas, Python automatically packs them into a single tuple.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Returning and Unpacking Tuples",
                "text": "",
                "code": "def powers(n):\n    return n**2, n**3\n\n# The returned tuple can be unpacked directly\npower2, power3 = powers(3)\nprint(f'{power2=}, {power3=}') # Output: power2=9, power3=27\n\n# Or captured as a single tuple variable\nresult_tuple = powers(2)\nprint(f'{result_tuple=}') # Output: result_tuple=(4, 8)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Local variables defined within a function are destroyed and become inaccessible once the function finishes executing.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Local Scope Destruction",
                "text": "Variables created inside a function are local to that function. They are destroyed and become inaccessible once the function has completed execution.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "The value returned by a function must be explicitly captured by the caller; otherwise, the returned data is lost and cannot be referenced.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Uncaptured Return Value is Lost",
                "text": "If a function's return value is not assigned to a variable or used immediately, it is lost.",
                "code": "def get_greeting():\n    return 'Hello'\n\nget_greeting() # Return value 'Hello' is not captured\n# The value is gone and cannot be accessed later.",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "It is a common error to use `print()` to display a result instead of `return` to provide a value back to the caller when a function is intended to produce an output for further use.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "explanation",
                "title": "Print vs. Return",
                "text": "`print()` displays output to the console; `return` sends a value back to the caller for further use. Functions intended to provide data should use `return`.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-6-d2",
                "kind": "example",
                "title": "Common Error: Print Instead of Return",
                "text": "",
                "code": "def func_prints(x):\n    print(x * 2)\n\ndef func_returns(x):\n    return x * 2\n\nresult_print = func_prints(5) # Prints 10, but result_print is None\nprint(f'{result_print=}')    # Output: result_print=None\n\nresult_return = func_returns(5)\nprint(f'{result_return=}') # Output: result_return=10",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "When a function might legitimately return `None`, it is considered good practice to check the return value using `if value is not None:` rather than `if value != None:`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "`is not None` vs `!= None`",
                "text": "When checking for `None`, `is not None` is generally preferred over `!= None`. `is` checks for identity (if it's the *exact* `None` object), while `!=` checks for equality.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-7-d2",
                "kind": "example",
                "title": "Checking for None Appropriately",
                "text": "",
                "code": "def safe_divide(numerator, denominator):\n    if denominator == 0:\n        return None\n    return numerator / denominator\n\nresult = safe_divide(10, 0)\n\nif result is not None:\n    print(f'Result: {result}')\nelse:\n    print('Cannot divide by zero')",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-9352bcbef8",
          "exm-63fab512ff",
          "exm-06f3293a1e",
          "lec-c2c935e354",
          "lec-7ac5f34762",
          "nb-f2dcb6af3e",
          "nb-fcd5ecd9a3",
          "nb-af7cb6892e",
          "nb-4e869348fc"
        ]
      }
    },
    {
      "id": "topic-conversion",
      "topic": "Type Conversion",
      "canonical_topic": "type conversion",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Type conversion (explicit)",
        "type conversion",
        "type conversion / indexing",
        "type_conversion",
        "type_conversion / dict"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-47086e180a",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Type conversion (explicit)",
            "explanation": "Python requires explicit conversion in most cases (unlike JavaScript). Conversion functions: str(), int(), float(), bool(), tuple(), list(), set(), dict().",
            "code_examples": [
              {
                "description": "Explicit conversions",
                "code": "print(str(1) == '1')           # True\nprint(int('1') == 1)           # True\nprint(int('1a'))               # ERROR\nprint(float('1') == 1.0)       # True\nprint(float('1.0') == 1.0)     # True\nprint(tuple([1,2,3]) == (1,2,3)) # True\nprint(tuple({1:3, 2:4}) == (1,2)) # True (dict->tuple gives keys)\nprint(list(range(1,5,2)) == [1,3]) # True\nprint(dict([1, 2]))            # ERROR\nprint(dict([(1,3),(2,4)]) == {1:3, 2:4})  # True"
              },
              {
                "description": "Implicit conversion (Python allows with bool/numeric mix)",
                "code": "print(1 + True)    # 2\nprint(1.0 + False) # 1.0\nprint('1' * 2)     # '11'\nprint('1' * True)  # '1'\nprint('1' * False) # ''"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-db07780cd0",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 3,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nx = '5'\ny = 2\nprint(x * y)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "52",
              "C": "55",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "String * integer repeats the string. '5' * 2 = '55'."
          },
          {
            "id": "exm-edec745151",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 5,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nprint(int('42') + float('3.5'))",
            "code_context": "",
            "options": {
              "A": "45",
              "B": "45.5",
              "C": "'423.5'",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "int('42')=42, float('3.5')=3.5. 42 + 3.5 = 45.5."
          },
          {
            "id": "exm-bd5df4659c",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 11,
            "week": 1,
            "topic": "type conversion / indexing",
            "question": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\n\nWhat is the output of the following code snippet?\n\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
            "code_context": "",
            "options": {
              "a": "SyntaxError",
              "b": "IndexError: list index out of range",
              "c": "False",
              "d": "True"
            },
            "correct": "d",
            "explanation": "x[2] = (1,2). x[2][0]=1, x[2][1]=2. 1+2=3. float(3)=3.0. type(3.0)=float. x[-2]=3.0 (index 5). type(3.0)=float. float==float \u2192 True."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-8ea9af8f8b",
            "week": 1,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(int('123'))\nprint(float('123'))\n\nprint(str(123))\nprint(float(123))\n\nprint(int(123.0))\nprint(str(123.0))",
            "outputs": []
          },
          {
            "id": "nb-c488bc51d9",
            "week": 1,
            "cell_index": 24,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "integer_list = [1, 2, 3, 1]\nletter_list = ['a', 'b', 'c', 'd']\nprint(set(integer_list))\nprint(tuple(integer_list))\nprint(dict(zip(letter_list, integer_list)))\n\ninteger_tuple = (1, 2, 3, 1)\nletter_tuple = ('a', 'b', 'c', 'd')\nprint(set(integer_tuple))\nprint(list(integer_tuple))\nprint(dict(zip(letter_tuple, integer_tuple)))\n\ninteger_set = {1, 2, 3}\nletter_set = {'a', 'b', 'c'}\nprint(list(integer_set))\nprint(tuple(letter_set))\nprint(dict(zip(integer_set, letter_set)))\n\nd_1 = {1: 'c', 2: 'b', 3: 'a'}\nprint(list(d_1))\nprint(tuple(d_1))\nprint(set(d_1))",
            "outputs": []
          },
          {
            "id": "nb-b60399a503",
            "week": 2,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1 + True, 1.0 + False, True + False)",
            "outputs": []
          },
          {
            "id": "nb-01f6077d4d",
            "week": 2,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1==1.0, 1.0 == True, 0 == False)",
            "outputs": []
          },
          {
            "id": "nb-3f066f26aa",
            "week": 2,
            "cell_index": 106,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print ('1' * 2, '1' * True, '1' * False)",
            "outputs": []
          },
          {
            "id": "nb-a358f49009",
            "week": 2,
            "cell_index": 114,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print ('1' + 2)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-3bd8e4f40b",
            "week": 2,
            "cell_index": 117,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(str(1) == '1')\nprint(int('1') == 1)",
            "outputs": []
          },
          {
            "id": "nb-614c69b0f2",
            "week": 2,
            "cell_index": 118,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(float('1') == 1.0)\nprint(float('1.0') == 1.0)  \nprint(tuple([1,2,3]) == (1,2,3))  \nprint(tuple({1:3, 2:4}) == (1,2))  \nprint(dict([(1,3), (2,4)]) == {1: 3, 2:4})",
            "outputs": []
          },
          {
            "id": "nb-4a7fe9bef0",
            "week": 2,
            "cell_index": 119,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(int('1a') == 1)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-66deb9932d",
            "week": 2,
            "cell_index": 120,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(dict([1, 2]))\nexcept Exception as e:\n    print(e)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Explicit type conversion is changing a value's data type using functions like `int()`, `float()`, `str()`, and `list()`. This is fundamental in Python, as operations between incompatible types (like adding a string to an integer) will raise a `TypeError` unless one is converted. Be aware that some conversions, like `int('4.5')`, are invalid and will raise a `ValueError`, while others, like `int(4.5)`, will truncate"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "When you convert a dictionary to a list using `list()`, what does the resulting list contain?",
            "How do you properly convert a string with a decimal (e.g., '25.5') into an integer?",
            "Why does `int('10.0')` raise a `ValueError` but `float('10.0')` works?",
            "What is the key difference between `'4' * 3` and `int('4') * 3`?",
            "What is the boolean value of an empty list (`bool([])`)?",
            "What is the result of `int(9.9)`?",
            "Can `True` be used in an arithmetic operation? (Yes, `True` is 1, `False` is 0)",
            "What happens if you call `dict()` on a list where an inner item isn't a pair?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic String to Numeric Conversion and Addition",
            "code": "print(int('42') + float('3.5'))",
            "why": "`int('42')` converts the string to the integer `42`, and `float('3.5')` converts the string to the float `3.5`. Their sum is `45.5`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "String Repetition with Integer and Boolean Multipliers",
            "code": "x = '5'\ny = 2\nprint(x * y)\nprint('A' * True)\nprint('B' * False)",
            "why": "Multiplying a string by an integer repeats the string that many times. Booleans `True` and `False` are implicitly treated as `1` and `0` respectively in multiplication.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Implicit Boolean Conversion in Arithmetic",
            "code": "print(1 + True)",
            "why": "`True` is implicitly converted to the integer `1` when used in arithmetic operations, so `1 + 1` evaluates to `2`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "incorrect",
            "title": "Invalid String to Integer Conversion (ValueError)",
            "code": "print(int('1a'))",
            "why": "The string '1a' cannot be converted into a valid integer, as it contains non-digit characters, leading to a `ValueError`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "Invalid Dictionary Construction (ValueError)",
            "code": "print(dict([1, 2]))",
            "why": "The `dict()` constructor expects an iterable of key-value pairs (e.g., `[(key, value)]`), not single elements. Providing an incorrect format results in a `ValueError`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "incorrect",
            "title": "Adding String and Integer (TypeError)",
            "code": "print('1' + 2)",
            "why": "Python does not implicitly convert an integer to a string for concatenation, nor does it convert a string to an integer for addition. Attempting direct addition between these dissimilar types results in a `TypeError`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Dictionary to Tuple Conversion Extracts Keys",
            "code": "print(tuple({1:3, 2:4}))",
            "why": "When a dictionary is converted to a tuple (or list/set), only its keys are extracted and form the elements of the new collection.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "List to Set Conversion Removes Duplicates",
            "code": "integer_list = [1, 2, 3, 1]\nprint(set(integer_list))",
            "why": "Sets inherently store only unique elements. Converting a list containing duplicates to a set will remove the repeated elements.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Comparison of Numeric and Boolean Values",
            "code": "print(1 == 1.0)\nprint(1.0 == True)\nprint(0 == False)",
            "why": "Python allows direct comparison between different numeric types, including booleans which are implicitly treated as `0` for `False` and `1` for `True`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Python typically requires explicit type conversion using built-in functions like `str()`, `int()`, `float()`, `bool()`, `tuple()`, `list()`, `set()`, and `dict()`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Basic Type Conversions",
                "text": "",
                "code": "print(str(1))\nprint(int('1'))\nprint(float('1.0'))\nprint(tuple([1,2,3]))\nprint(list(range(1,5,2)))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`int()` converts valid string representations of integers to integers, and `float()` converts valid string representations of numbers (or other numeric types) to floats.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "String to Numeric Conversion",
                "text": "Valid string representations can be converted to integers or floats.",
                "code": "print(int('42'))\nprint(float('3.5'))\nprint(int('42') + float('3.5'))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Attempting to convert a string that does not represent a valid numeric value using `int()` or `float()` will raise a `ValueError`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "explanation",
                "title": "ValueError on Invalid Conversion",
                "text": "Attempting to convert a non-numeric string to an integer or float will raise a ValueError.",
                "code": "try:\n    print(int('1a'))\nexcept ValueError as e:\n    print(e)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "When a dictionary is converted to `tuple`, `list`, or `set`, the resulting collection contains only the original dictionary's keys.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Dict to Collection (Keys Only)",
                "text": "Converting a dictionary to a tuple, list, or set will result in a collection of its keys.",
                "code": "my_dict = {1:3, 2:4}\nprint(tuple(my_dict))\nprint(list(my_dict))\nprint(set(my_dict))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "The `dict()` constructor requires an iterable of key-value pairs (e.g., `[(key, value)]`) to successfully create a dictionary; incorrect formats will raise a `ValueError`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "dict() Constructor Requirements",
                "text": "The dict() constructor needs an iterable of key-value pairs (tuples or lists).",
                "code": "print(dict([(1,3),(2,4)]))\ntry:\n    print(dict([1, 2]))\nexcept ValueError as e:\n    print(e)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "In arithmetic operations and numeric comparisons, Python implicitly treats `True` as `1` and `False` as `0`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "explanation",
                "title": "Booleans as Numbers",
                "text": "In numeric contexts, True is treated as 1 and False as 0.",
                "code": "print(1 + True) # Output: 2\nprint(1.0 + False) # Output: 1.0\nprint(True + False) # Output: 1\nprint(1 == True) # Output: True\nprint(0 == False) # Output: True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Multiplying a string by an integer or a boolean results in the string being repeated, with `True` acting as `1` and `False` as `0` for the multiplier.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "String Repetition with Booleans",
                "text": "Multiplying a string by a boolean repeats the string, treating True as 1 and False as 0.",
                "code": "print('1' * 2) # Output: '11'\nprint('1' * True) # Output: '1'\nprint('1' * False) # Output: ''",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Directly performing addition between a string and a numeric type (integer or float) without explicit conversion will result in a `TypeError`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "explanation",
                "title": "TypeError: String + Number",
                "text": "Directly adding a string and a numeric type without explicit conversion raises a TypeError.",
                "code": "try:\n    print('1' + 2)\nexcept TypeError as e:\n    print(e)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "Converting an iterable (like a list or tuple) to a `set` will automatically remove duplicate elements, storing only unique values.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "Set Conversion Removes Duplicates",
                "text": "Converting an iterable to a set automatically removes duplicate elements, keeping only unique values.",
                "code": "integer_list = [1, 2, 3, 1]\nprint(set(integer_list))\ninteger_tuple = (1, 2, 3, 1)\nprint(set(integer_tuple))",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-db07780cd0",
          "exm-edec745151",
          "lec-47086e180a",
          "nb-3f066f26aa",
          "nb-b60399a503",
          "nb-a358f49009",
          "nb-c488bc51d9",
          "nb-614c69b0f2"
        ]
      }
    },
    {
      "id": "topic-object",
      "topic": "Objects",
      "canonical_topic": "object",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "Object types \u2014 the 8 types to know",
        "Objects/types",
        "Objects: core properties",
        "objects",
        "objects / identity",
        "objects / type / is vs ==",
        "objects / types"
      ],
      "trap_patterns": [
        {
          "pattern": "Slicing creates a NEW object",
          "trap": "l2=l1 vs l2=l1[:] \u2014 l2=l1 shares the SAME object, slicing creates independent copy",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023",
            "midterm_2024",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-03d78ccf62",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Object types \u2014 the 8 types to know",
            "explanation": "int, float, str, bool, tuple, list, dict, set",
            "code_examples": [
              {
                "description": "All 8 types",
                "code": "var_1 = 123              # int\nvar_2 = 123.3            # float\nvar_3 = '123'            # str\nvar_4 = True             # bool\nvar_5 = ('123', 123)     # tuple\nvar_6 = [123, '123']     # list\nvar_7 = {'k1': 'v1'}     # dict\nvar_8 = {123, '123'}     # set"
              }
            ]
          },
          {
            "id": "leq-eb2764fa14",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Objects/types",
            "question": "Which of the following statements is correct? I: Two objects can have different values, while having the same type. II: Two objects can have the same value, while having different types.",
            "options": {
              "a": "I is correct",
              "b": "II is correct",
              "c": "I and II are both correct",
              "d": "Neither is correct"
            },
            "correct": "a",
            "explanation": "I is correct (e.g. a=1, b=2, both int). II is incorrect \u2014 if two objects have the same value they must have the same type."
          },
          {
            "id": "lec-8c4ac0f026",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Objects: core properties",
            "explanation": "Every object has exactly one unique id (cannot change), exactly one type (cannot change), and exactly one value. The type defines what value can be stored and whether the value is mutable or immutable. An object can have zero, one, or more names bound to it. A name can only refer to one object at any time.",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-ab87bba39e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 1,
            "week": 1,
            "topic": "objects / types",
            "question": "What is the output of the following code?\n\nprint(type(True))",
            "code_context": "",
            "options": {
              "A": "<class 'int'>",
              "B": "<class 'bool'>",
              "C": "<class 'str'>",
              "D": "<class 'NoneType'>"
            },
            "correct": "B",
            "explanation": "True is of type bool in Python."
          },
          {
            "id": "exm-58c16c860b",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 1,
            "week": 1,
            "topic": "objects / identity",
            "question": "What is the output of the following code?\n\nx = 257\ny = 257\nprint(x is y)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "For integers outside the range [-5, 256], Python does not guarantee interning. Two separate 257 literals are different objects, so 'is' returns False."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-ebb2df2e4e",
            "week": 1,
            "cell_index": 11,
            "cell_type": "markdown",
            "topic": "objects",
            "source": "### Everything in Python is an object. Objects in Python have one id, one value, one type, and zero or more names\n<br>An assignment statement is one of the ways to create an object. An object created with an assignment statement will have a name, an id, a value and a type.\n<br>If you know the name you can ask for the id, the value, and the type",
            "outputs": []
          },
          {
            "id": "nb-522899bb07",
            "week": 1,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "objects",
            "source": "a = 1\nprint(id(a))\nprint(a)\nprint(type(a))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Every value in Python is an object with a unique ID, a fixed type, and a value. The `is` operator checks if two variables point to the exact same object (comparing their IDs), while `==` checks if their values are equal. For output questions, pay close attention to whether the code uses `is` or `==`, especially with mutable types like lists or integers outside the range of -5 to 256, where Python creates separate ob"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the key difference between the `is` operator and the `==` operator?",
            "Will `x is y` be `True` or `False` for large integers or strings?",
            "If `a == b` is true, does that guarantee `a is b` is also true?",
            "Are lists mutable or immutable? What about tuples and strings?",
            "What is the difference between the `is` and `==` operators?",
            "Can an object's ID or type change after it is created?",
            "If `list2 = list1[:]`, are they one object or two?",
            "Why might `a = 257; b = 257; a is b` be `False`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Identifying Boolean Type",
            "code": "print(type(True))",
            "why": "`True` is an instance of the `bool` type in Python.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "`is` operator with large integers",
            "code": "x = 257\ny = 257\nprint(x is y)",
            "why": "Python does not guarantee interning for integers outside [-5, 256]. Therefore, `x` and `y` can refer to different object instances, resulting in `False` when comparing identity with `is`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Python's 8 Core Object Types",
            "code": "var_1 = 123       # int\nvar_2 = 123.3     # float\nvar_3 = '123'     # str\nvar_4 = True      # bool\nvar_5 = ('123', 123) # tuple\nvar_6 = [123, '123'] # list\nvar_7 = {'k1': 'v1'} # dict\nvar_8 = {123, '123'} # set",
            "why": "This snippet illustrates the creation and assignment of variables to instances of Python's eight fundamental built-in object types.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Retrieving Object ID, Value, and Type",
            "code": "a = 1\nprint(id(a))\nprint(a)\nprint(type(a))",
            "why": "Demonstrates how to access the unique identity (`id`), the current value, and the type (`type`) of an object.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "incorrect",
            "title": "List Assignment vs. Slicing for Object Identity",
            "code": "list1 = [1, 2, 3]\nlist2 = list1\nlist3 = list1[:]\n\nprint(list1 is list2) # True, same object\nprint(list1 is list3) # False, new object",
            "why": "Assigning `list2 = list1` makes `list2` a new name referencing the *same* object as `list1`. Slicing `list1[:]` creates a *new*, independent list object, so `list3` is a distinct object from `list1`.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Every object in Python has a unique, unchanging ID, an unchanging type, and a specific value.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Object Properties",
                "text": "Use `id()`, `type()`, and direct access to view an object's unique identifier, type, and value.",
                "code": "a = 10\nprint(f\"ID: {id(a)}\")\nprint(f\"Type: {type(a)}\")\nprint(f\"Value: {a}\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "An object's type determines its permissible values and whether it is mutable or immutable.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Type & Mutability",
                "text": "An object's type dictates the kind of values it can store and whether its contents can be altered after creation (mutable) or not (immutable).",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "An object can be referenced by multiple names, but each name refers to only one object at a time.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Multiple Names, One Object",
                "text": "Multiple variables can refer to the same object in memory. Modifications made through one name will be visible via all names referencing that object.",
                "code": "x = [1, 2]\ny = x\ny.append(3)\nprint(x) # Output: [1, 2, 3]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Assignment statements are a primary mechanism for creating and naming objects.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Assignment Creates Objects",
                "text": "An assignment statement like `variable = value` is a fundamental way to create an object and bind a name (the variable) to it.",
                "code": "my_string = \"Python Exam\"",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Python includes 8 core built-in object types: int, float, str, bool, tuple, list, dict, and set.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "table",
                "title": "8 Core Built-in Types",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Type",
                    "Example"
                  ],
                  "rows": [
                    [
                      "int",
                      "10"
                    ],
                    [
                      "float",
                      "10.5"
                    ],
                    [
                      "str",
                      "'hello'"
                    ],
                    [
                      "bool",
                      "True"
                    ],
                    [
                      "tuple",
                      "(1, 2)"
                    ],
                    [
                      "list",
                      "[1, 2]"
                    ],
                    [
                      "dict",
                      "{'a': 1}"
                    ],
                    [
                      "set",
                      "{1, 2}"
                    ]
                  ]
                }
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Objects with identical values must also have identical types.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "explanation",
                "title": "Value and Type Distinction",
                "text": "While `5 == 5.0` (numerical equality) is True, `5` (an `int`) and `5.0` (a `float`) are distinct objects with different types. The `is` operator confirms they are not the same object: `5 is 5.0` is False.",
                "code": "print(type(5) == type(5.0)) # False\nprint(5 == 5.0)          # True\nprint(5 is 5.0)          # False",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "For integers outside the range [-5, 256], Python does not guarantee object interning, meaning `is` may report different objects even for identical literal values.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "example",
                "title": "Integer Interning Range",
                "text": "Python often 'interns' small integers (typically -5 to 256), meaning identical literals refer to the same object. Outside this range, new objects might be created, making `is` return `False`.",
                "code": "x = 257\ny = 257\nprint(x is y) # Often False\n\na = 10\nb = 10\nprint(a is b) # True",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Slicing a sequence (e.g., `l1[:]`) creates a new, independent object, while direct assignment (e.g., `l2 = l1`) makes a new name refer to the original object.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "Slicing vs. Assignment Copying",
                "text": "Direct assignment (`l2 = l1`) makes a new name point to the existing object. Slicing (`l3 = l1[:]`) creates a new, independent (shallow) copy of the object.",
                "code": "l1 = [1, 2, 3]\nl2 = l1       # l2 and l1 refer to the same list\nl3 = l1[:]    # l3 is a new list with same elements as l1\n\nprint(l1 is l2) # True\nprint(l1 is l3) # False",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-ab87bba39e",
          "exm-58c16c860b",
          "lec-8c4ac0f026",
          "lec-03d78ccf62",
          "nb-ebb2df2e4e",
          "nb-522899bb07",
          "leq-eb2764fa14"
        ]
      }
    },
    {
      "id": "topic-zip",
      "topic": "Zip",
      "canonical_topic": "zip",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "dictionaries / zip / counting",
        "dictionary / zip",
        "enumerate",
        "enumerate()",
        "zip",
        "zip / enumerate",
        "zip / looping",
        "zip()"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) \u2014 second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          },
          {
            "id": "lec-bff7a8929a",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "zip()",
            "explanation": "Loops over multiple sequences in parallel. Zips sequences of equal length (Python handles unequal lengths but it can be messy). Can zip sequences of different types. Can zip more than 2.",
            "code_examples": [
              {
                "description": "zip two lists",
                "code": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(country, 'has capital:', capital)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-ba031912fa",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 16,
            "week": 2,
            "topic": "zip / looping",
            "question": "What is the output of the following code?\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
            "code_context": "",
            "options": {
              "A": "Alice: 85\nBob: 92\nCharlie: 78",
              "B": "Alice: 92\nBob: 85\nCharlie: 78",
              "C": "Alice Bob Charlie: 85 92 78",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "zip pairs elements positionally. Output: Alice: 85, Bob: 92, Charlie: 78."
          },
          {
            "id": "exm-f6de891c85",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 5,
            "week": 2,
            "topic": "dictionaries / zip / counting",
            "question": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\nYou need to create a dictionary called grade_counts that counts the number of students in each grade level.\n\nExpected: {9:3, 10:2, 11:1}\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "grade_counts = {}\nfor grade in grades:\n\tif grade not in grade_counts:\n\t\tgrade_counts[grade] = 0\n\tgrade_counts[grade] += 1",
              "b": "grade_counts = {}\nfor student, grade in zip(students, grades):\n\tif grade in grade_counts:\n\t\tgrade_counts[grade].append(student)\n\telse:\n\t\tgrade_counts[grade] = [student]",
              "c": "Both of the given options will work as intended.",
              "d": "Neither of the given options will work as intended."
            },
            "correct": "a",
            "explanation": "Option a correctly counts grades: initialises to 0 and increments. Produces {9:3, 10:2, 11:1}. Option b creates lists of student names, not counts \u2014 produces {9:['A','C','F'], 10:['B','E'], 11:['D']}, not the required format. Correct: a."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          },
          {
            "id": "nb-a88380d21a",
            "week": 2,
            "cell_index": 92,
            "cell_type": "code",
            "topic": "zip",
            "source": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(f'country {country} has capital: {capital}')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `zip()` function combines multiple iterables (like lists or strings) into a single iterator of tuples. Each tuple contains elements from the input iterables at the same position. `zip()` stops when the shortest input iterable is exhausted, so be mindful of lists with unequal lengths in output questions."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How do you convert the result of `zip()` into a list or a dictionary?",
            "What is the data type of the object that `zip()` returns?",
            "What happens when you `zip` lists of different lengths?",
            "What is the output of `list(zip('hi', [1, 2, 3]))`?",
            "What will `dict(zip(keys, values))` produce?",
            "Can you `unzip` a list of tuples?",
            "Write a one-line expression to create a dictionary from a `keys` list and a `values` list.",
            "What is the value of the index and the item at each step of an `enumerate` loop?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic positional pairing with `zip()` in a loop",
            "code": "names = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')\n# Expected output:\n# Alice: 85\n# Bob: 92\n# Charlie: 78",
            "why": "`zip()` iterates over `names` and `scores` in parallel, yielding (name, score) tuples based on their position until one of the lists is exhausted.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "incorrect",
            "title": "Using `zip()` to incorrectly count occurrences when building a dictionary",
            "code": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\ngrade_counts = {}\nfor student, grade in zip(students, grades):\n    if grade in grade_counts:\n        grade_counts[grade].append(student)\n    else:\n        grade_counts[grade] = [student]\n# Actual output: {9: ['A', 'C', 'F'], 10: ['B', 'E'], 11: ['D']}",
            "why": "This code uses `zip()` to iterate through `students` and `grades`, but it incorrectly constructs a dictionary where keys are grades and values are *lists of students* associated with that grade, rather than a numerical count of students per grade. To count occurrences, the `student` variable from the `zip` iteration is not needed, and the value associated with each grade key should be an integer count, incremented directly.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The built-in `zip()` function pairs elements positionally from multiple input sequences.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Basic Positional Pairing",
                "text": "Elements are paired based on their position from each input sequence.",
                "code": "names = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')\n# Output:\n# Alice: 85\n# Bob: 92\n# Charlie: 78",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`zip()` can combine sequences of different data types.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Combining Different Data Types",
                "text": "`zip()` can combine sequences of different data types, such as strings and integers as demonstrated in the basic pairing example for `names` and `scores`.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`zip()` can combine more than two input sequences.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Zipping More Than Two Sequences",
                "text": "The `zip()` function can accept and combine any number of input sequences, not just two.",
                "code": "names = ['Alice', 'Bob']\nages = [25, 30]\ncities = ['New York', 'London']\nfor name, age, city in zip(names, ages, cities):\n    print(f'{name} ({age}) lives in {city}')\n# Output:\n# Alice (25) lives in New York\n# Bob (30) lives in London",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "When input sequences have unequal lengths, `zip()` stops generating pairs when the shortest sequence is exhausted.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Unequal Sequence Lengths",
                "text": "When input sequences have different lengths, `zip()` stops pairing elements once the shortest sequence is exhausted. Elements from longer sequences beyond this point are ignored.",
                "code": "short_list = [1, 2]\nlong_list = ['a', 'b', 'c', 'd']\nfor num, char in zip(short_list, long_list):\n    print(f'{num}: {char}')\n# Output:\n# 1: a\n# 2: b",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`zip()` is useful for iterating over multiple sequences to construct other data structures, such as dictionaries.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Iterative Dictionary Construction",
                "text": "`zip()` is useful for iterating over two sequences (e.g., keys and values) to build a dictionary programmatically.",
                "code": "students = ['A', 'B', 'C']\ngrades = [9, 10, 9]\nstudent_grades = {}\nfor student, grade in zip(students, grades):\n    student_grades[student] = grade\nprint(student_grades)\n# Output: {'A': 9, 'B': 10, 'C': 9}",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-ba031912fa",
          "exm-f6de891c85",
          "lec-bff7a8929a",
          "lec-ca6bf752eb",
          "nb-a88380d21a",
          "nb-6d22b8d418",
          "nb-87216389d2"
        ]
      }
    },
    {
      "id": "topic-assignment-augmented",
      "topic": "Assignment",
      "canonical_topic": "assignment",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2024": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "Assignment statements \u2014 reading right to left",
        "Augmented assignment operators",
        "assignment",
        "augmented operators",
        "augmented_operators"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8f40fb5984",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Assignment statements \u2014 reading right to left",
            "explanation": "Python creates a new object with the value on the right, infers type from the value, then binds the name on the left to that object.",
            "code_examples": [
              {
                "description": "Basic assignment",
                "code": "name_1 = 300\nprint(name_1)        # 300\nprint(type(name_1))  # <class 'int'>\nprint(id(name_1))    # some unique integer"
              },
              {
                "description": "Two names bound to the same object (same id)",
                "code": "name_3 = name_4 = name_5 = name_6 = 300\nprint(name_3 is name_4 is name_5 is name_6)  # True"
              },
              {
                "description": "Two separate objects with equal value (different id)",
                "code": "name_1 = 300\nname_2 = 300\nprint(name_1 == name_2)           # True (same value)\nprint(id(name_1) != id(name_2))   # True (different objects)"
              }
            ]
          },
          {
            "id": "lec-18dd567530",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Augmented assignment operators",
            "explanation": "Shorthand for a = a OP b. All arithmetic operators have an augmented form.",
            "code_examples": [
              {
                "description": "All augmented operators",
                "code": "a += 1   # a = a + 1\na -= 2   # a = a - 2\na *= 3   # a = a * 3\na /= 4   # a = a / 4\na //= 5  # a = a // 5\na %= 6   # a = a % 6"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-970620e487",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 6,
            "week": 2,
            "topic": "augmented operators",
            "question": "What is the output of the following code?\n\nx = 10\nx //= 3\nprint(x)",
            "code_context": "",
            "options": {
              "A": "3",
              "B": "3.33",
              "C": "4",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "//= is floor division assignment. 10 // 3 = 3."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-1efd2c6579",
            "week": 1,
            "cell_index": 14,
            "cell_type": "code",
            "topic": "assignment",
            "source": "a = 100\nb = 200\nc = 300\nd, e, f = a, b, c\nprint(a, b, c)\nprint(d, e, f)",
            "outputs": []
          },
          {
            "id": "nb-3642142eff",
            "week": 1,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "assignment",
            "source": "a = 100\nb = 200\nc = 300\nprint(a, b, c)\nb, c, a = a, b, c \nprint(a, b, c)",
            "outputs": []
          },
          {
            "id": "nb-49999b1411",
            "week": 2,
            "cell_index": 3,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 1 \na += 1\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-34ac437319",
            "week": 2,
            "cell_index": 4,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 1 \na = a + 1\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-c120563f18",
            "week": 2,
            "cell_index": 6,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 2\na -= 2\nprint(a)\n\na=3\na *= 3\nprint(a)\n\na = 5\na /= 4\nprint(a)\n\na = 6\na //= 5\nprint(a)\n\na = 7\na %= 6\nprint(a)\n\na = 8\na **= 7\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Augmented assignment operators like `+=`, `-=`, `*=`, `//=`, and `%=` are shortcuts for performing an operation and assignment in one step. For example, `x //= 3` is equivalent to `x = x // 3`. For exam questions, pay close attention to the specific operator, especially the difference between true division (`/=`), which produces a float, and floor division (`//=`), which produces an integer."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Predict the output of a sequence of different augmented assignments.",
            "What happens when you use `*=` on a string (e.g., `s *= 3`)?",
            "Rewrite `a = a % b` using an augmented assignment operator.",
            "What is the difference between `x /= 2` and `x //= 2`?",
            "Does `+=` work on strings and lists? If so, how?",
            "What is the final value of `x` after `x //= 3`?",
            "What are the values of `a`, `b`, and `c` after a tuple assignment or swap?",
            "What is the final value of a variable after a series of reassignments?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Basic integer assignment and object details",
            "code": "name_1 = 300\nprint(name_1)\nprint(type(name_1))\nprint(id(name_1))",
            "why": "Demonstrates basic assignment, type inference, and unique object ID.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Chained assignment results in shared object identity",
            "code": "name_3 = name_4 = name_5 = name_6 = 300\nprint(name_3 is name_4 is name_5 is name_6)",
            "why": "All variables in a chained assignment refer to the exact same object in memory.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Separate assignments for equal values may create distinct objects",
            "code": "name_1 = 300\nname_2 = 300\nprint(name_1 == name_2) # Checks for value equality\nprint(id(name_1) != id(name_2)) # Checks for object identity inequality",
            "why": "Although values are equal, separate assignments often create distinct objects for numbers outside small integer caching range, or for mutable types.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Multiple assignment for sequential values",
            "code": "a = 100\nb = 200\nc = 300\nd, e, f = a, b, c\nprint(a, b, c)\nprint(d, e, f)",
            "why": "Demonstrates assigning multiple variables in one line from existing variables.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Swapping values using multiple assignment",
            "code": "a = 100\nb = 200\nc = 300\nprint(f\"Initial: a={a}, b={b}, c={c}\")\nb, c, a = a, b, c\nprint(f\"Swapped: a={a}, b={b}, c={c}\")",
            "why": "Illustrates an efficient way to swap variable values without a temporary variable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Floor division assignment (`//=`)",
            "code": "x = 10\nx //= 3\nprint(x)",
            "why": "The `//=` operator performs floor division (10 // 3 = 3) and assigns the result to `x`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Augmented addition assignment (`+=`)",
            "code": "a = 1\na += 1\nprint(a)",
            "why": "Equivalent to `a = a + 1`, resulting in `a` being `2`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Augmented subtraction assignment (`-=`)",
            "code": "a = 2\na -= 2\nprint(a)",
            "why": "Equivalent to `a = a - 2`, resulting in `a` being `0`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "correct",
            "title": "Augmented multiplication assignment (`*=`)",
            "code": "a = 3\na *= 3\nprint(a)",
            "why": "Equivalent to `a = a * 3`, resulting in `a` being `9`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-10",
            "kind": "correct",
            "title": "Augmented division assignment (`/=`)",
            "code": "a = 5\na /= 4\nprint(a)",
            "why": "Equivalent to `a = a / 4`, resulting in `a` being `1.25` (float division).",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-11",
            "kind": "correct",
            "title": "Augmented modulo assignment (`%=`)",
            "code": "a = 7\na %= 6\nprint(a)",
            "why": "Equivalent to `a = a % 6`, resulting in `a` being `1`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-12",
            "kind": "correct",
            "title": "Augmented exponentiation assignment (`**=`)",
            "code": "a = 8\na **= 7\nprint(a)",
            "why": "Equivalent to `a = a ** 7`, resulting in `a` being `2097152`.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-13",
            "kind": "correct",
            "title": "Expanded form of augmented assignment (`a = a + 1`)",
            "code": "a = 1\na = a + 1\nprint(a)",
            "why": "This demonstrates the longer form that augmented assignment operators (`+=`) condense.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Python processes assignment by evaluating the right-hand side, creating a new object, inferring its type, and then binding the left-hand name to that object.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "explanation",
                "title": "Assignment Process",
                "text": "Python evaluates the RHS, creates a new object, infers its type, then binds the LHS name to that object.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-1-d2",
                "kind": "example",
                "title": "Basic Assignment",
                "text": "",
                "code": "name_1 = 300\nprint(name_1)\nprint(type(name_1))\nprint(id(name_1))",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Augmented assignment operators provide a shorthand `a OP= b` for operations like `a = a OP b` for various arithmetic operators.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "explanation",
                "title": "Shorthand",
                "text": "Augmented assignment `a OP= b` is a shorthand for `a = a OP b`.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "All standard arithmetic operators, including `+`, `-`, `*`, `/`, `//`, `%`, and `**`, have corresponding augmented assignment forms (`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "table",
                "title": "Augmented Operators",
                "text": "",
                "code": "",
                "table": {
                  "headers": [
                    "Operator",
                    "Long Form"
                  ],
                  "rows": [
                    [
                      "+=",
                      "a = a + b"
                    ],
                    [
                      "-=",
                      "a = a - b"
                    ],
                    [
                      "*=",
                      "a = a * b"
                    ],
                    [
                      "/=",
                      "a = a / b"
                    ],
                    [
                      "//=",
                      "a = a // b"
                    ],
                    [
                      "%=",
                      "a = a % b"
                    ],
                    [
                      "**=",
                      "a = a ** b"
                    ]
                  ]
                }
              },
              {
                "id": "kp-3-d2",
                "kind": "example",
                "title": "Augmented Operator Use",
                "text": "",
                "code": "a = 10\na += 5  # a becomes 15\na *= 2  # a becomes 30\nprint(a)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "The floor division assignment operator `//=` performs integer division and assigns the result.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "Floor Division Assignment",
                "text": "`//=` performs integer division, discarding the fractional part.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-4-d2",
                "kind": "example",
                "title": "Floor Division Example",
                "text": "",
                "code": "x = 10\nx //= 3\nprint(x) # Output: 3",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Chained assignment (e.g., `a = b = c = value`) binds multiple variables to the *same* object in memory.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "explanation",
                "title": "Single Object Binding",
                "text": "Chained assignment binds all variables to the *exact same* object in memory.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-5-d2",
                "kind": "example",
                "title": "Chained Assignment Identity",
                "text": "",
                "code": "a = b = c = 300\nprint(a is b is c) # True (same object)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Multiple assignment allows assigning values to several variables in one line, useful for unpacking sequences or swapping variable contents.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Unpacking with Multiple Assignment",
                "text": "",
                "code": "a, b, c = 10, 20, 30\nprint(f'{a=}, {b=}, {c=}')",
                "table": null
              },
              {
                "id": "kp-6-d2",
                "kind": "example",
                "title": "Swapping Variables",
                "text": "",
                "code": "x = 10\ny = 20\nx, y = y, x # Swaps values\nprint(f'{x=}, {y=}')",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Assigning equal values to different variables separately (e.g., `a = 300; b = 300`) can result in them referencing distinct objects in memory.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "Separate Object Creation",
                "text": "Assigning equal values separately often creates distinct objects, especially for larger integers or mutable types.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-7-d2",
                "kind": "example",
                "title": "Distinct Object IDs",
                "text": "",
                "code": "name_1 = 300\nname_2 = 300\nprint(name_1 == name_2) # True (values are equal)\nprint(id(name_1) != id(name_2)) # True (likely different objects)",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-970620e487",
          "lec-18dd567530",
          "lec-8f40fb5984",
          "nb-49999b1411",
          "nb-c120563f18",
          "nb-1efd2c6579",
          "nb-3642142eff"
        ]
      }
    },
    {
      "id": "topic-list-loop",
      "topic": "Lists",
      "canonical_topic": "list",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2023": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "For-loops",
        "for_loop / list",
        "for_loops",
        "list_operations",
        "lists",
        "set / list / uniqueness",
        "set / list operations"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used \u2014 use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-989ce43b0f",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 6,
            "week": 2,
            "topic": "lists",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[1, 2, 3, 4]",
              "B": "[1, 2, 3, 4]\n[1, 2, 3, 4]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "lst[:] creates a shallow copy. Modifying lst2 does not affect lst. lst stays [1,2,3], lst2 becomes [1,2,3,4]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-de37856825",
            "week": 2,
            "cell_index": 41,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = []\nprint(squares)\nsquares = list()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-d2f4ffb243",
            "week": 2,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-959f6e1a09",
            "week": 2,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [4, 16]\nsquares = squares[:1] + [9] + squares[1:]  \nsquares.append(25)\nsquares += [36]\nsquares.insert(0, 1)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9b6dd0d742",
            "week": 2,
            "cell_index": 44,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 5, 9, 16]\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-001226386b",
            "week": 2,
            "cell_index": 45,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 8, 15]\nsquares[2] = 9\nsquares[3] = 16\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-80c6871326",
            "week": 2,
            "cell_index": 47,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nsquares.append(16)\nsquares.append(25)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-496d4b7476",
            "week": 2,
            "cell_index": 48,
            "cell_type": "code",
            "topic": "lists",
            "source": "if 16 not in squares:\n    squares.append(16)\nif 25 not in squares:\n    squares.append(25)    \nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-b93f963478",
            "week": 2,
            "cell_index": 50,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nsquares = set(squares)\nsquares.add(16)\nsquares.add(25)\nsquares = list(squares)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "List operations either modify a list 'in-place' or return a new, modified list. The most critical distinction to track for exams is whether the original list variable is changed or not. For example, `my_list.sort()` modifies the list and returns `None`, while `sorted(my_list)` leaves the original list untouched and returns a new, sorted list."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What happens if you assign the result of an in-place method to a variable (e.g., `x = my_list.sort()`)?",
            "Will converting a list to a set and back to a list maintain the original order?",
            "What's the most efficient way to check if a list contains any duplicate values?",
            "Does the operation change the original list (`in-place`) or return a new one?",
            "How do you correctly create a copy of a list vs. just a new reference to it?",
            "What happens if you try to create a set from a list containing other lists?",
            "What is printed if the print statement is inside versus outside the loop?",
            "What is the difference between `list.sort()` and the `sorted()` function?"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "List Initialization",
            "code": "squares = []\nprint(squares)\nsquares = list()\nprint(squares)\nsquares = [1, 4, 9, 16]\nprint(squares)",
            "why": "Demonstrates various ways to initialize empty and pre-filled lists.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Modifying List Elements by Index",
            "code": "squares = [1, 4, 8, 15]\nsquares[2] = 9\nsquares[3] = 16\nprint(squares)",
            "why": "Illustrates how to change specific elements in a list by direct index assignment.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Appending and Inserting Elements",
            "code": "squares = [4, 16]\nsquares = squares[:1] + [9] + squares[1:] # Insert 9 at index 1\nsquares.append(25)\nsquares += [36]\nsquares.insert(0, 1)\nprint(squares)",
            "why": "Shows using slicing for insertion, `append()` for adding to the end, `+=` for list concatenation, and `insert()` for adding at a specific index.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Deleting Elements from a List",
            "code": "squares = [1, 4, 5, 9, 16]\ndel(squares[2])\nprint(squares)",
            "why": "Demonstrates using the `del` statement to remove an element at a given index.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Shallow Copying a List with Slicing",
            "code": "lst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
            "why": "Shows that modifying a shallow copy (created with `[:]`) does not affect the original list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Conditional Appending and Element Existence Check",
            "code": "squares = [1, 4, 9, 16]\nif 16 not in squares:\n    squares.append(16)\nif 25 not in squares:\n    squares.append(25)\nprint(squares)",
            "why": "Illustrates how to use the `in` operator to check if an element exists before conditionally appending it.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "correct",
            "title": "Removing Duplicates Using Sets",
            "code": "squares = [1, 4, 9, 16, 16, 25]\nsquares = set(squares)\nsquares.add(36) # Example of adding to a set\nsquares = list(squares)\nprint(squares)",
            "why": "Demonstrates converting a list to a set to remove duplicates, adding an element to the set, and converting back to a list.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "correct",
            "title": "Basic For-Loop Summation",
            "code": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint(total)",
            "why": "A straightforward example of iterating through a list and summing its numeric elements.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Lists can be initialized as empty using `[]` or the `list()` constructor.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Initializing empty lists",
                "text": "",
                "code": "squares = []\nprint(squares)\nsquares = list()\nprint(squares)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Lists can be initialized directly with pre-defined elements.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Initializing with elements",
                "text": "",
                "code": "squares = [1, 4, 9, 16]\nprint(squares)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The `append()` method adds a single element to the end of a list.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "Using append()",
                "text": "Adds elements to the end of the list.",
                "code": "squares = [1, 4, 9, 16]\nsquares.append(25)\nprint(squares) # Output: [1, 4, 9, 16, 25]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Individual list elements can be modified by assigning new values using their index.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "example",
                "title": "Modifying elements by index",
                "text": "",
                "code": "squares = [1, 4, 8, 15]\nsquares[2] = 9\nsquares[3] = 16\nprint(squares) # Output: [1, 4, 9, 16]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "The `insert(index, element)` method adds an element at a specified index within a list, shifting existing elements.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Inserting elements with insert()",
                "text": "Adds an element at a specific index, shifting others.",
                "code": "squares = [4, 9, 16]\nsquares.insert(0, 1)\nprint(squares) # Output: [1, 4, 9, 16]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "The `del` statement removes an element from a list at a specific index.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Removing elements with del",
                "text": "The `del` statement removes an element by its index.",
                "code": "squares = [1, 4, 5, 9, 16]\ndel(squares[2])\nprint(squares) # Output: [1, 4, 9, 16]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Slicing a list using `[:]` creates a shallow copy, meaning changes to the new list do not affect the original.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "Shallow Copy with Slicing",
                "text": "Using `[:]` creates a new list with references to the original elements. Changes to the new list's elements won't affect the original if elements are immutable, but if elements are mutable (e.g., nested lists), modifying them in the copy will affect the original.",
                "code": "",
                "table": null
              },
              {
                "id": "kp-7-d2",
                "kind": "example",
                "title": "Shallow Copy Example",
                "text": "",
                "code": "lst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)  # Output: [1, 2, 3]\nprint(lst2) # Output: [1, 2, 3, 4]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Slicing can be used to insert or replace multiple elements within a list by concatenating slices.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-8-d1",
                "kind": "example",
                "title": "Slicing to insert/replace",
                "text": "",
                "code": "squares = [4, 16]\nsquares = squares[:1] + [9] + squares[1:]\nprint(squares) # Output: [4, 9, 16]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "The `+=` operator can be used to extend a list by concatenating it with another iterable.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-9-d1",
                "kind": "example",
                "title": "Extending with +=",
                "text": "The `+=` operator extends the list by concatenating another iterable (e.g., another list).",
                "code": "squares = [1, 4, 9, 16]\nsquares += [25, 36]\nprint(squares) # Output: [1, 4, 9, 16, 25, 36]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "The `in` operator checks for the presence of an element within a list.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-10-d1",
                "kind": "example",
                "title": "Checking presence with 'in'",
                "text": "The `in` operator returns `True` if an element exists in the list, `False` otherwise.",
                "code": "squares = [1, 4, 9]\nif 4 in squares:\n    print('4 is in squares')\nif 5 not in squares:\n    print('5 is not in squares')\n# Output:\n# 4 is in squares\n# 5 is not in squares",
                "table": null
              }
            ]
          },
          {
            "id": "kp-11",
            "text": "A `for` loop iterates over each item in a sequence, executing a block of code for each item.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-11-d1",
                "kind": "explanation",
                "title": "Basic for-loop syntax",
                "text": "A `for` loop processes each item in a sequence (like a list, tuple, or string) one by one.",
                "code": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint(total) # Output: 21",
                "table": null
              }
            ]
          },
          {
            "id": "kp-12",
            "text": "The `break` statement immediately terminates the loop it is contained within.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-12-d1",
                "kind": "explanation",
                "title": "Using 'break' in loops",
                "text": "The `break` statement immediately stops the execution of the loop and exits it. Control flow resumes at the statement immediately after the loop.",
                "code": "",
                "table": null
              }
            ]
          },
          {
            "id": "kp-13",
            "text": "The `continue` statement skips the remainder of the current loop iteration and proceeds to the next iteration.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-13-d1",
                "kind": "example",
                "title": "Using 'continue' in loops",
                "text": "The `continue` statement skips the rest of the current iteration's code block and proceeds to the next iteration of the loop.",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue # Skip non-numeric values\n    total += number\nprint(total) # Output: 18 (skips '3')",
                "table": null
              }
            ]
          },
          {
            "id": "kp-14",
            "text": "The underscore `_` is a conventional variable name for loop elements that are not used inside the loop's body.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-14-d1",
                "kind": "example",
                "title": "Underscore for unused variables",
                "text": "Use `_` as a placeholder variable when the loop element itself is not needed inside the loop body.",
                "code": "for _ in range(3):\n    print('Hello')\n# Output:\n# Hello\n# Hello\n# Hello",
                "table": null
              }
            ]
          },
          {
            "id": "kp-15",
            "text": "Converting a list to a `set` automatically removes duplicate elements, and the resulting `set` can be converted back into a list.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-15-d1",
                "kind": "example",
                "title": "Removing duplicates with set conversion",
                "text": "Converting a list to a `set` automatically removes all duplicate elements. Converting back to a list preserves the unique elements.",
                "code": "squares = [1, 4, 9, 16, 9, 4, 25]\nunique_squares = list(set(squares))\nprint(unique_squares) # Output (order may vary): [1, 4, 9, 16, 25]",
                "table": null
              }
            ]
          },
          {
            "id": "kp-16",
            "text": "The `add()` method is used to insert individual elements into a set.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-16-d1",
                "kind": "example",
                "title": "Adding elements to a set",
                "text": "The `add()` method inserts a single element into a set. If the element already exists, the set remains unchanged.",
                "code": "my_set = {1, 2, 3}\nmy_set.add(4)\nmy_set.add(2) # Already exists, no change\nprint(my_set) # Output (order may vary): {1, 2, 3, 4}",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-989ce43b0f",
          "lec-1a2667a070",
          "nb-959f6e1a09",
          "nb-496d4b7476",
          "nb-b93f963478",
          "nb-9b6dd0d742",
          "nb-de37856825",
          "nb-001226386b",
          "nb-80c6871326"
        ]
      }
    },
    {
      "id": "topic-string",
      "topic": "Strings",
      "canonical_topic": "string",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2023": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "enumerate",
        "enumerate / dict / string_ops",
        "enumerate()",
        "string indexing",
        "string_methods",
        "strings",
        "strings_escape",
        "strings_fstrings",
        "strings_quotes"
      ],
      "trap_patterns": [
        {
          "pattern": "str.upper() / string methods don't modify in place",
          "trap": "s.upper() returns a new string; s is unchanged. Must do s = s.upper()",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) \u2014 second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-14f703ef57",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 4,
            "week": 1,
            "topic": "string indexing",
            "question": "What is the output of the following code?\n\ns = 'Python'\nprint(s[1:4])",
            "code_context": "",
            "options": {
              "A": "Pyt",
              "B": "yth",
              "C": "ytho",
              "D": "ython"
            },
            "correct": "B",
            "explanation": "s[1:4] gives characters at indices 1, 2, 3: 'y', 't', 'h' = 'yth'."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-9ccea86971",
            "week": 1,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "strings",
            "source": "print(\"This is a string\")\nprint('This is another string')",
            "outputs": []
          },
          {
            "id": "nb-fac92dad98",
            "week": 1,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"",
            "outputs": []
          },
          {
            "id": "nb-2dd9891d55",
            "week": 1,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a,b)",
            "outputs": []
          },
          {
            "id": "nb-046b3572aa",
            "week": 1,
            "cell_index": 83,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
            "outputs": []
          },
          {
            "id": "nb-ecaef89c57",
            "week": 1,
            "cell_index": 85,
            "cell_type": "code",
            "topic": "strings_fstrings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(f\"First string: '{a}', Second string: '{b}'.\")\nprint(\"First string: '{a}', Second string: '{b}'.\")",
            "outputs": []
          },
          {
            "id": "nb-8d7baf62a3",
            "week": 1,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "strings_quotes",
            "source": "print('This gives an error\")\nprint(\"This gives an error')",
            "outputs": []
          },
          {
            "id": "nb-7fcad85f68",
            "week": 1,
            "cell_index": 91,
            "cell_type": "code",
            "topic": "strings_quotes",
            "source": "print(\"This gives no ' error\")\nprint('This gives no \" error')",
            "outputs": []
          },
          {
            "id": "nb-eefca863f9",
            "week": 1,
            "cell_index": 93,
            "cell_type": "code",
            "topic": "strings_escape",
            "source": "print('This gives no \\' error')\nprint(\"This gives no \\\" error\")",
            "outputs": []
          },
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Strings are immutable sequences of characters in Python. This means they cannot be changed in-place; methods like `.upper()` or `.replace()` always return a *new* string, leaving the original untouched. You can access parts of a string using indexing `s[i]` and slicing `s[i:j]`, which works just like list slicing and is a frequent topic for 'what is the output' questions."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How do you correctly update a string to its uppercase version?",
            "What is the output of `s[1:4]` for the string 'Python'?",
            "What does `s.upper()` do to the original string `s`?",
            "What error occurs if you try `my_string[0] = 'a'`?",
            "How do you get the last character of a string?",
            "Are strings mutable or immutable?",
            "Write a loop to print each character of a string on a new line with its position.",
            "Can you change a character in a string like `my_str[0] = 'a'`? (No)"
          ]
        },
        "ai_examples": [
          {
            "id": "ex-1",
            "kind": "correct",
            "title": "Defining and printing strings",
            "code": "a = 'This is a string'\nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a, b)",
            "why": "Demonstrates valid single and double-quoted string definition and basic printing.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-2",
            "kind": "correct",
            "title": "Concatenating strings",
            "code": "a = 'This is a string'\nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
            "why": "Shows how to join strings using the `+` operator.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-3",
            "kind": "correct",
            "title": "Using f-strings for formatting",
            "code": "a = 'This is a string'\nb = \"This is another string\"\nprint(f\"First string: '{a}', Second string: '{b}'.\")",
            "why": "Demonstrates correct syntax for embedding variables in f-strings.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-4",
            "kind": "correct",
            "title": "Using mixed quotes to avoid escaping",
            "code": "print(\"This gives no ' error\")\nprint('This gives no \" error')",
            "why": "Shows that a string defined with double quotes can naturally contain single quotes, and vice-versa, without escaping.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-5",
            "kind": "correct",
            "title": "Escaping same-type quotes within a string",
            "code": "print('This gives no \\' error')\nprint(\"This gives no \\\" error\")",
            "why": "Demonstrates using a backslash (`\\`) to escape a quote character when the string is defined by the same type of quote.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-6",
            "kind": "correct",
            "title": "Storing the result of string methods",
            "code": "s = \"hello\"\ns = s.upper()\nprint(s)",
            "why": "Shows that to apply a string method's effect, its return value (a new string) must be assigned back to a variable, as strings are immutable.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-7",
            "kind": "incorrect",
            "title": "Incorrect assumption that strip mutates in place",
            "code": "s = '  hello  '\ns.strip()\nprint(repr(s))",
            "why": "`strip()` returns a new string; the original `s` is unchanged unless reassigned.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-8",
            "kind": "incorrect",
            "title": "f-string without 'f' prefix",
            "code": "a = 'This is a string'\nb = \"This is another string\"\nprint(\"First string: '{a}', Second string: '{b}'.\")",
            "why": "Without the `f` prefix, Python treats `{a}` and `{b}` as literal strings, not placeholders for variables.",
            "status": "evidence_curated_gemini_reviewed"
          },
          {
            "id": "ex-9",
            "kind": "incorrect",
            "title": "Assuming in-place string modification",
            "code": "s = \"hello\"\ns.upper()\nprint(s)",
            "why": "String methods like `upper()` return a *new* string and do not modify the original string because strings are immutable in Python. The variable `s` retains its original value.",
            "status": "evidence_curated_gemini_reviewed"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Strings are sequences of characters that can be defined using either single or double quotes.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Defining Strings",
                "text": "",
                "code": "my_single_quote_string = 'Hello'\nmy_double_quote_string = \"World\"",
                "table": null
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Strings can be concatenated using the `+` operator.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-2-d1",
                "kind": "example",
                "title": "Concatenation with '+'",
                "text": "",
                "code": "s1 = 'Hello'\ns2 = ' World'\ncombined = s1 + s2\nprint(combined) # Output: Hello World",
                "table": null
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "f-strings (formatted string literals) allow embedding expressions directly within string literals by prefixing the string with `f`.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-3-d1",
                "kind": "example",
                "title": "F-string Syntax",
                "text": "Embed variables directly using an 'f' prefix.",
                "code": "name = 'Alice'\nage = 30\nmessage = f'My name is {name} and I am {age} years old.'\nprint(message)",
                "table": null
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "String slicing `s[start:end]` extracts a substring from the `start` index (inclusive) up to, but not including, the `end` index.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-4-d1",
                "kind": "explanation",
                "title": "String Slicing",
                "text": "Slicing `s[start:end]` includes characters from `start` up to, but not including, `end`.",
                "code": "s = 'Python'\nsubstring = s[1:4]\nprint(substring) # Output: yth",
                "table": null
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Strings defined with single quotes can naturally contain double quotes, and vice-versa, without needing to be escaped.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-5-d1",
                "kind": "example",
                "title": "Nesting Quotes",
                "text": "Use different quote types to avoid escaping.",
                "code": "print(\"This is a 'quote' inside double quotes.\")\nprint('This is a \"quote\" inside single quotes.')",
                "table": null
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "To include a quote character within a string defined by the same type of quote, it must be escaped using a backslash (`\\`).",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-6-d1",
                "kind": "example",
                "title": "Escaping Quotes",
                "text": "Use a backslash to include the same quote type.",
                "code": "print('She said, \\'Hello!\\'')\nprint(\"He shouted, \\\"Look out!\\\"\")",
                "table": null
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "String methods, such as `str.upper()`, return a *new* string and do not modify the original string in place because strings are immutable.",
            "status": "evidence_curated_gemini_reviewed",
            "model": "gemini-2.5-flash",
            "generator": "parallel_gemini_evidence_curation_2026_02_25",
            "details": [
              {
                "id": "kp-7-d1",
                "kind": "explanation",
                "title": "String Immutability",
                "text": "String methods return new strings; they don't change the original. Reassign the variable to store the new string.",
                "code": "s = 'hello'\nupper_s = s.upper() # s is still 'hello'\nprint(s) # Output: hello\nprint(upper_s) # Output: HELLO\n\ns = s.upper() # Now s is 'HELLO'",
                "table": null
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-14f703ef57",
          "lec-ca6bf752eb",
          "nb-046b3572aa",
          "nb-ecaef89c57",
          "nb-8d7baf62a3",
          "nb-6d22b8d418",
          "nb-87216389d2"
        ]
      }
    },
    {
      "id": "topic-arithmetic",
      "topic": "arithmetic_operators",
      "canonical_topic": "arithmetic",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Arithmetic operators",
        "arithmetic_operators"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-5eee5b396a",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Arithmetic operators",
            "explanation": "a+b, a-b, a*b: standard. a/b: always returns float. a//b: floor division (highest integer <= result). a%b: remainder. a**b: exponentiation. NOTE: ^ is NOT exponentiation in Python (it is XOR). (a//b)*b + a%b == a always.",
            "code_examples": [
              {
                "description": "Floor division and modulo",
                "code": "print(5 // 3, 5 % 3)    # 1 2\nprint(-5 // 3, -5 % 3)  # -2 1\nprint(5 // 2, 5 % 2)    # 2 1\nprint(-5 // 2, -5 % 2)  # -3 1"
              }
            ]
          },
          {
            "id": "leq-e9c4f96514",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Arithmetic operators",
            "question": "What is the result of (a//b)*b + a%b?",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-47b9ce3817",
            "week": 1,
            "cell_index": 41,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(4 + 3)\nprint(4 - 3)\nprint(4 * 3)\nprint(4 / 3)\nprint(4 / 2)\nprint(4 ** 3)",
            "outputs": [
              "7\n1\n12\n1.3333333333333333\n2.0\n64"
            ]
          },
          {
            "id": "nb-f3f249a2d7",
            "week": 1,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(5 // 3, 5 % 3)\nprint(-5 // 3, -5 % 3)\nprint(5 // 2, 5 % 2)\nprint(-5 // 2, -5 % 2)",
            "outputs": [
              "1 2\n-2 1\n2 1\n-3 1"
            ]
          },
          {
            "id": "nb-ff27913d20",
            "week": 1,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(5//2, 5%2)",
            "outputs": [
              "2 1"
            ]
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Python's arithmetic operators are straightforward, but exams often test edge cases. The key distinctions are between `/` (float division, always returns a float) and `//` (floor division, returns an integer). Also, be very careful with floor division and modulo (`%`) on negative numbers, as the results can be counterintuitive.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type and value of `10 / 5`? (float, `2.0`)",
            "What is the result of a negative floor division, like `-9 // 4`? (-3)",
            "What is the operator for exponentiation in Python? (`**`, not `^`)",
            "What is the result of `5 % 2` versus `-5 % 2`?",
            "Does Python follow PEMDAS/BODMAS for operator precedence?",
            "What is the result of `2 + 3 * 4`?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Float vs. Floor Division",
            "code": "float_div = 10 / 4   # Result is 2.5\nfloor_div = 10 // 4  # Result is 2\nprint(f\"Float: {float_div}, Floor: {floor_div}\")",
            "why": "This demonstrates the core difference: `/` performs standard division and always returns a float, while `//` performs integer division, discarding the remainder.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Exponentiation with `**`",
            "code": "base = 2\nexponent = 3\n# Correct way to calculate 2 to the power of 3\nresult = base ** exponent\nprint(result) # Output is 8",
            "why": "The correct operator for raising a number to a power in Python is `**`. This is a common point of confusion for beginners from other languages.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using `^` for Exponents",
            "code": "# Incorrectly trying to calculate 2 to the power of 3\nresult = 2 ^ 3\nprint(result) # Output is 1",
            "why": "A frequent mistake. In Python, `^` is the bitwise XOR operator, not exponentiation. `2` (binary `10`) XOR `3` (binary `11`) results in `1` (binary `01`).",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Misunderstanding Negative Floor Division",
            "code": "# Student expects -2\nresult = -9 // 4\nprint(result)",
            "why": "Floor division always rounds down (towards negative infinity). Since `-9 / 4` is `-2.25`, rounding down results in `-3`, not `-2` (which would be truncation).",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`/` (division) always returns a float; `//` (floor division) returns the largest integer less than or equal to the result of division.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Division operators",
                "text": "",
                "table": {
                  "headers": [
                    "Operator",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "`/`",
                      "True division (float result)"
                    ],
                    [
                      "`//`",
                      "Floor division (round down)"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`a % b` (modulo) returns the remainder of the division; its sign matches the divisor `b`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "Python uses `**` for exponentiation; `^` is the bitwise XOR operator, not exponentiation.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "For floor division with negative numbers, `//` truncates towards negative infinity (e.g., `-5 // 3` evaluates to -2).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(5 // 3)     # 1\nprint(-5 // 3)    # -2  (toward negative infinity)",
                "id": "kp-4-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-5eee5b396a",
          "nb-f3f249a2d7",
          "nb-47b9ce3817"
        ]
      }
    },
    {
      "id": "topic-exam",
      "topic": "Exam question types",
      "canonical_topic": "exam",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Exam question types"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-f3fc8a65be",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Exam question types",
            "explanation": "Which code fragment will print the following output? / What will be printed by the following code fragment? / Which code fragment prints the SAME output as...? / One fragment prints different output from the others. / Which correctly solves the problem? Options may include: 'None of the above', 'Both', 'All', 'An error'.",
            "code_examples": []
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "This topic describes the format of exam questions themselves, not a Python concept. Common types include 'What will be printed?', where you trace the code's output, 'Which code produces this output?', where you match code to a result, and 'Which fragment is different?', where you find the outlier among several code blocks. Understanding these formats helps you quickly identify what the question is asking you to do.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How should I approach a 'What will be printed?' question?",
            "What's a good strategy for 'Which code is different?' questions?",
            "How do I handle questions where multiple options seem correct?",
            "What does it mean to 'trace' a program's execution?",
            "What should I look for in 'Which fragment correctly solves the problem?' questions?",
            "What are common tricks or traps in multiple-choice questions?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Example of: 'What will be printed?'",
            "code": "x = 1\ny = x\nx = 2\nprint(y)",
            "why": "This question type tests your understanding of assignment. You must trace that `y` was assigned the value of `x` (which was 1), and that `y` is not affected when `x` is later reassigned. The answer is 1.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Example of: 'Which is different?'",
            "code": "# A: print(1+2)\n# B: print(3)\n# C: print(4-1)",
            "why": "This question format requires you to evaluate and compare the output of several snippets. A, B, and C all print '3'. If a fourth option printed '4', that would be the different one. It tests if you can spot functional e\u2026",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Misreading 'Solves the problem'",
            "code": "def find_max(nums):\n  return nums[0]\n# Problem: Find the largest number in a list",
            "why": "This code runs without error, but it doesn't correctly solve the stated problem (it only works if the first element is the largest). An exam question might offer this as an option to trap students who don't test the log\u2026",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Ignoring a Stated Constraint",
            "code": "def get_unique(items):\n  return list(set(items))\n# Constraint: Preserve original order.",
            "why": "This function correctly returns unique items, but converting to a set and back does not preserve the original order. If the exam question specified that order must be preserved, this would be an incorrect solution despi\u2026",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Output-tracing workflow: annotate each executed line as `(line -> variable updates -> printed text)`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-1-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "For loop questions, count iterations first: `range(n)` executes `n` times with values `0..n-1`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "For nested loops, total inner executions are cumulative/multiplicative; compute counts before evaluating output.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Type-check trap: `'3' + 2` raises `TypeError`, while `'3' * 2` repeats to `'33'`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-4-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-4-d2"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Method trap: in-place methods (e.g., `list.sort()`) return `None`; value-returning alternatives (e.g., `sorted(lst)`) return new objects.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "In-place vs new object",
                "text": "",
                "table": {
                  "headers": [
                    "Operation",
                    "Mutates original?",
                    "Return value"
                  ],
                  "rows": [
                    [
                      "`lst.sort()`",
                      "Yes",
                      "`None`"
                    ],
                    [
                      "`sorted(lst)`",
                      "No",
                      "New sorted list"
                    ]
                  ]
                },
                "id": "kp-5-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "lst = [3, 1, 2]\nresult = lst.sort()      # lst becomes [1, 2, 3]\nprint(result)            # None\nnew_lst = sorted(lst)    # new list object",
                "id": "kp-5-d2"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-f3fc8a65be"
        ]
      }
    },
    {
      "id": "topic-importing-package",
      "topic": "imports",
      "canonical_topic": "importing package",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Importing packages",
        "imports"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-7df6a75078",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Importing packages",
            "explanation": "Multiple import styles. 'import X' makes X available. 'import X as Y' renames. 'from X import Z' brings Z directly into namespace. 'from X import Z as W' renames. Once you use 'as', the original name is no longer accessible.",
            "code_examples": [
              {
                "description": "Import styles",
                "code": "import numpy\nnumpy.random.randint(1, 10)  # works\n\nimport numpy as np\nnp.random.randint(1, 10)     # works\nnumpy.random.randint(1, 10)  # ERROR\n\nfrom numpy.random import randint\nrandint(1, 10)               # works\n\nfrom numpy.random import randint as rnd\nrnd(1, 10)                   # works\nrandint(1, 10)               # ERROR"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-85bb01e6b1",
            "week": 1,
            "cell_index": 99,
            "cell_type": "code",
            "topic": "imports",
            "source": "# In this cell we create a function that deletes all the thus far created names in your program, \n# we need such a function else you cannot run some cells more times and getting the same result all the time when testing the import statements \nimport sys\ndef clear_names():\n    message = ''\n    for n in sorted(globals()): \n        if n[0]!='_' and n not in [\"sys\", \"clear_names\"]:\n            message += f\"{n}, \"\n            delattr(sys.modules[__name__], n)",
            "outputs": []
          },
          {
            "id": "nb-194b84a11d",
            "week": 1,
            "cell_index": 100,
            "cell_type": "code",
            "topic": "imports",
            "source": "%%writefile extension.py\n# In this cell we create a python file and write that to the hard disk (either of your computer or to the cloud depending where you run your code.\n# We will import this file to show how to import the names of objects \n# into your Python program\nYEAR = 2025\ndef create_absolute_year(x):\n    return YEAR + x",
            "outputs": [
              "Overwriting extension.py"
            ]
          },
          {
            "id": "nb-6ea8069d6e",
            "week": 1,
            "cell_index": 101,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(Exception)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)\n\nimport extension\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "<class 'Exception'>\nname 'extension' is not defined\nname 'YEAR' is not defined\n2025"
            ]
          },
          {
            "id": "nb-2709817f6f",
            "week": 1,
            "cell_index": 102,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2025\nname 'extension' is not defined"
            ]
          },
          {
            "id": "nb-364b083d05",
            "week": 1,
            "cell_index": 103,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nfrom extension import create_absolute_year\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2026\nname 'YEAR' is not defined"
            ]
          },
          {
            "id": "nb-ffb2c584b7",
            "week": 1,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nfrom extension import create_absolute_year as cay\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(cay(1))\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "name 'create_absolute_year' is not defined\n2026"
            ]
          },
          {
            "id": "nb-8de680a61a",
            "week": 1,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nimport extension\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2025\n2025"
            ]
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Importing brings code from other files into your program's memory so you can use it. The `import` style determines the name you must use to access the code. `import math` means you use `math.pi`, while `from math import pi` means you just use `pi`. Using an alias with `as` makes the original name unavailable.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "After `import numpy as np`, how do you access the `array` function?",
            "Why am I getting a `NameError` even though I imported the module?",
            "What is the difference between `import math` and `from math import *`?",
            "If you `import module as m`, can you still use `module.function()`? (No)",
            "After `from module import func`, what is the correct way to call `func`?",
            "Will changing an imported variable affect the original module?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Importing a Module with an Alias",
            "code": "import random as rd\n\n# Call function using the alias 'rd'\nnum = rd.randint(1, 10)\nprint(num)",
            "why": "Using `as` creates a shorter alias (`rd`) for the module `random`. All functions from the module must now be accessed through this alias.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Importing a Specific Name from a Module",
            "code": "from math import pi\n\n# The name 'pi' is now directly available\narea = pi * (5 ** 2)\nprint(area)",
            "why": "`from...import` brings the specific name (`pi`) into the current scope. It can be used directly without referencing the `math` module.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using Original Name After Aliasing",
            "code": "import random as rd\n\n# This will fail\nnum = random.randint(1, 10)\n# NameError: name 'random' is not defined",
            "why": "Once a module is imported with an alias (`as rd`), the original name (`random`) is no longer defined in the program's scope. You must use the alias.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Using Module Prefix After `from...import`",
            "code": "from math import pi\n\n# This will fail\narea = math.pi * (5 ** 2)\n# NameError: name 'math' is not defined",
            "why": "`from math import pi` only imports the name `pi`, not the `math` module itself. `pi` is now a global variable and `math` is not recognized.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`import module` requires access via `module.name`; `import module as alias` requires `alias.name`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "After `import module as alias`, use `alias.name`; `module.name` works only if `module` was also imported under its original name.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "id": "kp-2-det-1",
                "kind": "example",
                "title": "Optional code example",
                "code": "import math as m\nprint(m.sqrt(9))  # 3.0\n# math.sqrt(9) would fail unless `import math` was also executed"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`from module import name` allows direct access via `name` (e.g., `func()`), not `module.name`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "`from module import name as alias` brings `name` into the namespace as `alias`; access via `alias`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-5",
            "text": "Avoid `from module import *` as it pollutes the current namespace and can lead to name collisions.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-7df6a75078",
          "nb-2709817f6f",
          "nb-364b083d05",
          "nb-ffb2c584b7"
        ]
      }
    },
    {
      "id": "topic-keyword-pass",
      "topic": "pass",
      "canonical_topic": "keyword pass",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "pass",
        "pass keyword"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-242c6fa7e5",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "pass keyword",
            "explanation": "Does nothing. Used as a placeholder when an indented block is required but you have nothing to put there yet (stub). After a colon you must have an indented block \u2014 pass satisfies this.",
            "code_examples": [
              {
                "description": "pass as stub",
                "code": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else:\n        pass  # placeholder \u2014 won't cause IndentationError\n    return result"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-b29776646d",
            "week": 3,
            "cell_index": 25,
            "cell_type": "code",
            "topic": "pass",
            "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n    return result\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-d63665c405",
            "week": 3,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "pass",
            "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n        pass\n    return result\na = adder(1, 2)\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `pass` keyword is a null statement; it does nothing when executed. It serves as a placeholder where Python's syntax requires an indented block but you have no code to write yet. Using `pass` prevents an `IndentationError` in empty functions, classes, or conditional branches.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "When is it necessary to use the `pass` keyword?",
            "What is the difference between `pass`, `continue`, and `break`?",
            "What error occurs if you leave a function or `if` statement body empty?",
            "Can `pass` be used as a temporary stub during development?",
            "Does `pass` have any effect on program execution flow or variables?",
            "Is `pass` considered good practice in finished code?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Placeholder in a Function",
            "code": "def process_data(data):\n    # TODO: Implement data processing logic later\n    pass\n\nprocess_data([]) # Runs without error",
            "why": "`pass` correctly acts as a placeholder, allowing the empty function to be defined and called without causing an `IndentationError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Ignoring a Condition",
            "code": "for num in range(1, 5):\n    if num % 2 != 0:\n        # We only care about even numbers\n        pass\n    else:\n        print(f'{num} is even')",
            "why": "`pass` is used to explicitly and readably ignore cases you don't want to act on, fulfilling the `if` block's syntax requirement.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Missing Indented Block",
            "code": "def my_function():\n    # Forgetting to add pass or other code\n\n# IndentationError: expected an indented block",
            "why": "Python requires at least one indented statement after a colon (:). Leaving the block empty is a syntax error. `pass` should be used here as a placeholder.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Confusing `pass` with `return`",
            "code": "def check_user(user):\n    if not user:\n        pass\n    return 'User is valid'\n\nprint(check_user(None))",
            "why": "`pass` does nothing and execution continues to the next line. The function will always proceed to `return 'User is valid'`, even if the user is `None`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`pass` is a null operation; it does nothing and acts as a placeholder where a statement is syntactically required.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "if True:\n    pass   # TODO: fill logic later",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `pass` to avoid `IndentationError` when defining empty blocks for functions, classes, `if`/`else`, or loops.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "`break` terminates the enclosing loop; `continue` skips to the next iteration of the loop; `pass` is a no-op.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Loop control quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`break`",
                      "Exit current loop immediately"
                    ],
                    [
                      "`continue`",
                      "Skip rest of current iteration"
                    ],
                    [
                      "`pass`",
                      "Do nothing (placeholder statement)"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`pass` does not affect program execution flow or variables, serving only to satisfy syntax requirements.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-242c6fa7e5",
          "nb-d63665c405",
          "nb-b29776646d"
        ]
      }
    },
    {
      "id": "topic-execution-python",
      "topic": "Python execution model",
      "canonical_topic": "execution python",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Python execution model"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-e91df37af4",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Python execution model",
            "explanation": "Python script is translated line by line into byte code, then byte code is translated into machine code. Writing code must be precise; ambiguities that humans handle fine will cause Python errors.",
            "code_examples": []
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Python executes code sequentially, from the top of the file to the bottom, one line at a time. A variable or function must be defined before it can be used. If Python encounters an error on any line, the program will immediately stop, and any code after the error-causing line will not be executed.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the final output of this script?",
            "Why did the program stop executing?",
            "If a `NameError` happens on line 3, is line 2 executed? (Yes)",
            "If an error happens on line 3, is line 4 executed? (No)",
            "What is a `NameError` and why does it happen?",
            "Can I call a function before it is defined? (No)"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Simple Sequential Execution",
            "code": "x = 10\ny = 20\nx = x + y\nprint(x)\n# Output: 30",
            "why": "Python executes each line in order. By the time `print(x)` is reached, `x` has been defined, assigned 10, and then updated to 30.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Function Definition vs. Call",
            "code": "def say_hello():\n    print('Hello')\n\nprint('Start')\nsay_hello()\nprint('End')\n# Output: Start, Hello, End",
            "why": "Defining a function does not run its code. Python notes the definition, prints 'Start', executes the function body when `say_hello()` is called, and then continues.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using a Variable Before It's Defined",
            "code": "print(price)\nprice = 100\n# NameError: name 'price' is not defined",
            "why": "The script executes top-to-bottom. When `print(price)` is reached on the first line, the variable `price` has not yet been created in memory, causing a `NameError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Error Halting Execution",
            "code": "a = 10\nb = 0\nprint('Calculating...')\nc = a / b # Error occurs here\nprint('Done!') # This line is never reached",
            "why": "The program successfully executes the lines before the error. However, the `ZeroDivisionError` on the fourth line halts the script immediately. The final `print` statement is never run.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Execution order is sequential: `line_n` must finish before Python runs `line_n+1`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "An uncaught exception (`NameError`, `TypeError`, etc.) stops execution immediately; later lines do not run.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print('A')\n1 / 0              # ZeroDivisionError\nprint('B')         # never runs",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`def name(...):` creates a function object now; the function body executes only when `name(...)` is called.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "Name resolution follows LEGB order: Local -> Enclosing -> Global -> Builtins.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "LEGB order",
                "text": "",
                "table": {
                  "headers": [
                    "Lookup order",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "Local",
                      "Current function scope"
                    ],
                    [
                      "Enclosing",
                      "Nearest outer function scope"
                    ],
                    [
                      "Global",
                      "Module-level scope"
                    ],
                    [
                      "Builtins",
                      "Python built-in names"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`if`/`while` evaluate the condition before running the body; a falsy condition skips the body.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-e91df37af4"
        ]
      }
    },
    {
      "id": "topic-element-single-tuple",
      "topic": "Single-element tuple",
      "canonical_topic": "element single tuple",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Single-element tuple"
      ],
      "trap_patterns": [
        {
          "pattern": "Single-element tuple needs trailing comma",
          "trap": "(1) is int, not tuple. (1,) or 1, is a tuple",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-240025dd8c",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Single-element tuple",
            "explanation": "(1) is NOT a tuple \u2014 it's just the integer 1. To create a 1-element tuple: t = (1,) or t = 1,. Neat swap trick: x, y = y, x",
            "code_examples": [
              {
                "description": "1-element tuple gotcha",
                "code": "t1 = (1)\nprint(type(t1) == tuple)  # False\nprint(type(t1) == int)    # True\nt1 = (1,)  # correct 1-element tuple\nt1 = 1,    # also correct\nx, y = y, x  # swap using tuple unpacking"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Creating a tuple with only one element is a common exam trap. Using parentheses like `(1)` does not create a tuple; it evaluates to the integer `1`. To create a single-element tuple, you must include a trailing comma after the element, as in `(1,)`.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type of the expression `x = ('hello')`?",
            "How do you correctly define a tuple containing only the integer 5?",
            "Why is the trailing comma essential for single-element tuples?",
            "What is the output of `len((99))`?",
            "Can a single-element tuple be created without using any parentheses?",
            "What happens when you try to loop over `(10)` vs `(10,)`?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Correct: With Trailing Comma",
            "code": "my_tuple = (42,)\nprint(type(my_tuple))\n# <class 'tuple'>",
            "why": "The trailing comma after `42` is the correct and essential syntax that tells Python to create a tuple with one element.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Correct: Without Parentheses",
            "code": "my_tuple = 42,\nprint(type(my_tuple))\n# <class 'tuple'>",
            "why": "A trailing comma after any expression is sufficient to create a tuple, even without parentheses. This is less common but valid.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Incorrect: Missing Trailing Comma",
            "code": "not_a_tuple = (99)\nprint(type(not_a_tuple))\n# <class 'int'>",
            "why": "Without a trailing comma, the parentheses are treated as standard grouping operators. The expression evaluates to the integer `99`, not a tuple.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Incorrect: TypeError on Iteration",
            "code": "my_val = (100)\nfor i in my_val:\n    print(i)\n# TypeError: 'int' object is not iterable",
            "why": "Because `(100)` is just an integer, it cannot be iterated over with a `for` loop. To fix this, it must be defined as a tuple: `(100,)`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "A single-element tuple requires a trailing comma: `(value,)` or `value,`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`(value)` without a trailing comma evaluates to `value` itself, not a tuple; e.g., `(5)` is an `int`, not a `tuple`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`type((5))` is `int`, while `type((5,))` is `tuple`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`len((99))` results in a `TypeError` if `99` is not iterable, because `(99)` evaluates to the `int` 99; `len((99,))` returns 1.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-4-d2"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-240025dd8c"
        ]
      }
    },
    {
      "id": "topic-walru",
      "topic": "walrus_operator",
      "canonical_topic": "= walru",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Walrus operator :=",
        "walrus_operator"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-aa87baadd4",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Walrus operator :=",
            "explanation": "Introduced in Python 3.8. Assigns AND evaluates to a value (unlike = which is a statement). Useful in while conditions to assign and test at once.",
            "code_examples": [
              {
                "description": "Walrus in while loop",
                "code": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100:\n    if number % 2 == 1:\n        total += number\nprint(total)"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-43d9c8aa9a",
            "week": 2,
            "cell_index": 98,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100 :\n    if number % 2 == 1:\n        total += number\nprint (f'The sum of all the uneven numbers you entered is {total}')",
            "outputs": []
          },
          {
            "id": "nb-d7e9f74017",
            "week": 2,
            "cell_index": 100,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-d4e293f6ac",
            "week": 2,
            "cell_index": 101,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "from random import randint\nprint(a := randint(0,5))\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The walrus operator `:=` both assigns a value to a variable and evaluates to that same value within an expression. It's most useful for simplifying `while` loops by allowing you to get a value (e.g., from `input()`) and check it in the same line. Unlike `=`, `:=` is an expression, not a statement.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Rewrite a traditional `while` loop using the walrus operator.",
            "What is the main difference between `=` and `:=`?",
            "In which situations is the walrus operator most useful?",
            "What is the value of the variable after a `while` loop using `:=` has finished?",
            "Explain what `if (x := f()) > 10:` does.",
            "Is `x := 5` a valid standalone statement? (Yes)"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Simplify a while loop with user input",
            "code": "numbers = []\nwhile (line := input('Enter a number (or quit): ')) != 'quit':\n    numbers.append(int(line))\nprint(sum(numbers))",
            "why": "This is the classic use case. The `input()` result is assigned to `line` and `line` is immediately compared to 'quit' in the loop's condition, making the code more concise.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Use and test a value in an if statement",
            "code": "def get_len(text):\n    return len(text)\n\nsample = 'Python'\nif (n := get_len(sample)) > 5:\n    print(f'Text is too long: {n} chars')",
            "why": "The walrus operator captures the return value of `get_len(sample)` into `n`. This allows the code to both check if it's greater than 5 and use the value `n` in the print statement without calling the function twice.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using assignment operator (=) in a condition",
            "code": "while x = 5:\n    print('This will not work')\n\n# SyntaxError: invalid syntax",
            "why": "This is a `SyntaxError` because the standard assignment operator `=` is a statement, not an expression, and cannot be used as a condition in a `while` or `if` statement.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Misunderstanding operator precedence",
            "code": "data = [1, 2, 3]\nif x := len(data) > 2:\n    print(f'Value of x is {x}')\n\n# Value of x is True",
            "why": "The comparison `len(data) > 2` is evaluated first (to `True`), and then this boolean result `True` is assigned to `x`. The correct way to assign the length is `if (x := len(data)) > 2:`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The walrus operator `:=` (Python 3.8+) assigns a value to a variable and simultaneously evaluates to that value.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `:=` within `while` loop conditions to assign input to a variable and test it in a single concise expression (e.g., `while (var := input()) != 'stop':`).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The assignment operator `=` is a statement and does not return a value, unlike the walrus operator `:=` which allows assignment within an expression.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "The walrus operator can be used within an `if` condition to assign a value and immediately evaluate it, as in `if (x := f()) > 10:`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`x := 5` is a valid standalone statement.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-5-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-aa87baadd4",
          "nb-43d9c8aa9a",
          "nb-d4e293f6ac"
        ]
      }
    }
  ]
}
