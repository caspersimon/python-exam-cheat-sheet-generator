{
  "meta": {
    "generated_from": "study_data.json",
    "generator": "build_topic_cards.py",
    "course": "Introduction to Python",
    "weeks_covered": [
      1,
      2,
      3
    ],
    "total_cards": 37,
    "notes": [
      "Sections (1) lecture snippets, (2) exam Q&A, and (4) notebook snippets are sourced from study_data.json.",
      "Low-value one-line notebook/heading snippets are filtered out automatically.",
      "AI sections are generated separately (summary, common questions, examples).",
      "AI summary/common-questions/examples generated with gemini-cli and validated.",
      "Generated key_points_to_remember and recommended_ids via gemini-cli.",
      "Post-processed key_points_to_remember to remove question-style/low-value lines.",
      "Replaced generic fallback key points with topic-specific references for scope/exam/execution cards.",
      "Added optional key point detail blocks (tables/examples/explanations) for reference usage."
    ]
  },
  "cards": [
    {
      "id": "topic-loop",
      "topic": "For Loops",
      "canonical_topic": "for loop",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 14,
        "by_exam": {
          "trial_midterm": 5,
          "midterm_2024": 4,
          "midterm_2023": 3,
          "extra_practice": 2
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Dictionaries",
        "For-loops",
        "Looping over dictionaries",
        "While-loops",
        "dictionaries",
        "dictionaries / nested dicts",
        "for loops / enumerate",
        "for loops / range",
        "for vs while / loop control",
        "for_loop / break",
        "for_loops",
        "for_vs_while",
        "looping_dicts",
        "nested loops",
        "nested loops / complexity",
        "nested loops / pairs",
        "nested_loops",
        "nested_loops / dict",
        "nested_loops / pairs",
        "walrus_operator",
        "while loops",
        "while loops / walrus operator",
        "while_loop",
        "while_loop / continue",
        "while_loop / walrus",
        "while_loops",
        "zip / looping"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' — this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used — use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          },
          {
            "id": "lec-5ae780c366",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Looping over dictionaries",
            "explanation": ".keys() → key sequence. .values() → value sequence. .items() → sequence of (key, value) tuples. 'for key in dict' is the same as 'for key in dict.keys()'.",
            "code_examples": [
              {
                "description": "Looping over dict",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\n# These two are equivalent:\nfor key in capitals:\nfor key in capitals.keys():"
              }
            ]
          },
          {
            "id": "lec-35530d9a47",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "While-loops",
            "explanation": "while condition: expression. Checks condition BEFORE each execution. Use break and continue. Watch for infinite loops (Ctrl+C to exit). Use when you don't know beforehand how many iterations are needed. For-loops can always be replaced by while-loops.",
            "code_examples": [
              {
                "description": "While with break/continue",
                "code": "total = 0\nwhile True:\n    number = int(input('give a number, or 100 to stop '))\n    if number == 100:\n        break\n    if number % 2 == 0:\n        continue\n    total += number\nprint(total)"
              },
              {
                "description": "Truthy/Falsy in while condition",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:           # truthy while list is non-empty\n    total += l1[0]\n    del l1[0]\nprint(total)        # 21"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          },
          {
            "id": "exm-7b51257c98",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 9,
            "week": 2,
            "topic": "for loops / range",
            "question": "What is the output of the following code?\n\nresult = 0\nfor i in range(1, 6):\n    result += i\nprint(result)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "15",
              "C": "21",
              "D": "6"
            },
            "correct": "B",
            "explanation": "range(1,6) gives 1,2,3,4,5. Sum = 15."
          },
          {
            "id": "exm-e6b8037e2c",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 10,
            "week": 2,
            "topic": "while loops / walrus operator",
            "question": "What is the output of the following code?\n\nnumbers = [1, 3, 5, 2, 7]\nresult = []\nfor num in numbers:\n    if num % 2 == 0:\n        result.append(num)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 3, 5, 7]",
              "B": "[2]",
              "C": "[]",
              "D": "[1, 3, 5, 2, 7]"
            },
            "correct": "B",
            "explanation": "Only 2 is even in the list. result = [2]."
          },
          {
            "id": "exm-405a1c9038",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 21,
            "week": 3,
            "topic": "nested loops",
            "question": "What is the output of the following code?\n\nresult = []\nfor i in range(3):\n    for j in range(3):\n        if i == j:\n            result.append((i, j))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[(0,0), (1,1), (2,2)]",
              "B": "[(0,1), (0,2), (1,2)]",
              "C": "[(0,0), (0,1), (0,2)]",
              "D": "[]"
            },
            "correct": "A",
            "explanation": "Only pairs where i == j: (0,0), (1,1), (2,2)."
          },
          {
            "id": "exm-6265aa347e",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 24,
            "week": 3,
            "topic": "for vs while / loop control",
            "question": "What is the output of the following code?\n\nresult = []\ni = 0\nwhile i < 5:\n    if i % 2 == 0:\n        result.append(i)\n    i += 1\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 3]",
              "B": "[0, 2, 4]",
              "C": "[0, 1, 2, 3, 4]",
              "D": "[2, 4]"
            },
            "correct": "B",
            "explanation": "Loop i=0..4, appending even values: 0, 2, 4. Result = [0, 2, 4]."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-09e753703b",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 10,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nlst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
            "code_context": "",
            "options": {
              "A": "0 a\n1 b\n2 c",
              "B": "1 a\n2 b\n3 c",
              "C": "a 1\nb 2\nc 3",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "enumerate(lst, start=1) begins counting at 1. Output: 1 a, 2 b, 3 c."
          },
          {
            "id": "exm-19033dcb2f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 11,
            "week": 2,
            "topic": "while loops",
            "question": "What is the output of the following code?\n\nn = 1\nwhile n < 32:\n    n *= 2\nprint(n)",
            "code_context": "",
            "options": {
              "A": "16",
              "B": "32",
              "C": "64",
              "D": "31"
            },
            "correct": "B",
            "explanation": "n: 1->2->4->8->16->32. 32 < 32 is False, loop stops. print(n) = 32."
          },
          {
            "id": "exm-f49499c6d8",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 24,
            "week": 3,
            "topic": "nested loops / complexity",
            "question": "What is the output of the following code?\n\ncount = 0\nfor i in range(4):\n    for j in range(i):\n        count += 1\nprint(count)",
            "code_context": "",
            "options": {
              "A": "4",
              "B": "6",
              "C": "10",
              "D": "16"
            },
            "correct": "B",
            "explanation": "i=0: j in range(0) → 0 iterations. i=1: 1. i=2: 2. i=3: 3. Total: 0+1+2+3 = 6."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-b7bad1b1ce",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 8,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
            "code_context": "",
            "options": {
              "A": "0 apple\n1 banana\n2 cherry",
              "B": "1 apple\n2 banana\n3 cherry",
              "C": "apple 0\nbanana 1\ncherry 2",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "enumerate starts at 0 by default and yields (index, value) pairs."
          },
          {
            "id": "exm-ba031912fa",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 16,
            "week": 2,
            "topic": "zip / looping",
            "question": "What is the output of the following code?\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
            "code_context": "",
            "options": {
              "A": "Alice: 85\nBob: 92\nCharlie: 78",
              "B": "Alice: 92\nBob: 85\nCharlie: 78",
              "C": "Alice Bob Charlie: 85 92 78",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "zip pairs elements positionally. Output: Alice: 85, Bob: 92, Charlie: 78."
          },
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-7f6a7c840f",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 10,
            "week": 3,
            "topic": "nested loops / pairs",
            "question": "You need to write a function main(target_num, list_num) that returns all unique pairs of numbers that add up to target_num.\n\nExample: main(11, [4,5,6,9,3,7,2,8]) should return [(5,6),(4,7),(9,2),(3,8)].\n\nNote: (6,5) is not included since (5,6) is already found.\n\nWhich of the following code snippets achieve what you want?",
            "code_context": "",
            "options": {
              "a": "def main(target_num, list_num):\n\toutput = []\n\tfor i1 in list_num:\n\t\tfor i2 in list_num:\n\t\t\tif i1 + i2 == target_num:\n\t\t\t\toutput.append((i1, i2))\n\treturn output",
              "b": "def main(target_num,list_num):\n\tresult = []\n\tfor numb in range(target_num//2+1):\n\t\tif numb in list_num and target_num-numb in list_num:\n\t\t\tresult.append((numb,target_num-numb))\n\treturn result",
              "c": "Both work.",
              "d": "Neither works."
            },
            "correct": "b",
            "explanation": "Option a produces both (5,6) and (6,5) — it doesn't ensure uniqueness. Option b iterates up to target//2, so each pair is only considered once. For target=11, range(0,6): checks 0,1,2,3,4,5. Finds: 2+9,3+8,4+7,5+6 — unique pairs. Option b works as intended. Option a doesn't meet the uniqueness requirement. Correct: b."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          },
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-1eed6533a3",
            "week": 2,
            "cell_index": 84,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(f\"The country is {key}\")",
            "outputs": []
          },
          {
            "id": "nb-d50eeb7b9a",
            "week": 2,
            "cell_index": 85,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor value in capitals.values():\n    print(f\"The capital is {value}\")",
            "outputs": []
          },
          {
            "id": "nb-f09c460011",
            "week": 2,
            "cell_index": 86,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country, city in capitals.items():\n    print(f\"{country=} and {city=} \")",
            "outputs": []
          },
          {
            "id": "nb-faf3afc44b",
            "week": 2,
            "cell_index": 87,
            "cell_type": "code",
            "topic": "looping_dicts",
            "source": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor country in capitals:\n    print(f\"The country is {country}\")",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "For-loops are used to iterate over items in a sequence, such as a list, string, or a range of numbers. Exam questions often involve tracking the value of an accumulator variable through each loop iteration or determining the final output after the loop completes. Pay close attention to the `range(start, stop)` function, as the loop will not include the `stop` number, and watch for `continue` (skips to next iteration"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the final value of a variable after the loop finishes?",
            "What is the difference between `break` and `continue`?",
            "What items are collected in a list inside a loop?",
            "What is the output of a nested loop structure?",
            "Does `range(a, b)` include the value `b`? (No)",
            "How many times will a given loop run?",
            "What is the value of the outer loop variable during the third iteration of the inner loop?",
            "What's the total number of iterations for `for i in range(4): for j in range(i):`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Iterating Through Dictionary Items",
            "code": "grades = {'Alice': 85, 'Bob': 92}\nfor name, score in grades.items():\n    if score > 90:\n        print(name)",
            "why": "Using `.items()` provides each key-value pair. The code correctly iterates through the pairs, checks if the score is greater than 90, and prints the corresponding name ('Bob').",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Summing with `range()`",
            "code": "total = 0\nfor i in range(1, 5):\n    total += i\nprint(total)",
            "why": "The `range(1, 5)` function generates the numbers 1, 2, 3, and 4. The loop iterates through these numbers, adding each to `total`. The final sum is 1+2+3+4 = 10.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Generate coordinate pairs",
            "code": "points = []\nfor x in range(2):\n    for y in range(3):\n        points.append((x, y))\nprint(len(points))",
            "why": "The outer loop runs 2 times (`x=0`, `x=1`), and for each, the inner loop runs 3 times (`y=0,1,2`). This generates 2 * 3 = 6 total pairs.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Forgetting `.items()` on a Dictionary",
            "code": "data = {'x': 1, 'y': 2}\nfor key, val in data:\n    print(key, val)",
            "why": "Iterating directly over a dictionary (`for ... in data`) only yields the keys. This code tries to unpack each key (e.g., 'x') into two variables (`key`, `val`), causing a `ValueError` because there aren't enough values",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Off-by-One `IndexError`",
            "code": "items = ['a', 'b', 'c']\nfor i in range(len(items)):\n    print(items[i+1])",
            "why": "On the last iteration, `i` is 2. The code then tries to access `items[2+1]`, which is `items[3]`. Since the valid indices are 0, 1, and 2, this causes an `IndexError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Incorrectly referencing loop variable",
            "code": "total = 0\nfor i in range(3):\n    for j in range(4):\n        total += i\nprint(total)",
            "why": "This prints `12`. The inner loop runs 4 times for each `i`. For `i=0`, it adds 0 four times. For `i=1`, it adds 1 four times. For `i=2`, it adds 2 four times. Total is `0*4 + 1*4 + 2*4 = 0+4+8=12`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Dictionary iteration: `for key in dict:` is equivalent to `for key in dict.keys()`; use `.values()` for values, `.items()` for `(key, value)` tuples.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`while condition:` loops execute as long as the condition is `True`; ensure the condition changes to prevent infinite loops.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "n = 3\nwhile n > 0:\n    print(n)\n    n -= 1   # state update prevents infinite loop",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`break` immediately exits the innermost loop; `continue` skips the rest of the current iteration and proceeds to the next.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Loop control quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`break`",
                      "Exit current loop immediately"
                    ],
                    [
                      "`continue`",
                      "Skip rest of current iteration"
                    ],
                    [
                      "`pass`",
                      "Do nothing (placeholder statement)"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`enumerate(sequence)` yields `(index, value)` pairs; `enumerate(sequence, start=N)` begins indexing from `N`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`zip(seq1, seq2)` pairs elements from multiple sequences until the shortest sequence is exhausted.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`range(start, stop)` iterates up to `stop-1`; `range(stop)` iterates `0` to `stop-1`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(list(range(5)))      # [0, 1, 2, 3, 4]\nprint(list(range(2, 6)))   # [2, 3, 4, 5]",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Use `_` as a convention for loop variables when their specific value is not needed inside the loop body.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "Iterate dictionaries using `.keys()`, `.values()`, or `.items()` for key-value pairs, e.g., `for k, v in my_dict.items():`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`break` immediately terminates the loop it resides in; `continue` skips the current iteration and proceeds to the next.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Loop control quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`break`",
                      "Exit current loop immediately"
                    ],
                    [
                      "`continue`",
                      "Skip rest of current iteration"
                    ],
                    [
                      "`pass`",
                      "Do nothing (placeholder statement)"
                    ]
                  ]
                },
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Nested loops iterate fully for each outer loop cycle; inner loop completes `N` times for each outer loop iteration.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "for i in range(2):\n    for j in range(3):\n        print(i, j)\n# inner loop runs 3 times for each i",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-405a1c9038",
          "exm-f49499c6d8",
          "exm-19033dcb2f",
          "exm-6265aa347e",
          "exm-b7bad1b1ce",
          "exm-ba031912fa",
          "exm-e6b8037e2c",
          "exm-7f6a7c840f",
          "exm-f44278f521",
          "exm-3555baf8ba"
        ]
      }
    },
    {
      "id": "topic-function",
      "topic": "Functions",
      "canonical_topic": "fun example",
      "weeks": [
        1,
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 9,
        "by_exam": {
          "trial_midterm": 4,
          "midterm_2024": 3,
          "extra_practice": 1,
          "midterm_2023": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "*args / passing to function",
        "Function definition and calling",
        "Functions — basics",
        "Lambda functions",
        "Methods vs functions",
        "Nested functions and function factories",
        "filter function",
        "filter_function",
        "fun_example",
        "function factories / closures",
        "function_calls",
        "function_definition",
        "function_factories",
        "function_factory / closures",
        "len_function",
        "map function",
        "map_function",
        "nested functions / scope",
        "reduce function",
        "reduce_function"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-805233cb66",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Functions — basics",
            "explanation": "Functions are objects. Defined with def. Called with (). Built-in functions: print, id, len, type, del. Functions can return values. Methods are functions attached to objects.",
            "code_examples": [
              {
                "description": "Simple function",
                "code": "def size(length, width):\n    return length * width\nprint(size(2,3))  # 6"
              }
            ]
          },
          {
            "id": "lec-b5af6f4178",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Function definition and calling",
            "explanation": "def keyword, function name, parameters in parentheses, colon, indented body. Call with round brackets (). Using [] gives TypeError 'not subscriptable'. Using [] on a list with () gives TypeError 'not callable'.",
            "code_examples": [
              {
                "description": "Basic function",
                "code": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)  # 3"
              },
              {
                "description": "Wrong bracket errors",
                "code": "print[1]   # TypeError: 'function' object is not subscriptable\nl1 = [1,2,3]\nl1(1)      # TypeError: 'list' object is not callable"
              }
            ]
          },
          {
            "id": "lec-0a5f25a4f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Lambda functions",
            "explanation": "Anonymous one-line functions. Syntax: lambda params: expression. Equivalent to a regular def but more concise. Most useful with map, filter, reduce, sorted, max.",
            "code_examples": [
              {
                "description": "Lambda basics",
                "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))  # 3\n# Equivalent to:\ndef add_two(x, y):\n    return x + y"
              },
              {
                "description": "map() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))   # [2, 4, 6, 8, 10, 12]\n# Need list() to convert map object to list"
              },
              {
                "description": "filter() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))  # [2, 4, 6] (even numbers)"
              },
              {
                "description": "reduce() with lambda",
                "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))  # 720 (product)\n# reduce with initial value:\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))  # 5"
              },
              {
                "description": "sorted() with key lambda",
                "code": "l1 = ['aaa', 'c', 'baab']\nprint(sorted(l1))                              # ['aaa', 'baab', 'c']\nprint(sorted(l1, key=lambda x: x.count('a'))) # ['c', 'baab', 'aaa']\nprint(sorted(l1, key=len))                    # ['c', 'aaa', 'baab']\n\nd = {'a': 2, 'b': 1}\nprint(max(d.items()))                         # ('b', 1)  ← compares tuples\nprint(max(d.items(), key=lambda x: x[1]))     # ('a', 2)  ← by value"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings — you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable — must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT — captures new string\ns1.upper()       # WRONG — result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable — changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          },
          {
            "id": "lec-870bff9b01",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Nested functions and function factories",
            "explanation": "Functions can be defined inside other functions. The inner function is only visible to the outer function. Functions are objects — a function can return another function (factory pattern).",
            "code_examples": [
              {
                "description": "Function factory",
                "code": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\nadd4 = function_factory(4)\nadd5 = function_factory(5)\nprint(add4(3))  # 7\nprint(add5(3))  # 8"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-4b69d2de00",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 16,
            "week": 3,
            "topic": "map function",
            "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)",
            "code_context": "",
            "options": {
              "A": "[1, 4, 9, 16, 25]",
              "B": "[2, 4, 6, 8, 10]",
              "C": "[1, 2, 3, 4, 5]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "map applies the lambda (x**2) to each element: [1, 4, 9, 16, 25]."
          },
          {
            "id": "exm-42b9531488",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 17,
            "week": 3,
            "topic": "filter function",
            "question": "What is the output of the following code?\n\nnumbers = [1, 2, 3, 4, 5, 6]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)",
            "code_context": "",
            "options": {
              "A": "[1, 3, 5]",
              "B": "[2, 4, 6]",
              "C": "[1, 2, 3, 4, 5, 6]",
              "D": "[]"
            },
            "correct": "B",
            "explanation": "filter keeps elements for which the lambda returns True. Even numbers: [2, 4, 6]."
          },
          {
            "id": "exm-160b2f4876",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 19,
            "week": 3,
            "topic": "function factories / closures",
            "question": "What is the output of the following code?\n\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = make_multiplier(3)\nprint(times3(5))",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "8",
              "C": "3",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "make_multiplier(3) returns a closure that multiplies by 3. times3(5) = 5 * 3 = 15."
          },
          {
            "id": "exm-22f83f65e5",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 23,
            "week": 3,
            "topic": "reduce function",
            "question": "What is the output of the following code?\n\nfrom functools import reduce\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, numbers)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "120",
              "C": "24",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "reduce multiplies left to right: 1*2=2, 2*3=6, 6*4=24, 24*5=120."
          },
          {
            "id": "exm-141dceafbb",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 19,
            "week": 3,
            "topic": "map function",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nresult = list(map(str, lst))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "['1', '2', '3']",
              "C": "['str', 'str', 'str']",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "map(str, lst) converts each integer to string. Result: ['1', '2', '3']."
          },
          {
            "id": "exm-4ed0093860",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 20,
            "week": 3,
            "topic": "filter function",
            "question": "What is the output of the following code?\n\nlst = [0, 1, 2, 0, 3, 0]\nresult = list(filter(None, lst))\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[0, 0, 0]",
              "B": "[1, 2, 3]",
              "C": "[0, 1, 2, 0, 3, 0]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "filter(None, lst) keeps truthy values. 0 is falsy, so it filters out all 0s: [1, 2, 3]."
          },
          {
            "id": "exm-7c32aece02",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 22,
            "week": 3,
            "topic": "function factories / closures",
            "question": "What is the output of the following code?\n\ndef counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())\nprint(c())",
            "code_context": "",
            "options": {
              "A": "1\n1\n1",
              "B": "1\n2\n3",
              "C": "0\n1\n2",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "nonlocal allows increment() to modify count in the enclosing scope. Each call increments count: 1, 2, 3."
          },
          {
            "id": "exm-08341d3aa4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 15,
            "week": 3,
            "topic": "nested functions / scope",
            "question": "What is the output of the following code?\n\ndef outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "None",
              "C": "Error",
              "D": "0"
            },
            "correct": "A",
            "explanation": "inner() can access x from the enclosing scope (closure). Prints 10."
          },
          {
            "id": "exm-16556959b9",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 9,
            "week": 3,
            "topic": "*args / passing to function",
            "question": "Assume sum_even_in_list(l1) filters non-integers and sums even integers.\n\nYou want sum_even_integers that accepts a flexible number of arguments.\n\nFor example: sum_even_integers(1,'2', 3.0, 4) should return 4.\n\nWhich of the following function definitions will work as intended?",
            "code_context": "",
            "options": {
              "a": "def sum_even_integers(*args):\n\treturn sum_even_in_list(args)",
              "b": "def sum_even_integers(*args):\n\treturn sum([x for x in args if type(x) == int and x%2 == 0])",
              "c": "def sum_even_integers(*args):\n\tresult = 0\n\tfor x in args:\n\t\tif type(x) == int and x%2 == 0:\n\t\t\tresult += x\n\treturn result",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: *args creates a tuple, sum_even_in_list accepts any iterable so passing a tuple works. b: list comprehension on tuple works fine. c: direct iteration over tuple works. All three produce the same result. Correct: d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-607f841482",
            "week": 1,
            "cell_index": 58,
            "cell_type": "code",
            "topic": "len_function",
            "source": "print(len(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']))\nprint(len(('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')))\nprint(len({'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'}))\nprint(len({1:'A', 2:'B', 3:'C', 4:'D', 5:'E', 6:'F', 7:'G', 8:'H'}))\nprint(len(('ABCDEFGH')))\ntry:\n    print(len(12345678))\nexcept:\n    print ('Built-in len function cannot be applied on integers or floats')\ntry:\n    print(len(True))\nexcept:\n    print ('Built-in len function cannot be applied on booleans or floats')\nprint(len(str(12345678)))",
            "outputs": []
          },
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-09ab40d9b7",
            "week": 3,
            "cell_index": 1,
            "cell_type": "code",
            "topic": "function_definition",
            "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total",
            "outputs": []
          },
          {
            "id": "nb-447009e81a",
            "week": 3,
            "cell_index": 3,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "a = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-3fc221ef7b",
            "week": 3,
            "cell_index": 4,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "print(adder(1,2))",
            "outputs": []
          },
          {
            "id": "nb-e6cb1c0efc",
            "week": 3,
            "cell_index": 6,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "adder[1,2]",
            "outputs": []
          },
          {
            "id": "nb-0941b44178",
            "week": 3,
            "cell_index": 7,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "adder{1,2}",
            "outputs": []
          },
          {
            "id": "nb-45274c22b1",
            "week": 3,
            "cell_index": 10,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "l1 = [1, 2, 3]\nl1(1)",
            "outputs": []
          },
          {
            "id": "nb-aa2ac816b1",
            "week": 3,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "l1 = [1, 2, 3]\nl1{1}",
            "outputs": []
          },
          {
            "id": "nb-12853105fe",
            "week": 3,
            "cell_index": 13,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "def adder(n1, n2):\n    total = n1 + n2\n    return total\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-59219f177c",
            "week": 3,
            "cell_index": 14,
            "cell_type": "code",
            "topic": "function_calls",
            "source": "n1 = 1\nn2 = 2\ntotal = n1 + n2\na = total\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-eb8335fd0f",
            "week": 3,
            "cell_index": 45,
            "cell_type": "raw",
            "topic": "function_factories",
            "source": "def function_factory(increment):\n    def adder(n1):\n        return n1 + increment\n    return adder\n\nadd4 = function_factory(4)\nadd5 = function_factory (5)\n\nprint(add4(3))\nprint(add5(3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Functions package reusable code under a single name, defined with `def`. Methods are special functions tied to an object's type, like a string or list. In exams, track how methods on mutable objects (like lists) can change them directly ('in-place'), while methods on immutable objects (like strings) always produce a new value that you must save to a variable."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Trace the output of code that swaps variable values without a temporary variable.",
            "What is the final value of a variable after a function or method call?",
            "Why is my string variable unchanged after calling `.upper()` on it?",
            "Does this method modify the list in-place or return a new list?",
            "Is `my_list = sorted(my_list)` correct or incorrect usage?",
            "What does `my_list.sort()` return? (Answer: `None`)",
            "What is the output after calling the factory twice and using both created functions?",
            "Can the inner function access variables from the outer function's scope?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Method on Immutable String (Returns New)",
            "code": "name = 'python'\nname_upper = name.upper() # .upper() returns a new string\nprint(name_upper)\n# Output: PYTHON",
            "why": "Strings are immutable. The `.upper()` method cannot change the original string; it creates and returns a new uppercase string, which is correctly captured in `name_upper`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Method on Mutable List (In-Place)",
            "code": "data = [30, 10, 20]\ndata.sort() # sort() modifies the list directly\nprint(data)\n# Output: [10, 20, 30]",
            "why": "The `.sort()` method operates on the list `data` 'in-place'. It rearranges the existing list and does not return a new one.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Using 'nonlocal' to modify outer scope",
            "code": "def make_counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\nc1 = make_counter()\nprint(c1()) # 1\nprint(c1()) # 2",
            "why": "The 'nonlocal' keyword allows 'increment' to modify the 'count' variable in the outer scope. Without it, trying to do 'count += 1' would cause an error.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Ignoring Return Value from Immutable Method",
            "code": "course = 'intro to python'\ncourse.upper() # This line does nothing useful\nprint(course)\n# Output: intro to python",
            "why": "A common mistake. `.upper()` returns a new string but the result is not assigned to any variable. `course` remains unchanged because strings are immutable.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Misusing an In-Place Method's Return",
            "code": "scores = [9, 7, 8]\nsorted_scores = scores.sort()\nprint(sorted_scores)\n# Output: None",
            "why": "The `.sort()` method sorts a list in-place and always returns `None`. The sorted list is in `scores`, but the variable `sorted_scores` incorrectly captures the `None` return value.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Modifying outer variable without 'nonlocal'",
            "code": "def broken_counter():\n    count = 0\n    def increment():\n        # Missing 'nonlocal count'\n        count += 1\n        return count\n    return increment\n# c = broken_counter()\n# c() # This would raise UnboundLocalError",
            "why": "When 'count += 1' is used, Python treats 'count' as a new local variable in the 'increment' function. Because it hasn't been assigned a value locally before being modified, it raises an 'UnboundLocalError'.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Variable assignment `x = y` makes `x` refer to the same object as `y`; `x = value` makes `x` refer to a new object.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Assignment vs copy",
                "text": "",
                "table": {
                  "headers": [
                    "Statement",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "`y = x`",
                      "Alias: both names point to same object"
                    ],
                    [
                      "`y = x[:]` / `x.copy()`",
                      "New shallow copy (list)"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [1, 2]\nb = a\nb.append(3)\nprint(a)           # [1, 2, 3] (same object)\nc = a[:]\nc.append(4)\nprint(a, c)        # [1, 2, 3], [1, 2, 3, 4]",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`list.sort()` mutates in place and returns `None`; `sorted(iterable)` returns a new sorted list.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "In-place vs new object",
                "text": "",
                "table": {
                  "headers": [
                    "Operation",
                    "Mutates original?",
                    "Return value"
                  ],
                  "rows": [
                    [
                      "`lst.sort()`",
                      "Yes",
                      "`None`"
                    ],
                    [
                      "`sorted(lst)`",
                      "No",
                      "New sorted list"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "lst = [3, 1, 2]\nresult = lst.sort()      # lst becomes [1, 2, 3]\nprint(result)            # None\nnew_lst = sorted(lst)    # new list object",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "String methods like `.upper()` return a new string; original string objects are immutable and remain unchanged.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'uva'\ns.upper()          # ignored result\nprint(s)           # 'uva'\ns = s.upper()\nprint(s)           # 'UVA'",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Methods attached to mutable objects may modify the object in-place (e.g., `list.append()`, `list.pop()`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Function definition uses `def` and parameters; function call uses `()` and arguments.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def add(a, b):\n    return a + b\n\nresult = add(2, 3)\nprint(result)  # 5",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Methods that mutate mutable objects (e.g., `list.sort()`) return `None`; methods on immutable objects (e.g., `str.upper()`) return new objects.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'uva'\ns.upper()          # ignored result\nprint(s)           # 'uva'\ns = s.upper()\nprint(s)           # 'UVA'",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "The `nonlocal` keyword modifies a variable in the nearest enclosing non-global scope; without it, assignment creates a new local variable.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Function factories return functions, capturing and retaining the state (enclosing scope variables) from their creation context.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "A closure (or factory function) is an inner function retaining access to variables from its enclosing scope, even after the outer function completes.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def make_adder(k):\n    def add(x):\n        return x + k\n    return add\n\nadd5 = make_adder(5)\nprint(add5(3))   # 8",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Assigning to an outer variable without `nonlocal` in an inner function creates a new local variable, not modifying the outer one.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def outer():\n    n = 0\n    def bad():\n        n = n + 1   # UnboundLocalError\n    def good():\n        nonlocal n\n        n += 1",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-160b2f4876",
          "exm-7c32aece02",
          "exm-08341d3aa4",
          "lec-8bc2ca06f4",
          "lec-805233cb66",
          "lec-870bff9b01",
          "lec-b5af6f4178",
          "nb-711110ef0a",
          "nb-eb8335fd0f",
          "nb-09ab40d9b7"
        ]
      }
    },
    {
      "id": "topic-indexing",
      "topic": "Indexing",
      "canonical_topic": "indexing",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 8,
        "by_exam": {
          "extra_practice": 3,
          "midterm_2024": 2,
          "trial_midterm": 2,
          "midterm_2023": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Indexing",
        "dict / nested indexing",
        "dictionaries / indexing",
        "dictionaries / nested dicts",
        "indexing",
        "indexing / negative",
        "indexing / slicing",
        "indexing / type_conversion",
        "string indexing",
        "type conversion",
        "type conversion / indexing",
        "type_conversion"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-3c6bbdd9be",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Indexing",
            "explanation": "Forward: 0, 1, 2, ... len-1. Backward: -1 (last), -2 (second to last), ..., -len (first). l1[0] == l1[-len(l1)]",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-1b0f40ae76",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 1,
            "week": 1,
            "topic": "indexing / slicing",
            "question": "What is the output of the following code?\n\nx = 'Hello, World!'\nprint(x[-6:-1])",
            "code_context": "",
            "options": {
              "A": "World",
              "B": "orld!",
              "C": "World!",
              "D": "orld"
            },
            "correct": "A",
            "explanation": "x[-6:-1] starts 6 from the end ('W') and goes to 1 from the end (exclusive of '!'). That gives 'World'."
          },
          {
            "id": "exm-db07780cd0",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 3,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nx = '5'\ny = 2\nprint(x * y)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "52",
              "C": "55",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "String * integer repeats the string. '5' * 2 = '55'."
          },
          {
            "id": "exm-5c2740063a",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 4,
            "week": 1,
            "topic": "indexing / negative",
            "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[-2])",
            "code_context": "",
            "options": {
              "A": "20",
              "B": "30",
              "C": "40",
              "D": "50"
            },
            "correct": "C",
            "explanation": "lst[-2] is the second-to-last element: 40."
          },
          {
            "id": "exm-edec745151",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 5,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nprint(int('42') + float('3.5'))",
            "code_context": "",
            "options": {
              "A": "45",
              "B": "45.5",
              "C": "'423.5'",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "int('42')=42, float('3.5')=3.5. 42 + 3.5 = 45.5."
          },
          {
            "id": "exm-14f703ef57",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 4,
            "week": 1,
            "topic": "string indexing",
            "question": "What is the output of the following code?\n\ns = 'Python'\nprint(s[1:4])",
            "code_context": "",
            "options": {
              "A": "Pyt",
              "B": "yth",
              "C": "ytho",
              "D": "ython"
            },
            "correct": "B",
            "explanation": "s[1:4] gives characters at indices 1, 2, 3: 'y', 't', 'h' = 'yth'."
          },
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-fd0aa669b7",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 8,
            "week": 2,
            "topic": "dictionaries / indexing",
            "question": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\n\nWhich of the following lines of code will print True?",
            "code_context": "",
            "options": {
              "a": "print(x['a'][1] * x['b'][0] == x['c'][1])",
              "b": "print(x['b'][0] + x['c'][0] == x['d'][1])",
              "c": "print(x['d'][0] - x['c'][0] == x['a'][1])",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: x['a'][1]=2, x['b'][0]=3, 2*3=6, x['c'][1]=6. True. b: x['b'][0]=3, x['c'][0]=5, 3+5=8, x['d'][1]=8. True. c: x['d'][0]=7, x['c'][0]=5, 7-5=2, x['a'][1]=2. True. All are True, so d is correct."
          },
          {
            "id": "exm-bd5df4659c",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 11,
            "week": 1,
            "topic": "type conversion / indexing",
            "question": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\n\nWhat is the output of the following code snippet?\n\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
            "code_context": "",
            "options": {
              "a": "SyntaxError",
              "b": "IndexError: list index out of range",
              "c": "False",
              "d": "True"
            },
            "correct": "d",
            "explanation": "x[2] = (1,2). x[2][0]=1, x[2][1]=2. 1+2=3. float(3)=3.0. type(3.0)=float. x[-2]=3.0 (index 5). type(3.0)=float. float==float → True."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-8ea9af8f8b",
            "week": 1,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(int('123'))\nprint(float('123'))\n\nprint(str(123))\nprint(float(123))\n\nprint(int(123.0))\nprint(str(123.0))",
            "outputs": []
          },
          {
            "id": "nb-c488bc51d9",
            "week": 1,
            "cell_index": 24,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "integer_list = [1, 2, 3, 1]\nletter_list = ['a', 'b', 'c', 'd']\nprint(set(integer_list))\nprint(tuple(integer_list))\nprint(dict(zip(letter_list, integer_list)))\n\ninteger_tuple = (1, 2, 3, 1)\nletter_tuple = ('a', 'b', 'c', 'd')\nprint(set(integer_tuple))\nprint(list(integer_tuple))\nprint(dict(zip(letter_tuple, integer_tuple)))\n\ninteger_set = {1, 2, 3}\nletter_set = {'a', 'b', 'c'}\nprint(list(integer_set))\nprint(tuple(letter_set))\nprint(dict(zip(integer_set, letter_set)))\n\nd_1 = {1: 'c', 2: 'b', 3: 'a'}\nprint(list(d_1))\nprint(tuple(d_1))\nprint(set(d_1))",
            "outputs": []
          },
          {
            "id": "nb-a8e98f1319",
            "week": 1,
            "cell_index": 60,
            "cell_type": "code",
            "topic": "indexing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6] == 'G')\nprint(l1[6] == l1[-2])\nprint(l1[7] == 'H')\nprint(l1[7] == l1[-1])\nprint(l1[len(l1)-1] == l1[-1])\nprint(l1[len(l1)])",
            "outputs": []
          },
          {
            "id": "nb-b60399a503",
            "week": 2,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1 + True, 1.0 + False, True + False)",
            "outputs": []
          },
          {
            "id": "nb-01f6077d4d",
            "week": 2,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1==1.0, 1.0 == True, 0 == False)",
            "outputs": []
          },
          {
            "id": "nb-3f066f26aa",
            "week": 2,
            "cell_index": 106,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print ('1' * 2, '1' * True, '1' * False)",
            "outputs": []
          },
          {
            "id": "nb-a358f49009",
            "week": 2,
            "cell_index": 114,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print ('1' + 2)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-3bd8e4f40b",
            "week": 2,
            "cell_index": 117,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(str(1) == '1')\nprint(int('1') == 1)",
            "outputs": []
          },
          {
            "id": "nb-614c69b0f2",
            "week": 2,
            "cell_index": 118,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(float('1') == 1.0)\nprint(float('1.0') == 1.0)  \nprint(tuple([1,2,3]) == (1,2,3))  \nprint(tuple({1:3, 2:4}) == (1,2))  \nprint(dict([(1,3), (2,4)]) == {1: 3, 2:4})",
            "outputs": []
          },
          {
            "id": "nb-4a7fe9bef0",
            "week": 2,
            "cell_index": 119,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(int('1a') == 1)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-66deb9932d",
            "week": 2,
            "cell_index": 120,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(dict([1, 2]))\nexcept Exception as e:\n    print(e)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Indexing allows you to access individual elements in ordered data types like lists, tuples, and strings. Python uses zero-based indexing, where the first element is at index 0. Negative indexing provides a convenient way to access elements from the end of the sequence, where -1 is the last element. Slicing, using the `[start:stop]` syntax, extracts a portion of a sequence, but it's crucial to remember that the eleme"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What error occurs if you use an index that is too large? (`IndexError`)",
            "How do you get the last N elements of a sequence?",
            "What is the index of the first element?",
            "What is the index of the last element?",
            "What does the slice `s[1:4]` include?",
            "What does `my_list[-1]` return?",
            "In a complex expression, what is the data type after multiple indexing and conversion steps?",
            "What is the output of multiplying a string by an integer (e.g., `'5' * 2`)?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Slicing a String",
            "code": "word = 'programming'\n# Get characters from index 3 up to (but not including) 7\nprint(word[3:7])",
            "why": "The slice `[3:7]` starts at index 3 ('g') and extracts all characters up to index 7. This includes characters at indices 3, 4, 5, and 6, resulting in the substring 'gram'.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Accessing with a Negative Index",
            "code": "letters = ['a', 'b', 'c', 'd', 'e']\nprint(letters[-2])",
            "why": "Negative indexing counts from the end of the list. `letters[-1]` is the last element ('e'), so `letters[-2]` is the second-to-last element, which is 'd'.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "String to Number Conversion",
            "code": "val_str = '42'\nval_float = '3.5'\nresult = int(val_str) + float(val_float)\nprint(result)",
            "why": "The `int()` and `float()` functions correctly convert the string representations of numbers into actual numeric types, allowing for mathematical addition. The result is 45.5.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Forgetting the Slice `stop` is Exclusive",
            "code": "numbers = [1, 2, 3, 4, 5]\n# Goal: Get the first three numbers [1, 2, 3]\n# Mistake: The stop index should be 3, not 2\nprint(numbers[0:2])",
            "why": "The stop index in a slice is exclusive. `numbers[0:2]` extracts elements at index 0 and 1, but stops *before* index 2. The output is `[1, 2]`, not the intended `[1, 2, 3]`. The correct slice would be `numbers[0:3]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Index Out of Range",
            "code": "my_list = [10, 20, 30]\n# The highest index is 2, so this will fail\nprint(my_list[3])",
            "why": "In a list of 3 elements, the valid indices are 0, 1, and 2. Attempting to access an element at index 3, which does not exist, results in an `IndexError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Invalid Conversion to Integer",
            "code": "val = '9.9'\nnum = int(val)\nprint(num)",
            "why": "This causes a `ValueError`. The `int()` function cannot parse a string containing a decimal point. To fix this, you must first convert the string to a float: `int(float(val))`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Forward indexing starts at `0` for the first element; backward indexing uses `-1` for the last element, `-len(seq)` for the first.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "seq = ['a', 'b', 'c', 'd']\nprint(seq[0])    # 'a'\nprint(seq[-1])   # 'd'\nprint(seq[-4])   # 'a'",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Omitting `start` in a slice defaults to `0` (e.g., `seq[:end]`); omitting `end` defaults to `len(seq)` (e.g., `seq[start:]`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-3",
            "text": "Accessing a sequence with an index outside its valid range (0 to `len-1` or -1 to `-len`) raises an `IndexError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-4",
            "text": "`seq[-N:]` returns the last `N` elements of a sequence; `seq[:N]` returns the first `N` elements.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Slice `seq[start:end]` includes elements from `start` up to, but not including, `end`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "Negative indexing accesses elements from the end: `lst[-1]` is the last, `lst[-N]` is the Nth from last.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "seq = ['a', 'b', 'c', 'd']\nprint(seq[0])    # 'a'\nprint(seq[-1])   # 'd'\nprint(seq[-4])   # 'a'",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`int()` converts string digits to integers; `int('3.14')` raises `ValueError`, convert to `float` first.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "String multiplication (`'str' * N`) repeats the string N times; `int * int` performs arithmetic.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "String concatenation (`'1' + '2'`) joins strings; `1 + 2` performs arithmetic summation.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "Attempting to access a non-existent key at any dictionary level raises a `KeyError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Missing-key behavior",
                "text": "",
                "table": {
                  "headers": [
                    "Access form",
                    "Missing key result"
                  ],
                  "rows": [
                    [
                      "`d[key]`",
                      "`KeyError`"
                    ],
                    [
                      "`d.get(key)`",
                      "`None` (or provided default)"
                    ]
                  ]
                },
                "id": "kp-10-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "d = {'x': 10}\nprint(d.get('y', 0))   # 0\n# d['y'] would raise KeyError",
                "id": "kp-10-d2"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-1b0f40ae76",
          "exm-14f703ef57",
          "exm-5c2740063a",
          "exm-fd0aa669b7",
          "exm-db07780cd0",
          "exm-edec745151",
          "exm-f44278f521",
          "lec-3c6bbdd9be",
          "nb-a8e98f1319",
          "nb-8ea9af8f8b"
        ]
      }
    },
    {
      "id": "topic-dict",
      "topic": "Dictionaries",
      "canonical_topic": "dictionary",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 8,
        "by_exam": {
          "extra_practice": 5,
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Dictionaries",
        "Lists vs Dictionaries vs Sets — ordered/unordered",
        "Looping over dictionaries",
        "dict / in operator",
        "dictionaries",
        "dictionaries / average",
        "dictionaries / indexing",
        "dictionaries / nested dicts",
        "dictionaries / zip / counting",
        "dictionary",
        "dictionary / methods",
        "enumerate / dictionaries / conditions",
        "looping_dicts"
      ],
      "trap_patterns": [
        {
          "pattern": "dict 'in' checks KEYS not values",
          "trap": "4 in {1:4, 2:3} → False (4 is a value, not a key)",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2024"
          ]
        },
        {
          "pattern": "Empty set: {} creates dict, not set",
          "trap": "s = {} → empty dict. s = set() → empty set",
          "weeks": [
            2
          ],
          "appears_in_exams": []
        },
        {
          "pattern": "dict to tuple gives keys only",
          "trap": "tuple({1:'a',2:'b'}) → (1,2) — only keys, not values or items",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "trial_midterm"
          ]
        },
        {
          "pattern": "for key in dict == for key in dict.keys()",
          "trap": "Looping directly over a dict iterates over keys only",
          "weeks": [
            2
          ],
          "appears_in_exams": [
            "midterm_2023"
          ]
        },
        {
          "pattern": "RuntimeError: dictionary changed size during iteration",
          "trap": "Adding or deleting dict entries while iterating over it causes RuntimeError",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' — this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-c54469d107",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Lists vs Dictionaries vs Sets — ordered/unordered",
            "explanation": "Lists, tuples, strings are SEQUENCES (ordered). Dicts and sets are NOT sequences (unordered for equality). All are called collections.",
            "code_examples": [
              {
                "description": "Ordering comparison",
                "code": "print([1,2] == [2,1])        # False (ordered)\nprint((1,2) == (2,1))        # False (ordered)\nprint('12' == '21')          # False (ordered)\nprint({1,2} == {2,1})        # True  (unordered)\nprint({1:1,2:2}=={2:2,1:1})  # True  (unordered)"
              }
            ]
          },
          {
            "id": "lec-5ae780c366",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Looping over dictionaries",
            "explanation": ".keys() → key sequence. .values() → value sequence. .items() → sequence of (key, value) tuples. 'for key in dict' is the same as 'for key in dict.keys()'.",
            "code_examples": [
              {
                "description": "Looping over dict",
                "code": "capitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nfor key in capitals.keys():\n    print(key)\nfor val in capitals.values():\n    print(val)\nfor key, value in capitals.items():\n    print(key, value)\n# These two are equivalent:\nfor key in capitals:\nfor key in capitals.keys():"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-f44278f521",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 3,
            "week": 2,
            "topic": "dictionaries / nested dicts",
            "question": "Adelbrecht and Hortensia competed in a game. You have a dictionary with two subdictionaries:\n\nresults = {'Adelbrecht':{'attempt1':3,'attempt2':2,'attempt3':6},'Hortensia':{'attempt1':1,'attempt2':6}}\n\nYou would like to create a dictionary in which the keys are the highest and lowest scores and the values are a list of names of the players that attained the corresponding scores.\n\nWhich of the following code snippets implements this?",
            "code_context": "",
            "options": {
              "a": "Snippet using allscores list + max/min",
              "b": "Snippet using nested max/min directly on scorelist.values()",
              "c": "Both code snippets will work as intended.",
              "d": "Neither code snippet will work as intended."
            },
            "correct": "c",
            "explanation": "Both snippets correctly find the global max (6) and min (1), then iterate to find which players achieved those scores. Both produce the same correct output. Note: both Adelbrecht and Hortensia achieved score 6, so winners = ['Adelbrecht', 'Hortensia']."
          },
          {
            "id": "exm-d0901c699d",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 4,
            "week": 2,
            "topic": "dictionaries / average",
            "question": "math_scores = {'John': 85, 'Sarah': 92, 'Michael': 78, 'Emma': 90, 'David': 82}\n\nYou want to find and print the names of the students who scored above the average score.\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "average_score = sum(math_scores.values())/len(math_scores)\n\tfor student in math_scores.keys():\n\t\tif math_scores[student] > average_score:\n\t\t\tprint(student)",
              "b": "for student in math_scores:\n\tif math_scores[student] > (sum(math_scores.values())/len(math_scores)):\n\t\tprint(student)",
              "c": "Both code segments will work as intended.",
              "d": "Neither code segment will work as intended."
            },
            "correct": "b",
            "explanation": "Option a has an indentation error (the for loop is indented under the average_score line as if it's a block, but there's no colon). This causes an IndentationError. Option b works correctly. Actually option a depends on whether the indentation shown is a tab after a plain statement — in Python that's an IndentationError. So only b works. Correct: b."
          },
          {
            "id": "exm-f6de891c85",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 5,
            "week": 2,
            "topic": "dictionaries / zip / counting",
            "question": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\nYou need to create a dictionary called grade_counts that counts the number of students in each grade level.\n\nExpected: {9:3, 10:2, 11:1}\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "grade_counts = {}\nfor grade in grades:\n\tif grade not in grade_counts:\n\t\tgrade_counts[grade] = 0\n\tgrade_counts[grade] += 1",
              "b": "grade_counts = {}\nfor student, grade in zip(students, grades):\n\tif grade in grade_counts:\n\t\tgrade_counts[grade].append(student)\n\telse:\n\t\tgrade_counts[grade] = [student]",
              "c": "Both of the given options will work as intended.",
              "d": "Neither of the given options will work as intended."
            },
            "correct": "a",
            "explanation": "Option a correctly counts grades: initialises to 0 and increments. Produces {9:3, 10:2, 11:1}. Option b creates lists of student names, not counts — produces {9:['A','C','F'], 10:['B','E'], 11:['D']}, not the required format. Correct: a."
          },
          {
            "id": "exm-fd0aa669b7",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 8,
            "week": 2,
            "topic": "dictionaries / indexing",
            "question": "x = {'a': [1, 2], 'b':[3, 4], 'c':[5, 6], 'd':[7, 8]}\n\nWhich of the following lines of code will print True?",
            "code_context": "",
            "options": {
              "a": "print(x['a'][1] * x['b'][0] == x['c'][1])",
              "b": "print(x['b'][0] + x['c'][0] == x['d'][1])",
              "c": "print(x['d'][0] - x['c'][0] == x['a'][1])",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: x['a'][1]=2, x['b'][0]=3, 2*3=6, x['c'][1]=6. True. b: x['b'][0]=3, x['c'][0]=5, 3+5=8, x['d'][1]=8. True. c: x['d'][0]=7, x['c'][0]=5, 7-5=2, x['a'][1]=2. True. All are True, so d is correct."
          },
          {
            "id": "exm-f358fb2d91",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 12,
            "week": 2,
            "topic": "enumerate / dictionaries / conditions",
            "question": "def counter(y):\n\tx = {}\n\tfor index, element in enumerate(y):\n\t\tif index != int(element) and int(element) % 2 == 0:\n\t\t\tx[element] = len(element)\n\treturn x\n\nWhat will this function return when called as:\ncounter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])",
            "code_context": "",
            "options": {
              "a": "{'12345678': 8, '1234': 4, '12': 2, '123456': 6}",
              "b": "{'12345678': 8, '123': 3, '1234': 4, '12345': 5, '12': 2, '6': 1, '1': 1, '123456': 6}",
              "c": "{'123': 3, '12345': 5, '1': 1}",
              "d": "{'12345678': 8, '1': 1, '1234': 4, '12': 2, '6': 1, '123456': 6}"
            },
            "correct": "a",
            "explanation": "index 0: '12345678', int=12345678, index(0)!=12345678 ✓, even ✓ → add, len=8. index 1: '1', int=1, index==int → skip. index 2: '123', int=123, odd → skip. index 3: '1234', int=1234, index(3)!=1234 ✓, even ✓ → add, len=4. index 4: '12345', int=12345, odd → skip. index 5: '12', int=12, index(5)!=12 ✓, even ✓ → add, len=2. index 6: '6', int=6, index(6)==6 → skip. index 7: '1', int=1, odd → skip. index 8: '123456', int=123456, index(8)!=123456 ✓, even ✓ → add, len=6. Result: {'12345678':8,'1234':4,'12':2,'123456':6}. Correct: a."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Dictionaries map unique, hashable keys to values and are optimized for fast key-based lookups. In exam questions, the biggest traps are membership and missing-key behavior: `key in d` checks keys only (not values), and `d[key]` raises `KeyError` when the key is absent. Use `d.get(key, default)` for safe access, and use `d.items()` when you need both keys and values during iteration. Also watch for structure pitfalls such as using mutable keys, confusing `{}` with `set()`, or modifying a dictionary while iterating over it."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Does `key in d` check keys or values?",
            "What is the difference between `d[key]` and `d.get(key, default)`?",
            "What happens when you access a missing key directly?",
            "How do you iterate over both keys and values at the same time?",
            "What does `list(d)` return for a dictionary?",
            "Why can't a `list` be used as a dictionary key?",
            "Why does deleting keys while iterating raise `RuntimeError`?",
            "How do `d1.update(d2)` and `{**d1, **d2}` differ?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Safe Access with `.get()`",
            "code": "settings = {'theme': 'dark'}\n\n# 'font' key does not exist, so .get() returns the default 'Arial'\nfont = settings.get('font', 'Arial')\nprint(font)",
            "why": "Unlike `settings['font']` which would raise a `KeyError`, `settings.get('font', ...)` safely checks for the key. If the key is not found, it returns the provided default value instead of erroring.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Building a Frequency Counter",
            "code": "text = 'hello'\ncounts = {}\nfor char in text:\n    counts[char] = counts.get(char, 0) + 1\nprint(counts['l'])",
            "why": "This is an efficient pattern for counting. `counts.get(char, 0)` returns the current count if the character exists, or 0 if it's the first time seeing it, avoiding a `KeyError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-3",
            "kind": "incorrect",
            "title": "Using a List as a Key",
            "code": "cache = {}\nkey = [1, 2, 3]\n\n# This will fail because lists are mutable\ncache[key] = 'some_data'",
            "why": "Dictionary keys must be immutable (i.e., they cannot be changed). Since lists are mutable, they cannot be used as dictionary keys, resulting in a `TypeError: unhashable type: 'list'`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Converting a Dictionary to a Tuple",
            "code": "data = {'a': 1, 'b': 2}\n\n# This only converts the keys, not the values\nt = tuple(data)\nprint(t)",
            "why": "When a dictionary is converted directly to a tuple or list, only its keys are used. The result is `('a', 'b')`, not `(('a', 1), ('b', 2))` as might be expected. To get pairs, you must use `tuple(data.items())`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Modifying During Iteration",
            "code": "data = {'a': 1, 'b': 2, 'c': 3}\nfor key, val in data.items():\n    if val % 2 == 0:\n        del data[key]",
            "why": "This raises a `RuntimeError`. A dictionary's size cannot be changed while iterating over it. To fix this, iterate over a copy, like `list(data.items())`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`key in d` checks for keys only. To test values, use `value in d.values()`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "d = {'x': 1}\nprint('x' in d)            # True\nprint(1 in d)              # False\nprint(1 in d.values())     # True",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Dictionary keys must be immutable/hashable (e.g., `str`, `int`, `tuple`). Mutable types like `list` cannot be keys (`TypeError`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge",
            "details": [
              {
                "kind": "table",
                "title": "Hashable key quick check",
                "text": "",
                "table": {
                  "headers": [
                    "Type",
                    "Valid as dict key?"
                  ],
                  "rows": [
                    [
                      "`str`, `int`, `tuple`",
                      "Yes"
                    ],
                    [
                      "`list`, `dict`, `set`",
                      "No (mutable/unhashable)"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              },
              {
                "kind": "table",
                "title": "Mutable vs immutable",
                "text": "",
                "table": {
                  "headers": [
                    "Category",
                    "Examples",
                    "Can change in place?"
                  ],
                  "rows": [
                    [
                      "Mutable",
                      "`list`, `dict`, `set`",
                      "Yes"
                    ],
                    [
                      "Immutable",
                      "`int`, `str`, `tuple`, `bool`",
                      "No"
                    ]
                  ]
                },
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`d[key]` raises `KeyError` for missing keys; `d.get(key, default)` returns a fallback instead of failing.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge",
            "details": [
              {
                "kind": "table",
                "title": "Missing-key behavior",
                "text": "",
                "table": {
                  "headers": [
                    "Access form",
                    "Missing key result"
                  ],
                  "rows": [
                    [
                      "`d[key]`",
                      "`KeyError`"
                    ],
                    [
                      "`d.get(key)`",
                      "`None` (or provided default)"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "d = {'x': 10}\nprint(d.get('y', 0))   # 0\n# d['y'] would raise KeyError",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Use `for k, v in d.items()` for key-value pairs; `for k in d` / `d.keys()` yields keys; `d.values()` yields values.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`list(d)` and `tuple(d)` return keys only; use `.items()` when you need key-value pairs.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge"
          },
          {
            "id": "kp-6",
            "text": "`{}` creates an empty dictionary; use `set()` for an empty set.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "empty_dict = {}\nempty_set = set()\nprint(type(empty_dict).__name__)  # dict\nprint(type(empty_set).__name__)   # set",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Do not add/remove dictionary entries while iterating over `d.items()`; this raises `RuntimeError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge"
          },
          {
            "id": "kp-8",
            "text": "Combine dictionaries with `d1.update(d2)` (in-place) or `{**d1, **d2}` (new dictionary).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "manual-merge"
          }
        ],
        "recommended_ids": [
          "exm-3555baf8ba",
          "exm-4cee2500a8",
          "exm-57e3a8ca18",
          "exm-f44278f521",
          "exm-f6de891c85",
          "lec-27dc11e221",
          "lec-5ae780c366",
          "nb-24dbf7c985"
        ]
      }
    },
    {
      "id": "topic-dictionarie-list-ordered-sets-unordered",
      "topic": "Sets",
      "canonical_topic": "sets",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 6,
        "by_exam": {
          "midterm_2023": 2,
          "midterm_2024": 2,
          "extra_practice": 1,
          "trial_midterm": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Dictionaries",
        "Lists vs Dictionaries vs Sets — ordered/unordered",
        "Sets",
        "dictionaries",
        "lists",
        "lists / sets / duplicates",
        "sets"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-27dc11e221",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Dictionaries",
            "explanation": "Sets of key:value pairs. Keys must be unique and immutable (hashable). Dictionaries are unordered for equality ({1:1,2:2}=={2:2,1:1} is True). Cannot be sorted. You can check membership with 'in' — this checks KEYS only. Keys() gives key sequence, values() gives value sequence, items() gives tuples.",
            "code_examples": [
              {
                "description": "Creating and using dicts",
                "code": "capitals = {}\ncapitals = dict()\ncapitals = {'Andorra': 'Andorra la Vella', 'Belgium': 'Brussels'}\nprint(capitals['Belgium'])         # Brussels\ndel(capitals['Belgium'])           # delete key\ncapitals['Netherlands'] = 'Amsterdam'  # insert/update\ncapitals.update({'France': 'Paris'})   # insert/update multiple"
              },
              {
                "description": "Dict membership checks KEYS, not values",
                "code": "d = {1: 4, 2: 3}\nprint(1 in d)   # True  (1 is a key)\nprint(4 in d)   # False (4 is a value, not a key)"
              },
              {
                "description": "Creating dict from two lists",
                "code": "l1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)  # {1:1, 2:4, 3:9, 4:16}"
              },
              {
                "description": "Dict equality ignores order",
                "code": "print({1:1, 2:2} == {2:2, 1:1})  # True\nprint([1,2] == [2,1])            # False"
              }
            ]
          },
          {
            "id": "lec-c54469d107",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Lists vs Dictionaries vs Sets — ordered/unordered",
            "explanation": "Lists, tuples, strings are SEQUENCES (ordered). Dicts and sets are NOT sequences (unordered for equality). All are called collections.",
            "code_examples": [
              {
                "description": "Ordering comparison",
                "code": "print([1,2] == [2,1])        # False (ordered)\nprint((1,2) == (2,1))        # False (ordered)\nprint('12' == '21')          # False (ordered)\nprint({1,2} == {2,1})        # True  (unordered)\nprint({1:1,2:2}=={2:2,1:1})  # True  (unordered)"
              }
            ]
          },
          {
            "id": "lec-a3e5177371",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Sets",
            "explanation": "Unordered collection of unique values. Empty set MUST be set() — {} creates empty dict. Elements must be immutable. No indexing. Methods: .add(), .remove(), .update().",
            "code_examples": [
              {
                "description": "Set operations",
                "code": "countries = set()           # empty set (NOT {})\ncountries = {'Andorra', 'Belgium'}\nprint({1,2,2} == {2,1})     # True (duplicates ignored)\nprint(len({1,2,2}))         # 2\ncountries.remove('Andorra')\ncountries.add('Greece')\ncountries.update({'Spain', 'Italy'})"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-3555baf8ba",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 6,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nprint('d' in d)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "'in' on a dict checks keys. 'd' is not a key in d, so the result is False."
          },
          {
            "id": "exm-57e3a8ca18",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 7,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'x': 1, 'y': 2, 'z': 3}\ndel d['y']\nprint(d)",
            "code_context": "",
            "options": {
              "A": "{'x': 1, 'z': 3}",
              "B": "{'x': 1, 'y': 2, 'z': 3}",
              "C": "{'y': 2}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "del removes key 'y'. Remaining dict: {'x': 1, 'z': 3}."
          },
          {
            "id": "exm-35a84b1549",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 8,
            "week": 2,
            "topic": "sets",
            "question": "What is the output of the following code?\n\ns = {1, 2, 3, 2, 1}\nprint(len(s))",
            "code_context": "",
            "options": {
              "A": "5",
              "B": "3",
              "C": "2",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Sets do not allow duplicates. {1,2,3,2,1} has 3 unique elements."
          },
          {
            "id": "exm-4cee2500a8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 5,
            "week": 2,
            "topic": "dictionaries",
            "question": "What is the output of the following code?\n\nd = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(len(d))",
            "code_context": "",
            "options": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "After adding key 'c', the dictionary has 3 keys: 'a', 'b', 'c'. len(d) = 3."
          },
          {
            "id": "exm-989ce43b0f",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 6,
            "week": 2,
            "topic": "lists",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[1, 2, 3, 4]",
              "B": "[1, 2, 3, 4]\n[1, 2, 3, 4]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "lst[:] creates a shallow copy. Modifying lst2 does not affect lst. lst stays [1,2,3], lst2 becomes [1,2,3,4]."
          },
          {
            "id": "exm-925d0ec004",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 1,
            "week": 2,
            "topic": "lists / sets / duplicates",
            "question": "Suppose you have the following function:\n\ndef func1(l1):\n    return len(list(l1))==len(set(l1))\n\nWhich of the functions below returns the same values as the function above, if we call it in any of the following ways?\n\nfunc1(l1 = [1,2,3])\nfunc1(l1 = [1,2,2])\nfunc1(l1 = (1,2,2))",
            "code_context": "",
            "options": {
              "a": "def func1(l1):\n    counter = 0\n    for element in l1:\n        if l1.count(element)>1:\n            counter += 1\n    return (counter == 0)",
              "b": "def func1(l1):\n    counter = []\n    for element in l1:\n        if element in l1[l1.index(element)+1:]:\n            counter.append(element)\n    return (len(counter) == 0)",
              "c": "Neither function returns the same values.",
              "d": "Both functions return the same values."
            },
            "correct": "d",
            "explanation": "Option a: for (1,2,2), tuple has no .count() — wait, actually tuples DO have .count(). For [1,2,2]: element 2 has count>1 so counter=2, returns False. Original returns False. But for a tuple (1,2,2): tuple has .count(), works. But option b: l1[l1.index(element)+1:] — tuples support slicing and indexing too. Let's re-examine: for a tuple (1,2,2), both a and b should work the same. Actually option a counts ALL duplicated elements (counts 2 twice for [1,2,2]), making counter=2, so counter==0 is False. Original is False too. Both match. For option b applied to tuple: l1[l1.index(element)+1:] works for tuples too. Actually both a and b return same values as original. Correct: d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-01862d7806",
            "week": 2,
            "cell_index": 9,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])",
            "outputs": []
          },
          {
            "id": "nb-9522b948d8",
            "week": 2,
            "cell_index": 11,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "countries = ['Estonia', 'Belgium', 'France']\ncapitals = ['Tallinn', 'Brussels', 'Paris']\nprint(capitals[countries.index('Belgium')])\nprint(countries[capitals.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-4190a627f2",
            "week": 2,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = ['Estonia', 'Tallin', 'Belgium', 'Brussels', 'France', 'Paris']\nprint(capitals[capitals.index('Belgium') + 1])\nprint(capitals[capitals.index('Tallin') - 1])",
            "outputs": []
          },
          {
            "id": "nb-59478a0652",
            "week": 2,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ({1:1, 2:2} == {2:2, 1:1})",
            "outputs": []
          },
          {
            "id": "nb-3913d4091f",
            "week": 2,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "print ([1,2] == [2,1])",
            "outputs": []
          },
          {
            "id": "nb-ffa4a4d1ba",
            "week": 2,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "capitals = {'Estonia': 'Tallinn', 'Belgium': 'Brussels', 'France': 'Paris'}\nprint(capitals['Belgium'])\nlkeys = list(capitals.keys())        # This generates a list of all keys\nlvalues = list(capitals.values())    # This generates a list of all values\nprint(lkeys[lvalues.index('Tallinn')])",
            "outputs": []
          },
          {
            "id": "nb-24dbf7c985",
            "week": 2,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "a = 1\nb = {1:1}\nprint({a:b})\ntry:\n    print({b:a})\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-cf5ee32171",
            "week": 2,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {}\nprint(squares)\nsquares = dict()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-15e9592c9f",
            "week": 2,
            "cell_index": 27,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nprint(squares)\nl1 = [1, 2, 3, 4]\nl2 = [1, 4, 9, 16]\nsquares = dict(zip(l1, l2))\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-8d6be60bfb",
            "week": 2,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\nsquares[-1] = 1\nsquares[-2] = 4\nprint(squares)\nsquares = {1:1, 2:4, 3:9, 4:16}\nsquares.update({-1: 1, -2: 4})\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9e36b062f7",
            "week": 2,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:9, 4:16}\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-e13c6d9d1f",
            "week": 2,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "dictionaries",
            "source": "squares = {1:1, 2:4, 3:8, 4:15}\nsquares[3] = 9\nsquares[4] = 16\nprint(squares)\nsquares = {1:1, 2:4, 3:8, 4:15}\nsquares.update({3:9, 4:16})",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Dictionaries store data in `key:value` pairs, offering fast lookups using keys. Keys must be unique and of an immutable type (like strings or numbers), while values can be anything. A crucial concept is that the `in` operator checks for membership in the keys, not the values. Unlike lists, dictionaries are considered unordered; the order of elements does not affect equality comparisons."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How can you get a list of all keys or all values from a dictionary?",
            "What happens if you try to use a list as a dictionary key?",
            "Is `{'a': 1, 'b': 2}` equal to `{'b': 2, 'a': 1}`? Why?",
            "How do you add or update an item in a dictionary?",
            "Does `x in my_dict` check keys, values, or both?",
            "What is the output of `len()` on a dictionary?",
            "What is the result of converting a list with repeated elements to a set?",
            "Does `set('banana')` produce `{'banana'}` or `{'b', 'a', 'n'}`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Adding a new item",
            "code": "scores = {'math': 90, 'history': 85}\nscores['science'] = 95\nprint(len(scores))",
            "why": "Assigning a value to a new key (`'science'`) adds the key-value pair to the dictionary. The length becomes 3.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Check if a key exists",
            "code": "person = {'name': 'Alex', 'age': 30}\nprint('age' in person)",
            "why": "The `in` keyword checks for the existence of a key in a dictionary. Since `'age'` is a key, this correctly prints `True`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Modifying a Set with .add()",
            "code": "colors = {'red', 'green'}\ncolors.add('blue')\ncolors.add('red') # Does nothing\nprint(sorted(list(colors)))\n# Output: ['blue', 'green', 'red']",
            "why": "The `.add()` method only adds an element if it is not already present in the set. The final print is wrapped in `list()` and `sorted()` to show the contents in a predictable order.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Using a mutable key",
            "code": "d = {}\nl = [1, 2]\ntry:\n    d[l] = 'a list'\nexcept TypeError:\n    print('Error')",
            "why": "This code prints `Error` because it raises a `TypeError`. Dictionary keys must be immutable. Lists are mutable and cannot be used as keys.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Checking for a value with `in`",
            "code": "person = {'name': 'Alex', 'age': 30}\nprint('Alex' in person)",
            "why": "This incorrectly prints `False`. The `in` operator only checks dictionary keys. `'Alex'` is a value, not a key.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Creating an Empty Set",
            "code": "my_set = {}\nmy_set.add('item')\n# AttributeError: 'dict' object has no attribute 'add'",
            "why": "Using empty curly braces `{}` creates an empty dictionary, not an empty set. To create an empty set, you must use the `set()` constructor. Dictionaries do not have an `.add()` method.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Dictionaries are unordered for equality, meaning `{'a':1, 'b':2} == {'b':2, 'a':1}` is true; sequence types (lists, tuples, strings) are ordered.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Ordered vs unordered equality",
                "text": "",
                "table": {
                  "headers": [
                    "Type",
                    "Order affects equality?"
                  ],
                  "rows": [
                    [
                      "`list`, `tuple`, `str`",
                      "Yes"
                    ],
                    [
                      "`dict`, `set`",
                      "No"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Sets are unordered collections of unique, immutable elements; duplicate values are ignored, e.g., `len({1,2,2})` is 2.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = {1, 2, 2, 3}\nprint(s)        # {1, 2, 3} (order may vary)\nprint(len(s))   # 3",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Dictionary keys must be unique and immutable; mutable types like lists cannot be dictionary keys.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Hashable key quick check",
                "text": "",
                "table": {
                  "headers": [
                    "Type",
                    "Valid as dict key?"
                  ],
                  "rows": [
                    [
                      "`str`, `int`, `tuple`",
                      "Yes"
                    ],
                    [
                      "`list`, `dict`, `set`",
                      "No (mutable/unhashable)"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Dictionary membership check `key in my_dict` only verifies existence of keys, not values.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "d = {'x': 1}\nprint('x' in d)   # True\nprint(1 in d)     # False\nprint(1 in d.values())  # True",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Retrieve dictionary keys using `my_dict.keys()` and values using `my_dict.values()`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Initialize an empty set with `set()` not `{}` (which creates an empty dictionary).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "empty_dict = {}\nempty_set = set()\nprint(type(empty_dict).__name__)  # dict\nprint(type(empty_set).__name__)   # set",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`set('string')` converts the string into a set of its unique characters, e.g., `set('banana')` is `{'b', 'a', 'n'}`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "Create an empty set using `set()`; `{}` initializes an empty dictionary.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "empty_dict = {}\nempty_set = set()\nprint(type(empty_dict).__name__)  # dict\nprint(type(empty_set).__name__)   # set",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "Set equality `{1,2} == {2,1}` is `True` because sets are unordered.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = {1, 2, 2, 3}\nprint(s)        # {1, 2, 3} (order may vary)\nprint(len(s))   # 3",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Cannot add mutable objects (e.g., lists) directly to a set; elements must be hashable.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-35a84b1549",
          "exm-3555baf8ba",
          "exm-4cee2500a8",
          "exm-925d0ec004",
          "lec-c54469d107",
          "lec-a3e5177371",
          "lec-27dc11e221",
          "nb-24dbf7c985",
          "nb-59478a0652"
        ]
      }
    },
    {
      "id": "topic-scope",
      "topic": "Scope",
      "canonical_topic": "scope",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 6,
        "by_exam": {
          "midterm_2023": 2,
          "trial_midterm": 2,
          "extra_practice": 1,
          "midterm_2024": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Global and local scope",
        "nested functions / scope",
        "scope",
        "scope / UnboundLocalError",
        "scope / global",
        "scope / local_global"
      ],
      "trap_patterns": [
        {
          "pattern": "UnboundLocalError",
          "trap": "If a name appears on the left side of assignment ANYWHERE in a function, Python treats it as local THROUGHOUT the function body — even before the assignment line",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-b2f1496ec5",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Global and local scope",
            "explanation": "Local names: defined inside a function (parameter names + any assignment inside). Only known inside the function. Global names: defined outside any function, known everywhere EXCEPT when a same-named local exists (local dominates). Python makes names local at call time, BEFORE executing the body — so if you assign to a name ANYWHERE in a function, that name is local throughout the function (even before the assignment line). Use 'global' keyword to override (but avoid it).",
            "code_examples": [
              {
                "description": "Local name not accessible outside",
                "code": "def adder(n1, n2):\n    return n1 + n2\nadder(1, 2)\nprint(n1)  # NameError: name 'n1' is not defined"
              },
              {
                "description": "UnboundLocalError trap — local shadows global even before assignment",
                "code": "def main(a):\n    b = b      # ERROR: Python sees b assigned in function -> local\n    return a   # but local b has no value yet\nb = 1\nprint(main(1))  # UnboundLocalError"
              },
              {
                "description": "global keyword",
                "code": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)  # 2"
              },
              {
                "description": "Better pattern: avoid global",
                "code": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)  # 2"
              },
              {
                "description": "Mutable parameter is the SAME object",
                "code": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f'The sum of {l1} = {total}')  # The sum of [] = 15 !!!\n# l1 is empty because l2 and l1 refer to the SAME list object"
              },
              {
                "description": "Fix: copy mutable arg at start of function",
                "code": "def adder(l2):\n    l2 = l2[:]   # make a copy\n    result = 0\n    while l2:\n        result += l2.pop()\n    return result"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-aa69b4e771",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 11,
            "week": 3,
            "topic": "scope / global",
            "question": "What is the output of the following code?\n\nx = 10\ndef modify():\n    x = 20\n    print(x)\nmodify()\nprint(x)",
            "code_context": "",
            "options": {
              "A": "20\n20",
              "B": "10\n10",
              "C": "20\n10",
              "D": "10\n20"
            },
            "correct": "C",
            "explanation": "Inside modify(), x = 20 creates a local variable. Printing inside gives 20. After the call, global x is still 10."
          },
          {
            "id": "exm-a67a786ae7",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 12,
            "week": 3,
            "topic": "scope / UnboundLocalError",
            "question": "What is the output of the following code?\n\nx = 5\ndef func():\n    print(x)\n    x = 10\nfunc()",
            "code_context": "",
            "options": {
              "A": "5",
              "B": "10",
              "C": "UnboundLocalError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Because x is assigned inside func(), Python treats x as local throughout the function. Printing x before assignment raises UnboundLocalError."
          },
          {
            "id": "exm-4ae24a0d6a",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 13,
            "week": 3,
            "topic": "scope / UnboundLocalError",
            "question": "What is the output of the following code?\n\ny = 100\ndef func():\n    y += 1\n    return y\nprint(func())",
            "code_context": "",
            "options": {
              "A": "101",
              "B": "100",
              "C": "UnboundLocalError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "y += 1 makes y local to func(). But y hasn't been assigned locally before this line, causing UnboundLocalError."
          },
          {
            "id": "exm-f176c9e9e4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 9,
            "week": 3,
            "topic": "scope / global",
            "question": "What is the output of the following code?\n\ncount = 0\ndef increment():\n    global count\n    count += 1\n\nincrement()\nincrement()\nprint(count)",
            "code_context": "",
            "options": {
              "A": "0",
              "B": "1",
              "C": "2",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "The global keyword lets increment() modify the global count. After two calls, count = 2."
          },
          {
            "id": "exm-08341d3aa4",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 15,
            "week": 3,
            "topic": "nested functions / scope",
            "question": "What is the output of the following code?\n\ndef outer():\n    x = 10\n    def inner():\n        print(x)\n    inner()\n\nouter()",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "None",
              "C": "Error",
              "D": "0"
            },
            "correct": "A",
            "explanation": "inner() can access x from the enclosing scope (closure). Prints 10."
          },
          {
            "id": "exm-04e24a073b",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 2,
            "week": 3,
            "topic": "scope / global",
            "question": "val = 2\ndef func():\n    val = 3\n    print(val)\nfunc()\nprint(val)\n\nWhich of the following code snippets produces the same output as the above code snippet?",
            "code_context": "",
            "options": {
              "a": "val1 = 2\ndef func1():\n    val1 = val1 + 1\n    print(val1)\nfunc1()\nprint(val1)",
              "b": "val2 = 2\ndef func2():\n    global val2\n    val2 = val2 + 1\n    print(val2)\nfunc2()\nprint(val2)",
              "c": "val3 = 2\ndef func3():\n    val3 = 3\n    def innerfunc():\n        val3 = 2\n        print(val3)\n    print(val3)\nfunc3()\nprint(val3)",
              "d": "val4 = 2\ndef func4():\n    val4 = 3\n    def innerfunc():\n        val4 = 2\n        print(val4)\n    print(val4)\nfunc4()\ninnerfunc()"
            },
            "correct": "c",
            "explanation": "Original output: 3, 2. Option a: UnboundLocalError (val1 used before local assignment). Option b: global val2 modified to 3, print 3, then print val2=3. Output: 3,3. Option c: func3 creates local val3=3, prints 3. Global val3=2 unchanged, prints 2. Output: 3,2. Matches! Option d: innerfunc() called outside func4 scope — NameError. Correct: c."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-59b3d2b2bb",
            "week": 3,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "scope",
            "source": "del (n1, n2)\ndef adder(n1, n2):\n    return n1 + n2\nadder (1,2)\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-4151cecd5a",
            "week": 3,
            "cell_index": 29,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-ae24f910b8",
            "week": 3,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    global n1\n    n1 *= 2\n    return n1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-642af3f147",
            "week": 3,
            "cell_index": 31,
            "cell_type": "code",
            "topic": "scope",
            "source": "def main (a):\n    b = b\n    return a\nb = 1\nprint(main (1))",
            "outputs": []
          },
          {
            "id": "nb-6de5d86509",
            "week": 3,
            "cell_index": 32,
            "cell_type": "code",
            "topic": "scope",
            "source": "def main (a):\n    global b\n    b = b\n    return a\nb = 1\nprint(main (1))",
            "outputs": []
          },
          {
            "id": "nb-2b221f0928",
            "week": 3,
            "cell_index": 34,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer():\n    global n1\n    n1 = n1 + 1\nn1 = 1\nchanger()\nprint(n1)",
            "outputs": []
          },
          {
            "id": "nb-a8920b5b9d",
            "week": 3,
            "cell_index": 35,
            "cell_type": "code",
            "topic": "scope",
            "source": "def changer(n1):\n    n1 = n1 + 1\n    return n1\na = 1\na = changer(a)\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Scope refers to the region of code where a variable is accessible. Variables defined inside a function are `local` to that function. If you assign a value to a variable within a function, Python automatically considers it a local variable for the entire function's scope. This can lead to an `UnboundLocalError` if you try to read that variable before the line where it's assigned, even if a global variable of the same"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "If a local and global variable share a name, which one is used inside the function?",
            "How can a function modify a variable that was defined outside of it?",
            "What is the value of the global variable after the function call?",
            "What is the difference between a local and global variable?",
            "Why did my program raise an `UnboundLocalError`?",
            "Are function parameters local or global?",
            "What is the difference between changing a global (`global x; x=0`) and mutating a global (`my_list.append(1)`)?",
            "What is the output of code that prints a variable both inside and outside a function where it is reassigned?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Local Variable Shadowing",
            "code": "x = 10\ndef func():\n    x = 5 # This is a new, local variable `x`\n    print(f'Inside: {x}')\nfunc()\nprint(f'Outside: {x}')",
            "why": "The assignment `x = 5` inside `func` creates a new local variable that only exists within that function. It does not affect the global variable `x`, so the output is 'Inside: 5' followed by 'Outside: 10'.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Modifying a Global Variable",
            "code": "count = 0\ndef increment():\n    global count\n    count += 1\nincrement()\nincrement()\nprint(count)",
            "why": "The `global count` statement tells the function that `count` refers to the global variable, not a new local one. Each call to `increment()` modifies the same global `count`, resulting in a final value of 2.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Local Variable Shadows Global",
            "code": "x = 10\ndef my_func():\n    x = 2 # This is a new local variable\n    print(f\"Inside: {x}\")\n\nmy_func()\nprint(f\"Outside: {x}\")",
            "why": "The assignment `x = 2` inside the function creates a local variable. It does not affect the global `x`. The output is 'Inside: 2' followed by 'Outside: 10'.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Attempting to Modify Global Implicitly",
            "code": "score = 0\ndef add_points():\n    # This tries to read local `score` before it's assigned\n    score = score + 10\nadd_points()",
            "why": "This is a classic `UnboundLocalError`. The expression `score + 10` needs to read the value of `score` first. Since there is an assignment to `score` in the function, it's considered local, but it hasn't been assigned",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "`UnboundLocalError` Trap",
            "code": "value = 100\ndef update():\n    print(value) # Error occurs here\n    value = 50\nupdate()",
            "why": "Because `value` is assigned within the `update` function, Python treats it as a local variable throughout that function. The `print(value)` statement thus tries to access this local `value` before it has been assigned,",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Forgetting that Parameters are Local",
            "code": "val = 100\ndef update(val):\n    val = 200 # This only changes the local 'val'\n\nupdate(val)\nprint(val)",
            "why": "Function parameters behave as local variables. The `val` inside `update` is a distinct local variable that is initialized with the value passed to it. The assignment only changes the local copy. The global `val` remains",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`UnboundLocalError` occurs when Python marks a name local due to assignment, then that name is read before assignment.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 10\ndef f():\n    x += 1      # UnboundLocalError: local x referenced before assignment\n\n# fix:\ndef g():\n    global x\n    x += 1",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Assignment inside a function (e.g., `x = 10`) makes `x` local unless `global x` or `nonlocal x` is declared.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "LEGB lookup order: Local -> Enclosing -> Global -> Builtins; closest scope wins for name resolution.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "LEGB order",
                "text": "",
                "table": {
                  "headers": [
                    "Lookup order",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "Local",
                      "Current function scope"
                    ],
                    [
                      "Enclosing",
                      "Nearest outer function scope"
                    ],
                    [
                      "Global",
                      "Module-level scope"
                    ],
                    [
                      "Builtins",
                      "Python built-in names"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Parameters are local names: changing `param` inside the function does not rebind the caller's variable name.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Reading a global name is allowed inside a function; rebinding that name requires `global name`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "The `global` keyword is not needed to mutate elements of global mutable objects (e.g., `my_list.append(item)`), only for reassigning the variable itself.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = []\ndef add_item(v):\n    items.append(v)   # mutate global list, no global needed\n\ndef reset_items():\n    global items\n    items = []        # rebinding requires global",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Assigning to a variable inside a function without `global` implicitly creates a new local variable, not modifying an existing global.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`UnboundLocalError` occurs when a variable is referenced before its assignment, if Python determines it's a local variable.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 10\ndef f():\n    x += 1      # UnboundLocalError: local x referenced before assignment\n\n# fix:\ndef g():\n    global x\n    x += 1",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "If a local variable and a global variable share the same name, the local variable takes precedence within the function.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Function parameters are local to the function and do not affect global variables with the same name.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-f176c9e9e4",
          "exm-a67a786ae7",
          "exm-4ae24a0d6a",
          "exm-aa69b4e771",
          "exm-08341d3aa4",
          "lec-b2f1496ec5",
          "nb-ae24f910b8",
          "nb-4151cecd5a",
          "nb-2b221f0928",
          "nb-a8920b5b9d"
        ]
      }
    },
    {
      "id": "topic-slicing",
      "topic": "Slicing",
      "canonical_topic": "slicing",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 5,
        "by_exam": {
          "trial_midterm": 2,
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "Slicing",
        "Slicing / mutability",
        "Slicing negative step",
        "indexing / slicing",
        "slicing",
        "slicing / negative step",
        "slicing / negative_step",
        "slicing / strings",
        "strings"
      ],
      "trap_patterns": [
        {
          "pattern": "Negative slicing with step=-2",
          "trap": "l[::-2] starts from last element going backwards with step 2. l[::2][::-1] first takes every other starting from 0, then reverses — different result",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "extra_practice"
          ]
        },
        {
          "pattern": "range() and slicing both exclusive at stop",
          "trap": "range(1,10,3)→[1,4,7] not including 10; l[2:7] goes up to but not including index 7",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        },
        {
          "pattern": "Slicing creates a NEW object",
          "trap": "l2=l1 vs l2=l1[:] — l2=l1 shares the SAME object, slicing creates independent copy",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023",
            "midterm_2024",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8b4915c558",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing",
            "explanation": "Syntax: seq[start:end:step]. Start is inclusive, end is NOT inclusive. Defaults: start=0, end=len, step=1. Negative step goes from right to left. Slicing always creates a NEW object of the same type.",
            "code_examples": [
              {
                "description": "Basic slicing examples",
                "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[7])       # 8\nprint(l1[-1])      # 8\nprint(l1[-5:5])    # [4, 5]\nprint(l1[:-5])     # [1, 2, 3]"
              },
              {
                "description": "Negative step",
                "code": "l1 = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(l1[5:1:-2])  # [6, 4]\nprint(l1[5::-1])   # [6, 5, 4, 3, 2, 1]\nprint(l1[:1:-1])   # [8, 7, 6, 5, 4, 3]\nprint(l1[1:5:-2])  # [] (already past end)"
              },
              {
                "description": "Slice reversal",
                "code": "l1 = [1, 2, 3, 4]\nprint(l1[::-1])    # [4, 3, 2, 1]"
              },
              {
                "description": "Slicing creates new object — key exam trap",
                "code": "l1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)  # True False (l3 is independent copy)"
              },
              {
                "description": "Changing a list slice vs index",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nl1[1:2] = [1, 1]      # replaces element at index 1 with two elements\nprint(l1)             # [1, 1, 1, 3, 4, 5, 6]\n\nl1 = [1, 2, 3, 4, 5, 6]\nl1[1] = [1, 1]        # replaces element at index 1 with a list\nprint(l1)             # [1, [1, 1], 3, 4, 5, 6]"
              },
              {
                "description": "Slicing strings and tuples",
                "code": "t1 = (1, 2, 3)\nprint(t1[1:])          # (2, 3)\ns1 = 'uva Amsterdam'\nprint(s1[5:-3:2])      # 'mtr'"
              },
              {
                "description": "Changing string/tuple (must create new object)",
                "code": "s1 = 'uva Amsterdam'\n# s1[6] = 's'  # ERROR\ns1 = s1[:6] + 's' + s1[7:]\nprint(s1)  # works\n\nt1 = (1, 4, 3)\n# t1[1] = 2  # ERROR\nt1 = t1[:1] + (2,) + t1[2:]\nprint(t1)  # works"
              }
            ]
          },
          {
            "id": "leq-d9ed64b435",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing / mutability",
            "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nl2 = l1\nl3 = l1[:]\nl1[-1] = 5\nprint(l1 == l2, l2 == l3)",
            "options": {},
            "correct": null,
            "explanation": ""
          },
          {
            "id": "leq-eb2d6e90d2",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Slicing negative step",
            "question": "What will be printed?\nl1 = [1, 2, 3, 4]\nprint(l1[::-1])",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [
          {
            "id": "exm-1b0f40ae76",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 1,
            "week": 1,
            "topic": "indexing / slicing",
            "question": "What is the output of the following code?\n\nx = 'Hello, World!'\nprint(x[-6:-1])",
            "code_context": "",
            "options": {
              "A": "World",
              "B": "orld!",
              "C": "World!",
              "D": "orld"
            },
            "correct": "A",
            "explanation": "x[-6:-1] starts 6 from the end ('W') and goes to 1 from the end (exclusive of '!'). That gives 'World'."
          },
          {
            "id": "exm-1c9f7b4c79",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 4,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\nx = [0, 1, 2, 3, 4, 5]\nprint(x[1:5:2])",
            "code_context": "",
            "options": {
              "A": "[1, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[0, 2, 4]",
              "D": "[1, 2]"
            },
            "correct": "A",
            "explanation": "x[1:5:2] starts at index 1, stops before index 5, step 2. Gives elements at indices 1 and 3: [1, 3]."
          },
          {
            "id": "exm-90abd89ecf",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 3,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\ns = 'abcdef'\nprint(s[2:5])",
            "code_context": "",
            "options": {
              "A": "bcd",
              "B": "cde",
              "C": "cdef",
              "D": "bcde"
            },
            "correct": "B",
            "explanation": "s[2:5] gives characters at indices 2,3,4: 'c','d','e' = 'cde'."
          },
          {
            "id": "exm-d71c297b9e",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 2,
            "week": 1,
            "topic": "slicing",
            "question": "What is the output of the following code?\n\nlst = [10, 20, 30, 40, 50]\nprint(lst[::2])",
            "code_context": "",
            "options": {
              "A": "[10, 30, 50]",
              "B": "[20, 40]",
              "C": "[10, 20, 30, 40, 50]",
              "D": "[50, 30, 10]"
            },
            "correct": "A",
            "explanation": "lst[::2] takes every other element starting from index 0: [10, 30, 50]."
          },
          {
            "id": "exm-451a3ff1d3",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 6,
            "week": 1,
            "topic": "slicing / negative step",
            "question": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nWhich of the following lines of code will NOT create a list with the name subset, and the value [10, 8, 6, 4, 2]?",
            "code_context": "",
            "options": {
              "a": "subset = numbers[-1::-2]",
              "b": "subset = numbers[::-2]",
              "c": "subset = numbers[::-1][::2]",
              "d": "subset = numbers[::2][::-1]"
            },
            "correct": "d",
            "explanation": "a: starts at -1 (10), step -2: [10,8,6,4,2]. Correct. b: [::-2] starts at last (10), step -2: [10,8,6,4,2]. Correct. c: [::-1] reverses to [10,9,8,7,6,5,4,3,2,1], then [::2] takes every 2nd: [10,8,6,4,2]. Correct. d: [::2] gives [1,3,5,7,9], then [::-1] reverses: [9,7,5,3,1]. This does NOT give [10,8,6,4,2]. Correct answer (the one that does NOT work): d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-3f9cf37bbb",
            "week": 1,
            "cell_index": 62,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[6:5])\nprint(l1[6:6])\nprint(l1[6:7])\nprint(l1[6:7] == l1[6])\nprint(l1[6:7][0] == l1[6])\nprint(l1[6:7] == list(l1[6]))",
            "outputs": []
          },
          {
            "id": "nb-1a515da900",
            "week": 1,
            "cell_index": 63,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[1:17])\nprint(l1[16:17])\nprint(l1[:6])\nprint(l1[6:])\nprint(l1[:6] + l1[6:] == l1)\nprint(l1[:] == l1)\nprint(l1[:] is l1)",
            "outputs": []
          },
          {
            "id": "nb-be3698c98e",
            "week": 1,
            "cell_index": 64,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\nprint(l1[0:6:2])\nprint(l1[1:6:1] == l1[1:6])\nprint(l1[1:6:1] == l1[1:6:])\nprint(l1[0:6:2] == l1[:6:2])\nprint(l1[2:len(l1):2] == l1[2::2])\nprint(l1[0:len(l1):1] == l1[::])",
            "outputs": []
          },
          {
            "id": "nb-15c3c8bffd",
            "week": 1,
            "cell_index": 65,
            "cell_type": "code",
            "topic": "slicing",
            "source": "l1 = ['a', 'b']\nl2 = l1\nl2[-1] = 'c'\nprint(l1 == l3)\nl3 = l1[::]\nl3[-1] = 'c'\nprint(l1 == l3)",
            "outputs": []
          },
          {
            "id": "nb-9ccea86971",
            "week": 1,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "strings",
            "source": "print(\"This is a string\")\nprint('This is another string')",
            "outputs": []
          },
          {
            "id": "nb-fac92dad98",
            "week": 1,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"",
            "outputs": []
          },
          {
            "id": "nb-2dd9891d55",
            "week": 1,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a,b)",
            "outputs": []
          },
          {
            "id": "nb-046b3572aa",
            "week": 1,
            "cell_index": 83,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Slicing extracts a portion of a sequence like a list or string using the `[start:stop:step]` syntax. The `start` index is inclusive, while the `stop` index is exclusive. Pay close attention to the direction when the `step` is negative, as it reverses traversal from right to left. Remember that slicing always produces a new object, which is a key distinction from direct assignment (`l2 = l1` vs. `l2 = l1[:]`)."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the result of a slice where the start index is greater than the stop index with a positive step?",
            "Explain the difference between a shallow copy `[:]` and a direct assignment `=`.",
            "What happens if you use a negative step, like `my_list[5:1:-1]`?",
            "How do you reverse a string using slicing?",
            "What is the output of `my_list[1:5]`?",
            "What does `my_list[::2]` do?",
            "How do you get the last three elements of a list in their original order vs reverse order?",
            "What are the default `start` and `stop` values when the step is negative?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Reverse a portion of a list",
            "code": "letters = ['a', 'b', 'c', 'd', 'e']\nprint(letters[3:1:-1])",
            "why": "This starts at index 3 ('d'), goes towards index 1 (exclusive), with a step of -1. It picks elements at index 3 and 2, resulting in `['d', 'c']`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Get every other element",
            "code": "nums = [10, 20, 30, 40, 50, 60]\nprint(nums[::2])",
            "why": "With no start or end, `::2` steps through the entire list, picking every second element starting from the first one, resulting in `[10, 30, 50]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Slice a subsequence backwards",
            "code": "nums = [10, 20, 30, 40, 50, 60]\nprint(nums[4:1:-1])",
            "why": "Starts at index 4 (50), moves right-to-left, and stops before index 1. It collects elements at indices 4, 3, and 2, outputting `[50, 40, 30]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Forgetting `stop` is exclusive",
            "code": "nums = [1, 2, 3, 4, 5]\n# Goal: get [2, 3, 4, 5]\nprint(nums[1:4])",
            "why": "This incorrectly prints `[2, 3, 4]`. The slice `[1:4]` stops *before* index 4. To include the element at index 4, the slice must be `nums[1:5]` or `nums[1:]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Confusing a slice and an index",
            "code": "letters = ['a', 'b', 'c', 'd']\nprint(letters[1:2] == 'b')",
            "why": "This is `False`. Slicing `[1:2]` creates a new list `['b']`, which is not equal to the string `'b'`. The correct comparison would be `letters[1] == 'b'`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Incorrect Start/Stop for negative step",
            "code": "nums = [10, 20, 30, 40, 50]\nprint(nums[1:4:-1])",
            "why": "This prints an empty list `[]`. With a negative step, the `start` index must be to the right of the `stop` index. The slice cannot go from index 1 to 4 by moving backwards.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Slicing `my_list[:]` creates a new shallow copy; direct assignment `new_list = old_list` creates a reference to the same object.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [[1], [2]]\nb = a[:]         # shallow copy\nb[0].append(9)\nprint(a)         # [[1, 9], [2]] (inner list shared)",
                "id": "kp-1-d1"
              },
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `copy.deepcopy(...)` when nested mutable objects must be fully independent.",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Slicing syntax is `seq[start:end:step]` where `start` is inclusive, `end` is exclusive, and `step` defaults to 1.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Slice fields",
                "text": "",
                "table": {
                  "headers": [
                    "Field",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "`start`",
                      "First included index"
                    ],
                    [
                      "`end`",
                      "First excluded index"
                    ],
                    [
                      "`step`",
                      "Stride (+/- direction and gap)"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'abcdef'\nprint(s[1:4])    # 'bcd'\nprint(s[::2])    # 'ace'\nprint(s[::-1])   # 'fedcba'",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Range and slicing `end` values are exclusive, e.g., `range(1, 10)` goes up to 9, `list[2:7]` goes up to index 6.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(list(range(5)))      # [0, 1, 2, 3, 4]\nprint(list(range(2, 6)))   # [2, 3, 4, 5]",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Negative indices access elements from the end of the sequence; `seq[-1]` is the last element.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "For `seq[::-1]`, `start` defaults to `len(seq)-1` (last element) and `end` defaults to `-len(seq)-1` (before first element), effectively reversing the sequence.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'python'\nprint(s[::-1])     # 'nohtyp'\nprint(s[-1::-1])   # same result",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "A slice with `start > end` and a positive `step` results in an empty sequence.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-7",
            "text": "A slice with a negative step `seq[start:end:-step]` requires `start > end` to produce results; if `start <= end`, the slice will be empty.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = [0, 1, 2, 3, 4, 5]\nprint(x[5:1:-2])   # [5, 3]\nprint(x[1:5:-2])   # []",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Distinguish `l[::-2]` (every other element, reversed from end) from `l[::2][::-1]` (every other element from start, then reversed).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "When using a negative step `seq[start:end:-step]`, the slice moves from `start` to `end` from right to left.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = [0, 1, 2, 3, 4, 5]\nprint(x[5:1:-2])   # [5, 3]\nprint(x[1:5:-2])   # []",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Slices where `start >= end` (for positive step) or `start < end` (for negative step) produce an empty sequence.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = [0, 1, 2, 3, 4, 5]\nprint(x[5:1:-2])   # [5, 3]\nprint(x[1:5:-2])   # []",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-451a3ff1d3",
          "exm-1c9f7b4c79",
          "exm-d71c297b9e",
          "exm-90abd89ecf",
          "exm-1b0f40ae76",
          "lec-8b4915c558",
          "nb-3f9cf37bbb",
          "nb-15c3c8bffd",
          "nb-1a515da900",
          "leq-eb2d6e90d2"
        ]
      }
    },
    {
      "id": "topic-args-star",
      "topic": "*args",
      "canonical_topic": "*arg",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 5,
        "by_exam": {
          "trial_midterm": 2,
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 4
      },
      "related_topics": [
        "*args",
        "*args / **kwargs",
        "*args / function design",
        "*args / passing to function",
        "Keyword arguments and **kwargs",
        "Methods vs functions",
        "args_star",
        "fun_example",
        "keyword args / **kwargs"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-521c0f3bef",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Keyword arguments and **kwargs",
            "explanation": "Arguments can be passed by name (keyword). **kwargs collects undefined keyword arguments into a dict. Order in function definition: positional, *args, keyword-with-defaults, **kwargs.",
            "code_examples": [
              {
                "description": "Keyword arguments",
                "code": "def calc(first, second, third, fourth, fifth, sixth):\n    return first + 2*second + 3*third + 4*fourth + 5*fifth + 6*sixth\nprint(calc(fifth=2, third=4, fourth=1, sixth=5, second=2, first=3))  # 63"
              },
              {
                "description": "**kwargs",
                "code": "def calc(**kwargs):\n    return kwargs['first'] + 2*kwargs['second'] + 3*kwargs['third']\nprint(calc(third=4, second=2, first=3))"
              },
              {
                "description": "Mixed: positional + *args + **kwargs",
                "code": "def calc(first, second, *args, **kwargs):\n    return first + second*2 + args[0]*3 + args[1]*4 + 5*kwargs['fifth'] + 6*kwargs['sixth']\nprint(calc(3, 2, 4, 1, sixth=5, fifth=2))  # 63"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings — you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable — must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT — captures new string\ns1.upper()       # WRONG — result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable — changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-b0d0a64cde",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 14,
            "week": 3,
            "topic": "*args",
            "question": "What is the output of the following code?\n\ndef func(*args):\n    return sum(args)\n\nprint(func(1, 2, 3, 4, 5))",
            "code_context": "",
            "options": {
              "A": "15",
              "B": "(1, 2, 3, 4, 5)",
              "C": "[1, 2, 3, 4, 5]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "*args collects all positional arguments as a tuple. sum((1,2,3,4,5)) = 15."
          },
          {
            "id": "exm-11949e2fb1",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 22,
            "week": 3,
            "topic": "keyword args / **kwargs",
            "question": "What is the output of the following code?\n\ndef greet(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\ngreet(name='Alice', age=30)",
            "code_context": "",
            "options": {
              "A": "name: Alice\nage: 30",
              "B": "Alice: name\n30: age",
              "C": "{'name': 'Alice', 'age': 30}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "**kwargs collects keyword arguments as a dict. Iterating items() gives key-value pairs: name: Alice, age: 30."
          },
          {
            "id": "exm-1e574c41d3",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 17,
            "week": 3,
            "topic": "*args",
            "question": "What is the output of the following code?\n\ndef func(*args):\n    print(type(args))\n\nfunc(1, 2, 3)",
            "code_context": "",
            "options": {
              "A": "<class 'list'>",
              "B": "<class 'tuple'>",
              "C": "<class 'dict'>",
              "D": "<class 'set'>"
            },
            "correct": "B",
            "explanation": "*args collects positional arguments as a tuple."
          },
          {
            "id": "exm-fda16bbeb3",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 14,
            "week": 3,
            "topic": "*args / **kwargs",
            "question": "What is the output of the following code?\n\ndef func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\n\nfunc(1, 2, 3, 4, x=5, y=6)",
            "code_context": "",
            "options": {
              "A": "1 2 (3, 4) {'x': 5, 'y': 6}",
              "B": "1 2 [3, 4] {'x': 5, 'y': 6}",
              "C": "1 2 3 4 5 6",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "a=1, b=2, args=(3,4) as tuple, kwargs={'x':5,'y':6} as dict."
          },
          {
            "id": "exm-16556959b9",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 9,
            "week": 3,
            "topic": "*args / passing to function",
            "question": "Assume sum_even_in_list(l1) filters non-integers and sums even integers.\n\nYou want sum_even_integers that accepts a flexible number of arguments.\n\nFor example: sum_even_integers(1,'2', 3.0, 4) should return 4.\n\nWhich of the following function definitions will work as intended?",
            "code_context": "",
            "options": {
              "a": "def sum_even_integers(*args):\n\treturn sum_even_in_list(args)",
              "b": "def sum_even_integers(*args):\n\treturn sum([x for x in args if type(x) == int and x%2 == 0])",
              "c": "def sum_even_integers(*args):\n\tresult = 0\n\tfor x in args:\n\t\tif type(x) == int and x%2 == 0:\n\t\t\tresult += x\n\treturn result",
              "d": "All of the above."
            },
            "correct": "d",
            "explanation": "a: *args creates a tuple, sum_even_in_list accepts any iterable so passing a tuple works. b: list comprehension on tuple works fine. c: direct iteration over tuple works. All three produce the same result. Correct: d."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-181e9ccd25",
            "week": 3,
            "cell_index": 38,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "outputs": []
          },
          {
            "id": "nb-a5fa1fde61",
            "week": 3,
            "cell_index": 39,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(l1):\n    result = 0\n    for number in l1:\n        result += number  \n    return result\nprint(adder([1, 2, 3, 4, 5]))",
            "outputs": []
          },
          {
            "id": "nb-3e6522622c",
            "week": 3,
            "cell_index": 40,
            "cell_type": "code",
            "topic": "args_star",
            "source": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number  \n    return result\nprint(adder(1, 2, 3, 4, 5))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `*args` syntax in a function definition allows it to accept a variable number of positional arguments. Inside the function, `args` becomes a tuple containing all the positional arguments that weren't assigned to specific parameters. This is useful for creating flexible functions that can operate on an unknown number of inputs, such as a custom `sum` or `print` function. The arguments are collected in the order t"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What happens if you call a function that accepts `**kwargs` with no keyword arguments?",
            "Can a function have both regular parameters and `*args`? What is the correct order?",
            "What is the correct parameter order for `a`, `*args`, `b=1`, and `**kwargs`?",
            "What happens if you call a function with `*args` with no extra arguments?",
            "How can you loop through all the key-value pairs passed via `**kwargs`?",
            "Is the name `args` required, or can you use another name like `*nums`?",
            "How can you use `**` to unpack a dictionary when calling a function?",
            "What is the data type of the `kwargs` variable inside the function?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Print user profile",
            "code": "def print_profile(**user_info):\n    for key, value in user_info.items():\n        print(f'{key.title()}: {value}')\n\nprint_profile(name='Ben', age=25, city='Lisbon')",
            "why": "`**user_info` collects the keyword arguments into `{'name': 'Ben', 'age': 25, 'city': 'Lisbon'}`. The loop then correctly iterates and prints each key-value pair.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Mixing regular args and *args",
            "code": "def multiply(multiplier, *numbers):\n    result = []\n    for n in numbers:\n        result.append(n * multiplier)\n    return result\nprint(multiply(10, 1, 2, 3))",
            "why": "`10` is assigned to `multiplier`, and `*numbers` collects the rest into the tuple `(1, 2, 3)`. The function correctly returns a new list `[10, 20, 30]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Summing multiple numbers",
            "code": "def adder(*numbers):\n    total = 0\n    for n in numbers:\n        total += n\n    return total\nprint(adder(1, 5, 10))",
            "why": "`*numbers` collects `1`, `5`, and `10` into a tuple `(1, 5, 10)`. The function then correctly iterates over the tuple and sums them, returning `16`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Placing *args before positional args",
            "code": "# def my_func(*args, separator):\n#     return separator.join(args)\n\n# This function definition causes a SyntaxError\n# in older Python versions and is bad practice.",
            "why": "Standard positional parameters must be defined before `*args`. Although modern Python allows this if the later argument is passed by keyword (`func('a', separator='-')`), it is confusing and often tested as an error.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Passing a list to *args",
            "code": "def my_sum(*nums):\n    return sum(nums)\ndata = [1, 2, 3]\n# Incorrectly passing the list as one item\nprint(my_sum(data))",
            "why": "This causes a `TypeError`. `*nums` expects individual arguments, but gets one: the list `[1, 2, 3]`. `nums` becomes `([1, 2, 3],)`, a tuple containing one list. Call with `my_sum(*data)` to unpack it.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Assuming a key exists in **kwargs",
            "code": "def get_name(**kwargs):\n    return kwargs['name']\n\ntry:\n    print(get_name(age=30))\nexcept KeyError:\n    print('Error: name not provided')",
            "why": "This raises a `KeyError`. The call creates a `kwargs` dictionary `{'age': 30}`, which does not contain the key `'name'`. Use `kwargs.get('name')` for a safe lookup.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Call a function with `func(*iterable)` to unpack an iterable (list, tuple, etc.) into positional arguments.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3]\nprint(*nums)  # 1 2 3\n\ndef add(a, b, c):\n    return a + b + c\nprint(add(*nums))  # 6",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`*args` in a function signature collects all non-keyword positional arguments into a `tuple`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(*args):\n    print(type(args).__name__, args)\n\nf(1, 2, 3)  # tuple (1, 2, 3)",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`**kwargs` in a function signature collects all non-matched keyword arguments into a `dict`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def g(**kwargs):\n    for k, v in kwargs.items():\n        print(k, v)\n\ng(name='Ana', score=10)",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Call a function with `func(**dictionary)` to unpack a dictionary into keyword arguments.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3]\nprint(*nums)  # 1 2 3\n\ndef add(a, b, c):\n    return a + b + c\nprint(add(*nums))  # 6",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Inside a function, `type(kwargs)` is `dict`; access values like `kwargs['key']` or `kwargs.get('key')`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "The parameter order for functions is positional, `*args`, default keyword arguments, then `**kwargs`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-7",
            "text": "Iterate `**kwargs` using `for key, value in kwargs.items():` to process all passed keyword arguments.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "Inside a function, `type(args)` is `tuple`, allowing tuple operations like iteration or indexing.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "Function parameters must follow the order: positional arguments, then `*args`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "Unpack an iterable (list/tuple) into individual positional arguments for a function using the `*` operator during the call (e.g., `func(*my_list)`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3]\nprint(*nums)  # 1 2 3\n\ndef add(a, b, c):\n    return a + b + c\nprint(add(*nums))  # 6",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-fda16bbeb3",
          "exm-1e574c41d3",
          "exm-16556959b9",
          "exm-11949e2fb1",
          "exm-b0d0a64cde",
          "lec-521c0f3bef",
          "nb-3e6522622c"
        ]
      }
    },
    {
      "id": "topic-condition-falsy-truthy",
      "topic": "Conditions",
      "canonical_topic": "condition",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 4,
        "by_exam": {
          "midterm_2024": 2,
          "midterm_2023": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Boolean operators",
        "Conditional statements and expressions",
        "Conditions and boolean operators — precedence",
        "Truthy and Falsy",
        "conditional_expression",
        "conditions",
        "conditions / boolean",
        "conditions / conditional expression",
        "conditions / precedence",
        "conditions / truthy falsy",
        "conditions / truthy_falsy",
        "conditions_precedence",
        "truthy / falsy",
        "truthy_falsy"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-2f353ad9dc",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Boolean operators",
            "explanation": "x and y: True only if both True. x or y: False only if both False. not x: inverts. NOTE: && and || are Python operators but do something different (bitwise). Precedence: 'not' first, then 'and', then 'or'. Use parentheses to avoid confusion.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\nprint(a==1 or a==2 and b==1 or b==2)  # True (WRONG: and binds tighter)\nprint((a==1 or a==2) and (b==1 or b==2))  # False (CORRECT)"
              }
            ]
          },
          {
            "id": "lec-ce8d642b40",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Conditional statements and expressions",
            "explanation": "if/elif/else. One if at start, at most one else at end, unlimited elif in between. Indentation is critical — all code in a block must have same indentation. Conditional expression (ternary): value_if_true if condition else value_if_false.",
            "code_examples": [
              {
                "description": "if/elif/else structure",
                "code": "if condition_1:\n    expression_1\nelif condition_2:\n    expression_2\n    expression_3\nelse:\n    expression_4"
              },
              {
                "description": "Conditional expression (ternary)",
                "code": "# Statement form:\nif a > 0:\n    b = a\nelse:\n    b = 0\n# Expression form:\nb = a if a > 0 else 0\n# Even simpler:\nb = max(0, a)"
              }
            ]
          },
          {
            "id": "lec-d7fa16c039",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Conditions and boolean operators — precedence",
            "explanation": "Precedence (high to low): comparisons → not → and → or. Use parentheses to be explicit. 'in' checks membership in sequence/set/dict-keys.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\n# WRONG: Python evaluates 'and' before 'or'\nprint(a==1 or a==2 and b==1 or b==2)     # True (unexpected)\n# CORRECT: use brackets\nprint((a==1 or a==2) and (b==1 or b==2)) # False"
              },
              {
                "description": "Inclusion check — 'in' operator",
                "code": "print(1 in [1,2,3])    # True\nprint(1 in (1,2,3))    # True\nprint('1' in '123')    # True (substring)\nprint(1 in {1:4, 2:3}) # True (checks keys)\nprint(4 in {1:4, 2:3}) # False (4 is value, not key)\nprint(1 in {1,2,3})    # True"
              }
            ]
          },
          {
            "id": "lec-0fb3921997",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Truthy and Falsy",
            "explanation": "In conditions, Python auto-converts to bool. Falsy: [], (), {}, set(), '', 0, 0.0, range(0), None. Truthy: everything else (non-empty collections, non-zero numbers).",
            "code_examples": [
              {
                "description": "Falsy values",
                "code": "# All evaluate to False in a condition:\n[]    # empty list\n()    # empty tuple\n{}    # empty dict\nset() # empty set\n''    # empty string\n0     # zero int\n0.0   # zero float"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-6f4723b001",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 8,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following values is truthy in Python?",
            "code_context": "",
            "options": {
              "A": "0",
              "B": "''",
              "C": "[]",
              "D": "' '"
            },
            "correct": "D",
            "explanation": "A string with at least one space is truthy. 0, empty string, and empty list are all falsy."
          },
          {
            "id": "exm-163328662e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 9,
            "week": 2,
            "topic": "conditions / conditional expression",
            "question": "What is the output of the following code?\n\nx = 7\nresult = 'odd' if x % 2 != 0 else 'even'\nprint(result)",
            "code_context": "",
            "options": {
              "A": "even",
              "B": "odd",
              "C": "7",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "7 % 2 = 1 != 0, so result = 'odd'."
          },
          {
            "id": "exm-ac7c608999",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 12,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following expressions evaluates to True?",
            "code_context": "",
            "options": {
              "A": "bool([])",
              "B": "bool(0)",
              "C": "bool('')",
              "D": "bool([0])"
            },
            "correct": "D",
            "explanation": "A list with one element [0] is truthy even though the element itself is falsy. [], 0, and '' are all falsy."
          },
          {
            "id": "exm-f280f69ab8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 7,
            "week": 2,
            "topic": "conditions / truthy falsy",
            "question": "What is the output of the following code?\n\nx = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')",
            "code_context": "",
            "options": {
              "A": "truthy",
              "B": "falsy",
              "C": "0",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "0 is falsy in Python. The else branch executes, printing 'falsy'."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-42ed2c546b",
            "week": 2,
            "cell_index": 53,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(3 > 2)",
            "outputs": []
          },
          {
            "id": "nb-067af65884",
            "week": 2,
            "cell_index": 55,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(True and True,   True or True)\nprint(True and False,  True or False)\nprint(False and True,  False or True)\nprint(False and False, False or False)",
            "outputs": []
          },
          {
            "id": "nb-e50e4bec92",
            "week": 2,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(not True) \nprint(not False)",
            "outputs": []
          },
          {
            "id": "nb-fd93961a89",
            "week": 2,
            "cell_index": 59,
            "cell_type": "code",
            "topic": "conditions",
            "source": "print(True and True or False and False)\nprint((True and True) or (False and False))",
            "outputs": []
          },
          {
            "id": "nb-8706fdaa04",
            "week": 2,
            "cell_index": 61,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "print(True or True and False or False)\nprint((True or True) and (False or False))",
            "outputs": []
          },
          {
            "id": "nb-d218099c8c",
            "week": 2,
            "cell_index": 63,
            "cell_type": "code",
            "topic": "conditions",
            "source": "a = 3\nif a > 1 and a < 5:\n    print('a between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-6cf4db433f",
            "week": 2,
            "cell_index": 65,
            "cell_type": "code",
            "topic": "conditions",
            "source": "a = 3\nif 5 > a > 1:\n    print('a between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-01f68c2b97",
            "week": 2,
            "cell_index": 67,
            "cell_type": "code",
            "topic": "conditions",
            "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-0f0d71f802",
            "week": 2,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "a=1\nb=3\nprint(a==1 or a==2 and b==1 or b==2)",
            "outputs": []
          },
          {
            "id": "nb-85aa6dad86",
            "week": 2,
            "cell_index": 71,
            "cell_type": "code",
            "topic": "conditions_precedence",
            "source": "a=1\nb=3\nprint((a==1 or a==2) and (b==1 or b==2))",
            "outputs": []
          },
          {
            "id": "nb-eebf273aa8",
            "week": 2,
            "cell_index": 74,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5) \nprint(a)\n\nif a > 0:\n    b = a\nelse:\n    b = 0\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-a54cf6c386",
            "week": 2,
            "cell_index": 75,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = a if a > 0 else 0\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-fc57853175",
            "week": 2,
            "cell_index": 77,
            "cell_type": "code",
            "topic": "conditional_expression",
            "source": "from random import randint\na = randint(-5,5)\nprint(a)\n\nb = max(a, 0)\nprint(b)",
            "outputs": []
          },
          {
            "id": "nb-33c2cdb26d",
            "week": 2,
            "cell_index": 108,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [[], (), {}, set(), '', 0, 0.0, range(0)] \nfor x in l1:\n    print (f'{x} is {\"Truthy\" if x else \"Falsy\"}')",
            "outputs": []
          },
          {
            "id": "nb-0e0cf74816",
            "week": 2,
            "cell_index": 110,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:\n    total += l1[0]\n    del l1[0]\nprint(total)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "In Python conditions, values are automatically treated as 'truthy' (True) or 'falsy' (False). Key falsy values include empty collections (`[]`, `{}`, `''`), numeric zero (`0`, `0.0`), and `None`. All other values, including non-empty collections like `[0]` or strings with spaces like `' '`, are truthy. Exam questions focus on predicting whether an `if` or `else` block will execute based on the truthiness of a variab"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Does a list containing a falsy element (e.g., `[0]`) evaluate to True or False?",
            "Is an empty string (`''`) truthy or a string with a space (`' '`)?",
            "Will an empty dictionary or list trigger the `if` or `else` path?",
            "Which of the following values is truthy or falsy?",
            "How is `None` evaluated in a conditional check?",
            "What is the output of this `if/else` block?",
            "When is it better to use a full `if/else` statement instead of a ternary?",
            "Convert a simple `if/else` block to a conditional expression."
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Non-empty list is truthy",
            "code": "data = [0]\nif data:\n    print('truthy')\nelse:\n    print('falsy')",
            "why": "A list is truthy if it contains any elements, even if that element is itself falsy (like 0). The `if` block executes.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Zero (0) is falsy",
            "code": "count = 0\nif count:\n    print('Items exist')\nelse:\n    print('No items')",
            "why": "The integer 0 is a falsy value. The condition evaluates to False, so the `else` block executes.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Using a Conditional Expression Inside `print`",
            "code": "age = 20\nprint('adult' if age >= 18 else 'minor')",
            "why": "Correct. The expression `'adult' if age >= 18 else 'minor'` is evaluated first, resulting in the string 'adult', which is then passed to the `print` function.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Forgetting an empty list is falsy",
            "code": "items = []\nif items:\n    print(f'First item: {items[0]}')\nelse:\n    print('No items to show.')",
            "why": "This logic is flawed because an empty list `[]` is falsy. The `if` block will be skipped, preventing the `IndexError` that would occur from trying to access `items[0]`, but the title implies a misunderstanding of truthi",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Confusing empty string with a space",
            "code": "username = ' '\nif not username:\n    print('Username is required!')\nelse:\n    print(f'Welcome, {username}')",
            "why": "A string with a space (`' '`) is not empty and is therefore truthy. This code incorrectly assumes it's falsy, so the validation message `Username is required!` will not be printed as intended.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Confusing Statements with Expressions",
            "code": "x = 5\n# This is a SyntaxError\n# value = print('ok') if x == 5 else print('wrong')",
            "why": "This is a `SyntaxError`. The parts of a conditional expression must be values or things that produce a value. `print('ok')` is a statement that performs an action; it doesn't return a value to be assigned.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Python automatically converts expressions to boolean (`True` or `False`) when used in conditional statements like `if`, `while`, or `and`/`or` operators.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "value = []\nif value:\n    print('truthy')\nelse:\n    print('falsy')   # runs",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Falsy values include `False`, `None`, numeric zeros (`0`, `0.0`), empty sequences (`''`, `[]`, `()`, `range(0)`), and empty mappings (`{}`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Truthy/Falsy quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Boolean value"
                  ],
                  "rows": [
                    [
                      "`0`, `0.0`, `''`, `[]`, `{}`, `None`",
                      "Falsy"
                    ],
                    [
                      "Non-empty collections, non-zero numbers",
                      "Truthy"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Any non-empty collection (e.g., `[0]`, `{'key': None}`, `' '`) evaluates to `True` in a boolean context.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Truthy/Falsy quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Boolean value"
                  ],
                  "rows": [
                    [
                      "`0`, `0.0`, `''`, `[]`, `{}`, `None`",
                      "Falsy"
                    ],
                    [
                      "Non-empty collections, non-zero numbers",
                      "Truthy"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`if/elif/else` statements require consistent indentation; inconsistent indentation raises `IndentationError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Logical operators follow precedence: `not` > `and` > `or`; use parentheses to override.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "expr = True or False and False\nprint(expr)  # True (`and` evaluated before `or`)\nprint((True or False) and False)  # False",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Python supports chained comparisons: `1 < x < 5` is equivalent to `1 < x and x < 5`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 3\nprint(1 < x < 5)          # True\nprint((1 < x) and (x < 5))  # equivalent",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Conditional expressions use `value_if_true if condition else value_if_false` for concise assignments.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "Use full `if/elif/else` statements for multi-line logic or complex branching.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "The `and` operator short-circuits: it evaluates to the first falsy operand, or the last operand if all are truthy.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Short-circuit return value",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Returns"
                  ],
                  "rows": [
                    [
                      "`A and B`",
                      "First falsy operand, else `B`"
                    ],
                    [
                      "`A or B`",
                      "First truthy operand, else `B`"
                    ]
                  ]
                },
                "id": "kp-9-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(0 and 5)      # 0\nprint(3 and 5)      # 5\nprint('' or 'x')    # 'x'",
                "id": "kp-9-d2"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "The `in` operator checks for membership (substring, element in sequence, key in dict); `x in [1, 2]` checks if `x` matches `1` or `2`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print('a' in 'cat')   # True (substring)\nprint(2 in [1, 2])    # True (element)\nprint('x' in {'x': 1}) # True (dict key)",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-6f4723b001",
          "exm-f280f69ab8",
          "exm-ac7c608999",
          "exm-163328662e",
          "lec-0fb3921997",
          "lec-ce8d642b40",
          "lec-d7fa16c039",
          "lec-2f353ad9dc",
          "nb-33c2cdb26d",
          "nb-6cf4db433f"
        ]
      }
    },
    {
      "id": "topic-immutable-mutable",
      "topic": "mutable_immutable",
      "canonical_topic": "immutable mutable",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Mutable vs immutable types",
        "mutable / immutable",
        "mutable_immutable"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-874b4592ee",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Mutable vs immutable types",
            "explanation": "Immutable: int, float, str, bool, tuple. Mutable: list, dict, set. The value of a mutable object CAN be changed in-place. The value of an immutable object CANNOT be changed — a new object must be created.",
            "code_examples": [
              {
                "description": "List is mutable — can change element in place",
                "code": "l1 = [1, 2, 3]\nprint(l1)      # [1, 2, 3]\nl1[2] = 4\nprint(l1)      # [1, 2, 4]"
              },
              {
                "description": "Tuple is immutable — assigning to index raises TypeError",
                "code": "t1 = (1, 2, 3)\nt1[2] = 4\n# TypeError: 'tuple' object does not support item assignment"
              },
              {
                "description": "String reassignment creates a NEW object, not mutation",
                "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)  # False — different object"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-368b3a2107",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[4, 1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "y = x makes y point to the same list object. Appending to y also modifies x since they reference the same list."
          },
          {
            "id": "exm-132fbfd043",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 3,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "Which of the following is immutable in Python?\n\na) list\nb) dict\nc) tuple\nd) set",
            "code_context": "",
            "options": {
              "A": "list",
              "B": "dict",
              "C": "tuple",
              "D": "set"
            },
            "correct": "C",
            "explanation": "Tuples are immutable — their elements cannot be changed after creation. Lists, dicts, and sets are mutable."
          },
          {
            "id": "exm-a1a45e4e9f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nt = (1, 2, 3)\nt[0] = 10",
            "code_context": "",
            "options": {
              "A": "(10, 2, 3)",
              "B": "(1, 2, 3)",
              "C": "TypeError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Tuples are immutable. Attempting to assign to an index raises TypeError."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-c93a09bd31",
            "week": 1,
            "cell_index": 52,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-489da644f8",
            "week": 1,
            "cell_index": 54,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-0e4cc47d59",
            "week": 1,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Mutable objects (lists, dictionaries, sets) can be changed in-place after they are created. Immutable objects (integers, floats, strings, tuples) cannot. When you assign a mutable variable to another (e.g., `list_b = list_a`), both variables point to the exact same object in memory. Therefore, modifying the object through one variable will be visible through the other.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Which of the following data types is immutable: list, dict, tuple, set?",
            "If `y = x` and `x` is a list, what happens to `x` if you append an element to `y`?",
            "Why does attempting to change an element in a tuple (e.g., `my_tuple[0] = 5`) raise a `TypeError`?",
            "What is the difference between `x = x + [4]` and `x.append(4)` for a list `x`?",
            "Does `x = y` create a copy of a list or just a new reference?",
            "How does reassignment (`x = 15`) differ from mutation (`x[0] = 15`)?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Modifying a Mutable List",
            "code": "x = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "why": "`y = x` makes both variables point to the same list. Since lists are mutable, using `.append()` on `y` modifies this shared list, so the change is reflected in `x`.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Reassigning an Immutable String",
            "code": "s1 = 'hello'\ns2 = s1\ns1 = s1.upper() # Creates a new string\nprint(s2)",
            "why": "Strings are immutable. `s1.upper()` doesn't change the original 'hello' string; it creates and returns a new string 'HELLO'. `s1` is reassigned to this new string, but `s2` still points to the original 'hello'.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Attempting to Modify a Tuple",
            "code": "t = (1, 2, 3)\nt[0] = 10\nprint(t)",
            "why": "This raises a `TypeError`. Tuples are immutable, meaning their contents cannot be changed via item assignment after creation.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Confusing Reassignment with Mutation",
            "code": "x = 10\ny = x\ny = 15\nprint(x)",
            "why": "This prints 10. Integers are immutable. `y = 15` does not change the object that `x` points to. It simply makes the name `y` point to a new integer object with the value 15.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Mutable types (`list`, `dict`, `set`) allow in-place modification; immutable types (`int`, `float`, `str`, `bool`, `tuple`) always create new objects for changes.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Mutable vs immutable",
                "text": "",
                "table": {
                  "headers": [
                    "Category",
                    "Examples",
                    "Can change in place?"
                  ],
                  "rows": [
                    [
                      "Mutable",
                      "`list`, `dict`, `set`",
                      "Yes"
                    ],
                    [
                      "Immutable",
                      "`int`, `str`, `tuple`, `bool`",
                      "No"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Assigning mutable `y = x` makes `y` and `x` refer to the same object; changes via `y` affect `x`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = [1]\ny = x\ny.append(2)\nprint(x)   # [1, 2]",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Attempting to modify an element of an immutable object (e.g., `my_tuple[0] = value`) raises a `TypeError`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "`list.append(item)` modifies the list in-place; `list = list + [item]` creates a new list object.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "exm-368b3a2107",
          "exm-132fbfd043",
          "exm-a1a45e4e9f",
          "lec-874b4592ee"
        ]
      }
    },
    {
      "id": "topic-immutable-mutable-name",
      "topic": "Names",
      "canonical_topic": "name",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Mutable vs immutable types",
        "Names / variable naming rules",
        "mutable / immutable",
        "mutable_immutable",
        "mutable_immutable / names",
        "names"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-874b4592ee",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Mutable vs immutable types",
            "explanation": "Immutable: int, float, str, bool, tuple. Mutable: list, dict, set. The value of a mutable object CAN be changed in-place. The value of an immutable object CANNOT be changed — a new object must be created.",
            "code_examples": [
              {
                "description": "List is mutable — can change element in place",
                "code": "l1 = [1, 2, 3]\nprint(l1)      # [1, 2, 3]\nl1[2] = 4\nprint(l1)      # [1, 2, 4]"
              },
              {
                "description": "Tuple is immutable — assigning to index raises TypeError",
                "code": "t1 = (1, 2, 3)\nt1[2] = 4\n# TypeError: 'tuple' object does not support item assignment"
              },
              {
                "description": "String reassignment creates a NEW object, not mutation",
                "code": "box_1 = 'content'\nold_id = id(box_1)\nbox_1 = 'new content'\nnew_id = id(box_1)\nprint(old_id == new_id)  # False — different object"
              }
            ]
          },
          {
            "id": "lec-054707f60d",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Names / variable naming rules",
            "explanation": "Names can consist of letters (upper/lower), digits, and underscores. Names CANNOT start with a digit. Names ARE case-sensitive (name_1 != Name_1). Avoid Python reserved words (e.g., don't name a variable 'sorted', 'list', 'print').",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-368b3a2107",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]",
              "B": "[1, 2, 3, 4]",
              "C": "[4, 1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "y = x makes y point to the same list object. Appending to y also modifies x since they reference the same list."
          },
          {
            "id": "exm-a1a45e4e9f",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 2,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "What is the output of the following code?\n\nt = (1, 2, 3)\nt[0] = 10",
            "code_context": "",
            "options": {
              "A": "(10, 2, 3)",
              "B": "(1, 2, 3)",
              "C": "TypeError",
              "D": "None"
            },
            "correct": "C",
            "explanation": "Tuples are immutable. Attempting to assign to an index raises TypeError."
          },
          {
            "id": "exm-132fbfd043",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 3,
            "week": 1,
            "topic": "mutable / immutable",
            "question": "Which of the following is immutable in Python?\n\na) list\nb) dict\nc) tuple\nd) set",
            "code_context": "",
            "options": {
              "A": "list",
              "B": "dict",
              "C": "tuple",
              "D": "set"
            },
            "correct": "C",
            "explanation": "Tuples are immutable — their elements cannot be changed after creation. Lists, dicts, and sets are mutable."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-7465f041cc",
            "week": 1,
            "cell_index": 28,
            "cell_type": "code",
            "topic": "names",
            "source": "var_1 = 100\nvar_2 = var_1\nvar_3 = var_2\nvar_4 = var_1\nprint(id(var_1), id(var_2), id(var_3), id(var_4))\nprint(id(var_1) == id(var_2) == id(var_3) == id(var_4))\nprint(var_1 is var_2 is var_3 is var_4)",
            "outputs": []
          },
          {
            "id": "nb-632dd37679",
            "week": 1,
            "cell_index": 30,
            "cell_type": "code",
            "topic": "names",
            "source": "var_1 = 100\nprint(id(var_1))\nvar_1 = 200\nprint(id(var_1))\ndel(var_1)\nprint(id(var_1))",
            "outputs": []
          },
          {
            "id": "nb-c93a09bd31",
            "week": 1,
            "cell_index": 52,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = 100\nid1 = id(var_1)\nvar_1 = 110\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = 100.0\nid1 = id(var_1)\nvar_1 = 110.0\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = '100'\nid1 = id(var_1)\nvar_1 = '110'\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = True\nid1 = id(var_1)\nvar_1 = False\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = [100,110]\nid1 = id(var_1)\nvar_1[0] = 120\nvar_1.append(130)\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {'first': 100,'second': '110'}\nid1 = id(var_1)\nvar_1['first'] = 120\nid2 = id(var_1)\nprint(id1 == id2)\n\nvar_1 = {1, '2', 3}\nid1 = id(var_1)\nvar_1.remove(3)\nvar_1.add(4)\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-489da644f8",
            "week": 1,
            "cell_index": 54,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\nvar_1[1] = '110'\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          },
          {
            "id": "nb-0e4cc47d59",
            "week": 1,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_immutable",
            "source": "var_1 = (100, '100')\nid1 = id(var_1)\ntry:\n    var_1[1] = '110'\nexcept:\n    print ('tupples cannot be changed')\nid2 = id(var_1)\nprint(id1 == id2)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Variable names are references to objects in memory. When you execute `y = x`, both names now point to the same object. If this object is mutable (like a list), modifying it via `y` (e.g., `y.append(4)`) will also change what `x` sees. If the object is immutable (like an int), reassigning `y` (e.g., `y = 15`) simply makes `y` point to a new object, leaving `x` unaffected and still pointing to its original object."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How can you create a true, independent copy of a list instead of just a new reference?",
            "After `x = 100`, if you run `x = 200`, does the original object `100` get modified?",
            "If `y = x` where `x` is an integer, what happens to `x` when you run `y = y + 1`?",
            "If `list_b = list_a`, do `list_a` and `list_b` refer to the same object?",
            "What is the difference between the `is` operator and the `==` operator?",
            "Why might `a == b` be True while `a is b` is False for two lists?",
            "What happens if I create a variable called `list = [1, 2]`?",
            "Why do I get a `TypeError: 'list' object is not callable`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Two Names Pointing to One List",
            "code": "list_a = [10, 20]\nlist_b = list_a\nlist_b.append(30)\nprint(list_a is list_b)",
            "why": "This prints `True`. `list_b = list_a` makes both names refer to the exact same list object in memory. Any in-place modification affects the single, shared object.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Reassigning a Name for an Immutable",
            "code": "a = 50\nb = a\nb = 60\nprint(a)",
            "why": "This prints 50. `b = 60` does not change the original integer object `50`. It simply reassigns the name `b` to point to a new integer object, `60`. `a` is unaffected.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Case-Sensitive Names",
            "code": "name = 'Alice'\nName = 'Bob'\nprint(f\"{name} and {Name}\")\n# Output: Alice and Bob",
            "why": "Python is case-sensitive, so `name` and `Name` are treated as two distinct variables holding different values.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Assuming Assignment Copies a List",
            "code": "x = [1, 2]\ny = x\ny = [1, 2, 3] # This creates a NEW list\nprint(x)",
            "why": "This prints `[1, 2]`. The line `y = [1, 2, 3]` creates an entirely new list object and makes the name `y` point to it. This breaks the link to `x`, which remains unchanged.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Value vs. Identity (`==` vs `is`)",
            "code": "x = [1, 2, 3]\ny = [1, 2, 3]\nprint(x is y)",
            "why": "This prints `False`. While the lists have identical contents (`x == y` would be `True`), they are two separate, distinct objects created independently in memory.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Shadowing a Built-in Function",
            "code": "# Overwrite the built-in 'sum'\nsum = 5 + 10\n\n# Try to use the original sum() function\nmy_list = [1, 2, 3]\ntotal = sum(my_list)\n# TypeError: 'int' object is not callable",
            "why": "The variable `sum` is assigned an integer, overwriting the built-in `sum()` function. The subsequent attempt to call it as a function fails.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`a is b` checks if `a` and `b` refer to the exact same object's memory address (`id(a) == id(b)`); `a == b` checks if their values are equal.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = [1]\ny = [1]\nz = x\nprint(x == y)  # True\nprint(x is y)  # False\nprint(x is z)  # True",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "For immutable types like `int`, `x = 100` then `x = 200` makes `x` point to a new object, not modification of the original `100`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Mutable vs immutable",
                "text": "",
                "table": {
                  "headers": [
                    "Category",
                    "Examples",
                    "Can change in place?"
                  ],
                  "rows": [
                    [
                      "Mutable",
                      "`list`, `dict`, `set`",
                      "Yes"
                    ],
                    [
                      "Immutable",
                      "`int`, `str`, `tuple`, `bool`",
                      "No"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Assignment `y = x` creates a new reference `y` pointing to `x`'s object; reassigning `y` to a new object does not affect `x`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = {'k': 1}\ny = x\ny['k'] = 2\nprint(x['k'])   # 2 (same object)",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Create an independent copy of a mutable list using slicing (`new_list = old_list[:]`), `old_list.copy()`, or `copy.deepcopy()`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Do not use Python keywords (e.g., `if`, `for`) or built-in function names (e.g., `list`, `print`) as variable names to avoid shadowing.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Naming pitfalls",
                "text": "",
                "table": {
                  "headers": [
                    "Bad name",
                    "Issue"
                  ],
                  "rows": [
                    [
                      "`for`, `if`, `class`",
                      "Syntax error (keywords)"
                    ],
                    [
                      "`list`, `print`, `str`",
                      "Shadows built-ins"
                    ]
                  ]
                },
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`x = y` creates a new reference `x` to the object `y` points to; `x = value` points `x` to a new `value` object.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Name binding behavior",
                "text": "",
                "table": {
                  "headers": [
                    "Statement",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`x = y`",
                      "Bind `x` to existing object referenced by `y`"
                    ],
                    [
                      "`x = value`",
                      "Bind `x` to object produced by `value` expression"
                    ]
                  ]
                },
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Python variable names are case-sensitive; `myVar` and `myvar` refer to different entities.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "Use `id(variable)` to check if two variables refer to the exact same object in memory.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-368b3a2107",
          "lec-874b4592ee",
          "lec-054707f60d",
          "nb-7465f041cc",
          "nb-632dd37679"
        ]
      }
    },
    {
      "id": "topic-conversion",
      "topic": "Type Conversion",
      "canonical_topic": "type conversion",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Type conversion (explicit)",
        "type conversion",
        "type conversion / indexing",
        "type_conversion",
        "type_conversion / dict"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-47086e180a",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Type conversion (explicit)",
            "explanation": "Python requires explicit conversion in most cases (unlike JavaScript). Conversion functions: str(), int(), float(), bool(), tuple(), list(), set(), dict().",
            "code_examples": [
              {
                "description": "Explicit conversions",
                "code": "print(str(1) == '1')           # True\nprint(int('1') == 1)           # True\nprint(int('1a'))               # ERROR\nprint(float('1') == 1.0)       # True\nprint(float('1.0') == 1.0)     # True\nprint(tuple([1,2,3]) == (1,2,3)) # True\nprint(tuple({1:3, 2:4}) == (1,2)) # True (dict->tuple gives keys)\nprint(list(range(1,5,2)) == [1,3]) # True\nprint(dict([1, 2]))            # ERROR\nprint(dict([(1,3),(2,4)]) == {1:3, 2:4})  # True"
              },
              {
                "description": "Implicit conversion (Python allows with bool/numeric mix)",
                "code": "print(1 + True)    # 2\nprint(1.0 + False) # 1.0\nprint('1' * 2)     # '11'\nprint('1' * True)  # '1'\nprint('1' * False) # ''"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-db07780cd0",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 3,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nx = '5'\ny = 2\nprint(x * y)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "52",
              "C": "55",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "String * integer repeats the string. '5' * 2 = '55'."
          },
          {
            "id": "exm-edec745151",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 5,
            "week": 1,
            "topic": "type conversion",
            "question": "What is the output of the following code?\n\nprint(int('42') + float('3.5'))",
            "code_context": "",
            "options": {
              "A": "45",
              "B": "45.5",
              "C": "'423.5'",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "int('42')=42, float('3.5')=3.5. 42 + 3.5 = 45.5."
          },
          {
            "id": "exm-bd5df4659c",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 11,
            "week": 1,
            "topic": "type conversion / indexing",
            "question": "x = ['abc', [[]], (1, 2), {}, True, 3.0, 4]\n\nWhat is the output of the following code snippet?\n\nprint(type(float(x[2][0] + x[2][1])) == type(x[-2]))",
            "code_context": "",
            "options": {
              "a": "SyntaxError",
              "b": "IndexError: list index out of range",
              "c": "False",
              "d": "True"
            },
            "correct": "d",
            "explanation": "x[2] = (1,2). x[2][0]=1, x[2][1]=2. 1+2=3. float(3)=3.0. type(3.0)=float. x[-2]=3.0 (index 5). type(3.0)=float. float==float → True."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-8ea9af8f8b",
            "week": 1,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(int('123'))\nprint(float('123'))\n\nprint(str(123))\nprint(float(123))\n\nprint(int(123.0))\nprint(str(123.0))",
            "outputs": []
          },
          {
            "id": "nb-c488bc51d9",
            "week": 1,
            "cell_index": 24,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "integer_list = [1, 2, 3, 1]\nletter_list = ['a', 'b', 'c', 'd']\nprint(set(integer_list))\nprint(tuple(integer_list))\nprint(dict(zip(letter_list, integer_list)))\n\ninteger_tuple = (1, 2, 3, 1)\nletter_tuple = ('a', 'b', 'c', 'd')\nprint(set(integer_tuple))\nprint(list(integer_tuple))\nprint(dict(zip(letter_tuple, integer_tuple)))\n\ninteger_set = {1, 2, 3}\nletter_set = {'a', 'b', 'c'}\nprint(list(integer_set))\nprint(tuple(letter_set))\nprint(dict(zip(integer_set, letter_set)))\n\nd_1 = {1: 'c', 2: 'b', 3: 'a'}\nprint(list(d_1))\nprint(tuple(d_1))\nprint(set(d_1))",
            "outputs": []
          },
          {
            "id": "nb-b60399a503",
            "week": 2,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1 + True, 1.0 + False, True + False)",
            "outputs": []
          },
          {
            "id": "nb-01f6077d4d",
            "week": 2,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print (1==1.0, 1.0 == True, 0 == False)",
            "outputs": []
          },
          {
            "id": "nb-3f066f26aa",
            "week": 2,
            "cell_index": 106,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print ('1' * 2, '1' * True, '1' * False)",
            "outputs": []
          },
          {
            "id": "nb-a358f49009",
            "week": 2,
            "cell_index": 114,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print ('1' + 2)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-3bd8e4f40b",
            "week": 2,
            "cell_index": 117,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(str(1) == '1')\nprint(int('1') == 1)",
            "outputs": []
          },
          {
            "id": "nb-614c69b0f2",
            "week": 2,
            "cell_index": 118,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "print(float('1') == 1.0)\nprint(float('1.0') == 1.0)  \nprint(tuple([1,2,3]) == (1,2,3))  \nprint(tuple({1:3, 2:4}) == (1,2))  \nprint(dict([(1,3), (2,4)]) == {1: 3, 2:4})",
            "outputs": []
          },
          {
            "id": "nb-4a7fe9bef0",
            "week": 2,
            "cell_index": 119,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(int('1a') == 1)\nexcept Exception as e:\n    print(e)",
            "outputs": []
          },
          {
            "id": "nb-66deb9932d",
            "week": 2,
            "cell_index": 120,
            "cell_type": "code",
            "topic": "type_conversion",
            "source": "try:\n    print(dict([1, 2]))\nexcept Exception as e:\n    print(e)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Explicit type conversion is changing a value's data type using functions like `int()`, `float()`, `str()`, and `list()`. This is fundamental in Python, as operations between incompatible types (like adding a string to an integer) will raise a `TypeError` unless one is converted. Be aware that some conversions, like `int('4.5')`, are invalid and will raise a `ValueError`, while others, like `int(4.5)`, will truncate"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "When you convert a dictionary to a list using `list()`, what does the resulting list contain?",
            "How do you properly convert a string with a decimal (e.g., '25.5') into an integer?",
            "Why does `int('10.0')` raise a `ValueError` but `float('10.0')` works?",
            "What is the key difference between `'4' * 3` and `int('4') * 3`?",
            "What is the boolean value of an empty list (`bool([])`)?",
            "What is the result of `int(9.9)`?",
            "Can `True` be used in an arithmetic operation? (Yes, `True` is 1, `False` is 0)",
            "What happens if you call `dict()` on a list where an inner item isn't a pair?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Converting a List to a Set",
            "code": "my_list = [1, 2, 2, 3, 1]\nmy_set = set(my_list)\nprint(my_set)",
            "why": "Converting a list to a set creates a new collection containing only the unique elements from the original list. The result is `{1, 2, 3}`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Converting Float to Integer",
            "code": "val_float = 19.99\nval_int = int(val_float)\nprint(val_int)",
            "why": "When a float is converted to an integer, Python truncates the decimal part; it does not perform rounding. The result is 19.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Creating a Dict with `zip()`",
            "code": "keys = ['name', 'id']\nvalues = ['Bob', 42]\nd = dict(zip(keys, values))\nprint(d)",
            "why": "`zip` creates pairs `('name', 'Bob')` and `('id', 42)`, which `dict()` correctly uses to build `{'name': 'Bob', 'id': 42}`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Accidental String Concatenation",
            "code": "val1 = input('Enter first number: ') # User enters 10\nval2 = input('Enter second number: ') # User enters 20\nprint(val1 + val2)",
            "why": "The `input()` function always returns a string. Without converting to numbers, the `+` operator concatenates them, printing '1020' instead of calculating the sum 30.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Invalid String for `int()`",
            "code": "s = '42.0'\nnum = int(s)\nprint(num)",
            "why": "This raises a `ValueError`. The `int()` function cannot directly parse a string that contains a decimal point, even if the fractional part is zero.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Input Item Not a Pair",
            "code": "data = [['a', 1], ['b']]\nd = dict(data)\nprint(d)",
            "why": "This raises a `ValueError`. The common mistake is not ensuring every item passed to `dict()` is a pair. The item `['b']` only has one element, causing the conversion to fail.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Python requires explicit type conversion using functions like `int()`, `float()`, `str()`, `bool()`, `list()`, `tuple()`, `set()`, `dict()`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = '12'\nb = 3\n# print(a + b)   # TypeError\nprint(int(a) + b)   # 15\nprint(a + str(b))   # '123'",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`int(float_val)` truncates the decimal part; `int(string_val)` fails if `string_val` contains non-digit characters or decimals (e.g., `'10.0'`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-3",
            "text": "Empty collections (`[]`, `{}`, `''`, `()`) and numeric `0` are `False` in boolean contexts; others are `True`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Truthy/Falsy quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Boolean value"
                  ],
                  "rows": [
                    [
                      "`0`, `0.0`, `''`, `[]`, `{}`, `None`",
                      "Falsy"
                    ],
                    [
                      "Non-empty collections, non-zero numbers",
                      "Truthy"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Directly adding (`+`) a string and a number raises `TypeError`; convert one type to match the other.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "To convert a string containing a float to an integer, first convert to float (`float()`), then to integer (`int()`), e.g., `int(float('3.5'))` results in `3`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(int('3'))          # 3\n# int('3.5') -> ValueError\nprint(int(float('3.5'))) # 3",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Converting a `dict` to `list()` or `tuple()` yields a sequence of its keys.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-7",
            "text": "`str * int` repeats the string; `int * int` performs arithmetic.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "`True` evaluates to `1`, `False` to `0` in numeric contexts.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "Python generally requires explicit type conversion; attempting to combine incompatible types (e.g., `str` + `int`) raises a `TypeError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = '12'\nb = 3\n# print(a + b)   # TypeError\nprint(int(a) + b)   # 15\nprint(a + str(b))   # '123'",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "String multiplication (`'char' * N`) repeats the string `N` times; `N` can be `True` (repeats once) or `False` (empty string).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print('ab' * 3)       # 'ababab'\nprint('ab' * True)    # 'ab'\nprint('ab' * False)   # ''",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-db07780cd0",
          "exm-edec745151",
          "lec-47086e180a",
          "nb-3f066f26aa",
          "nb-b60399a503",
          "nb-a358f49009",
          "nb-c488bc51d9",
          "nb-614c69b0f2"
        ]
      }
    },
    {
      "id": "topic-enumerate",
      "topic": "Enumerate",
      "canonical_topic": "enumerate",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "For-loops",
        "enumerate",
        "enumerate / dictionaries / conditions",
        "enumerate()",
        "for loops / enumerate",
        "for_loop / enumerate",
        "for_loops"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) — second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          },
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used — use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-09e753703b",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 10,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nlst = ['a', 'b', 'c']\nfor i, v in enumerate(lst, start=1):\n    print(i, v)",
            "code_context": "",
            "options": {
              "A": "0 a\n1 b\n2 c",
              "B": "1 a\n2 b\n3 c",
              "C": "a 1\nb 2\nc 3",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "enumerate(lst, start=1) begins counting at 1. Output: 1 a, 2 b, 3 c."
          },
          {
            "id": "exm-b7bad1b1ce",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 8,
            "week": 2,
            "topic": "for loops / enumerate",
            "question": "What is the output of the following code?\n\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)",
            "code_context": "",
            "options": {
              "A": "0 apple\n1 banana\n2 cherry",
              "B": "1 apple\n2 banana\n3 cherry",
              "C": "apple 0\nbanana 1\ncherry 2",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "enumerate starts at 0 by default and yields (index, value) pairs."
          },
          {
            "id": "exm-f358fb2d91",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 12,
            "week": 2,
            "topic": "enumerate / dictionaries / conditions",
            "question": "def counter(y):\n\tx = {}\n\tfor index, element in enumerate(y):\n\t\tif index != int(element) and int(element) % 2 == 0:\n\t\t\tx[element] = len(element)\n\treturn x\n\nWhat will this function return when called as:\ncounter(['12345678', '1', '123', '1234', '12345', '12', '6', '1', '123456'])",
            "code_context": "",
            "options": {
              "a": "{'12345678': 8, '1234': 4, '12': 2, '123456': 6}",
              "b": "{'12345678': 8, '123': 3, '1234': 4, '12345': 5, '12': 2, '6': 1, '1': 1, '123456': 6}",
              "c": "{'123': 3, '12345': 5, '1': 1}",
              "d": "{'12345678': 8, '1': 1, '1234': 4, '12': 2, '6': 1, '123456': 6}"
            },
            "correct": "a",
            "explanation": "index 0: '12345678', int=12345678, index(0)!=12345678 ✓, even ✓ → add, len=8. index 1: '1', int=1, index==int → skip. index 2: '123', int=123, odd → skip. index 3: '1234', int=1234, index(3)!=1234 ✓, even ✓ → add, len=4. index 4: '12345', int=12345, odd → skip. index 5: '12', int=12, index(5)!=12 ✓, even ✓ → add, len=2. index 6: '6', int=6, index(6)==6 → skip. index 7: '1', int=1, odd → skip. index 8: '123456', int=123456, index(8)!=123456 ✓, even ✓ → add, len=6. Result: {'12345678':8,'1234':4,'12':2,'123456':6}. Correct: a."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "`enumerate()` adds a counter to a sequence, allowing a `for` loop to access both the index and the value of each item simultaneously. The syntax is `for index, value in enumerate(sequence)`. By default, the index starts at 0, but you can change this with a second argument, like `enumerate(sequence, start=1)`. Output questions hinge on tracking the start value and the correct assignment of index and value variables."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Predicting the index of a specific element in the sequence.",
            "Swapping the `index` and `value` variables in the loop.",
            "What is the output of this loop using `enumerate()`?",
            "Forgetting that the default start index is 0, not 1.",
            "What is the default starting value for the index?",
            "How do you change the starting index to 1?",
            "In `for idx, val in enumerate(data):`, what does `idx` represent?",
            "By default, what is the first index that `enumerate()` returns?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Enumerate with start=1",
            "code": "fruits = ['apple', 'banana']\nfor idx, val in enumerate(fruits, start=1):\n    print(f'Item {idx} is {val}')",
            "why": "Providing `start=1` as the second argument makes the counter begin at 1. The output will be `Item 1 is apple` and `Item 2 is banana`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Default enumerate starts at 0",
            "code": "fruits = ['apple', 'banana']\nfor idx, val in enumerate(fruits):\n    print(f'{idx}: {val}')",
            "why": "By default, `enumerate` starts its counter at 0. This code correctly prints the index-value pairs, resulting in `0: apple` and `1: banana`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Default `enumerate` (Starts at 0)",
            "code": "letters = ['a', 'b', 'c']\nfor index, value in enumerate(letters):\n    print(f'Index: {index}, Value: {value}')",
            "why": "This correctly iterates through the list, printing index-value pairs starting from the default index of 0.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Swapping index and value variables",
            "code": "fruits = ['apple', 'banana']\n# Goal: print index and then fruit\nfor fruit, index in enumerate(fruits):\n    print(f'{index}: {fruit}')",
            "why": "`enumerate` yields `(index, value)`. This code incorrectly assigns them to `fruit` and `index`, respectively, resulting in reversed output like `apple: 0`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Assuming enumerate modifies the list",
            "code": "fruits = ['apple', 'banana']\nenumerate(fruits)\nprint(fruits[0])",
            "why": "`enumerate` returns a new iterator object; it does not change the original list. The code will simply print 'apple', as the list remains untouched.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Mixing up Index and Value",
            "code": "letters = ['a', 'b', 'c']\nfor letter, count in enumerate(letters, 1):\n    print(letter)",
            "why": "This prints `0`, `1`, `2`. The mistake is swapping the variable names. `enumerate` always yields `(index, value)`, so here `letter` gets the index and `count` gets the value.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Use `enumerate` to access both the element and its sequential index within a loop; avoid manual index tracking with a counter variable.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "letters = ['a', 'b']\nfor idx, letter in enumerate(letters):\n    print(idx, letter)",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`enumerate(iterable)` generates `(index, value)` pairs for loop iteration, with the index starting at `0` by default.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Change the starting index for `enumerate` by passing an integer argument: `enumerate(iterable, start=N)`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`enumerate(iterable)` yields `(index, value)` pairs; `index` starts at `0` by default.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Use `for idx, val in enumerate(data):` for simultaneous index and value access.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Example: `list(enumerate(['x', 'y']))` produces `[(0, 'x'), (1, 'y')]`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`_` as a loop variable indicates an intentionally unused value, e.g., `for _ in range(5):`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "`enumerate(iterable, start=N)` begins the index count at `N`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-8-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-b7bad1b1ce",
          "exm-09e753703b",
          "exm-f358fb2d91",
          "lec-ca6bf752eb",
          "lec-1a2667a070",
          "nb-6d22b8d418"
        ]
      }
    },
    {
      "id": "topic-lambda-sorted",
      "topic": "Lambda",
      "canonical_topic": "lambda",
      "weeks": [
        2,
        3
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Lambda functions",
        "Methods vs functions",
        "filter / lambda",
        "fun_example",
        "lambda",
        "lambda / map",
        "lambda / reduce",
        "lambda / sorted",
        "sorted / lambda"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-0a5f25a4f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Lambda functions",
            "explanation": "Anonymous one-line functions. Syntax: lambda params: expression. Equivalent to a regular def but more concise. Most useful with map, filter, reduce, sorted, max.",
            "code_examples": [
              {
                "description": "Lambda basics",
                "code": "add_two = lambda x, y: x + y\nprint(add_two(1, 2))  # 3\n# Equivalent to:\ndef add_two(x, y):\n    return x + y"
              },
              {
                "description": "map() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(map(lambda x: x * 2, l1)))   # [2, 4, 6, 8, 10, 12]\n# Need list() to convert map object to list"
              },
              {
                "description": "filter() with lambda",
                "code": "l1 = [1, 2, 3, 4, 5, 6]\nprint(list(filter(lambda x: not x % 2, l1)))  # [2, 4, 6] (even numbers)"
              },
              {
                "description": "reduce() with lambda",
                "code": "from functools import reduce\nl1 = [1, 2, 3, 4, 5, 6]\nprint(reduce(lambda x, y: x*y, l1))  # 720 (product)\n# reduce with initial value:\nl1 = ['aaa', 'baab', 'c']\nprint(reduce(lambda x, y: x + y.count('a'), l1, 0))  # 5"
              },
              {
                "description": "sorted() with key lambda",
                "code": "l1 = ['aaa', 'c', 'baab']\nprint(sorted(l1))                              # ['aaa', 'baab', 'c']\nprint(sorted(l1, key=lambda x: x.count('a'))) # ['c', 'baab', 'aaa']\nprint(sorted(l1, key=len))                    # ['c', 'aaa', 'baab']\n\nd = {'a': 2, 'b': 1}\nprint(max(d.items()))                         # ('b', 1)  ← compares tuples\nprint(max(d.items(), key=lambda x: x[1]))     # ('a', 2)  ← by value"
              }
            ]
          },
          {
            "id": "lec-8bc2ca06f4",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Methods vs functions",
            "explanation": "Methods are functions attached to objects. Calling obj.method() is equivalent to Class.method(obj). For mutable objects: some methods CHANGE the object (e.g. list.sort()), some RETURN a value (e.g. list.index()). For immutable objects: methods always return a new value (can't change the object itself). COMMON ERROR: s1.upper() on strings — you must do s1 = s1.upper() to save the result.",
            "code_examples": [
              {
                "description": "Method on immutable — must capture return value",
                "code": "s1 = 'UVA Amsterdam'\ns1 = s1.upper()  # CORRECT — captures new string\ns1.upper()       # WRONG — result is lost, s1 unchanged"
              },
              {
                "description": "Method on mutable — changes in place vs returns value",
                "code": "l1 = [3, 1, 2]\nl1.sort()           # changes l1 in place, returns None\nprint(l1)           # [1, 2, 3]\nprint(l1.index(2))  # 1 (returns index, doesn't change l1)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-fcf6f31262",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 15,
            "week": 3,
            "topic": "lambda",
            "question": "What is the output of the following code?\n\ndouble = lambda x: x * 2\nprint(double(5))",
            "code_context": "",
            "options": {
              "A": "25",
              "B": "10",
              "C": "52",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "The lambda multiplies its argument by 2. double(5) = 5 * 2 = 10."
          },
          {
            "id": "exm-9ac62bbb4e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 18,
            "week": 3,
            "topic": "lambda",
            "question": "What is the output of the following code?\n\nf = lambda x, y: x if x > y else y\nprint(f(3, 7))",
            "code_context": "",
            "options": {
              "A": "3",
              "B": "7",
              "C": "10",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "3 > 7 is False, so the lambda returns y = 7."
          },
          {
            "id": "exm-17c4e4022d",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 12,
            "week": 3,
            "topic": "lambda / sorted",
            "question": "What is the output of the following code?\n\npairs = [(1, 3), (2, 1), (3, 2)]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nprint(sorted_pairs)",
            "code_context": "",
            "options": {
              "A": "[(1, 3), (2, 1), (3, 2)]",
              "B": "[(2, 1), (3, 2), (1, 3)]",
              "C": "[(3, 2), (2, 1), (1, 3)]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Sorted by second element (x[1]): 1 < 2 < 3. Result: [(2,1), (3,2), (1,3)]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-711110ef0a",
            "week": 2,
            "cell_index": 122,
            "cell_type": "code",
            "topic": "fun_example",
            "source": "x,y = 3,1\nprint(x,y)\nx = x + y\ny = x - y\nx = x - y\nprint(x,y)",
            "outputs": []
          },
          {
            "id": "nb-b257dde94b",
            "week": 3,
            "cell_index": 59,
            "cell_type": "code",
            "topic": "lambda",
            "source": "multiply_and_double = lambda x, y: 2*x*y  \nprint(multiply_and_double(1,3))",
            "outputs": []
          },
          {
            "id": "nb-64fa3cf49c",
            "week": 3,
            "cell_index": 60,
            "cell_type": "code",
            "topic": "lambda",
            "source": "def multiply_and_double(x,y):\n    return 2*x*y\nprint(multiply_and_double(1,3))",
            "outputs": []
          },
          {
            "id": "nb-ead5baf6cb",
            "week": 3,
            "cell_index": 62,
            "cell_type": "code",
            "topic": "lambda",
            "source": "print((lambda x, y: 2*x*y)(4, 3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "A 'lambda' function is a small, one-line anonymous function defined using the 'lambda' keyword. It's restricted to a single expression and is most useful when you need a short-lived function for a simple task, like providing a 'key' for sorting. The 'sorted()' function can take a 'lambda' as its key argument to specify a custom sorting logic, for instance, to sort a list of tuples based on the second element of each"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the difference between 'list.sort()' and 'sorted(list)'?",
            "Rewrite this lambda function using a standard 'def' statement.",
            "What will be the output of 'sorted()' using this lambda key?",
            "Sort a list of dictionaries by a specific value.",
            "Can a lambda function contain an 'if/else'?",
            "What does this lambda function return?",
            "What happens if you use `map` on lists of unequal length with a two-argument lambda?",
            "Write a `lambda` with `map` to get the first letter of each string in a list."
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Sorting tuples by the second element",
            "code": "pairs = [(1, 'c'), (2, 'a'), (3, 'b')]\nsorted_pairs = sorted(pairs, key=lambda p: p[1])\nprint(sorted_pairs)",
            "why": "The lambda function 'lambda p: p[1]' tells 'sorted' to use the second element of each tuple ('c', 'a', 'b') as the sorting key. The list is therefore sorted alphabetically by this element, resulting in [(2, 'a'), (3, 'b",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Simple lambda assigned to a variable",
            "code": "adder = lambda x, y: x + y\nresult = adder(5, 3)\nprint(result)",
            "why": "A lambda function can be assigned to a variable to be used like a regular function. Here, 'adder' is a function that takes two arguments and returns their sum. The result is 8.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Filter Strings by Length",
            "code": "words = ['cat', 'window', 'defenestrate']\nlong_words = filter(lambda s: len(s) > 6, words)\nprint(list(long_words))\n# Output: ['window', 'defenestrate']",
            "why": "This demonstrates using a `lambda` with a condition based on a string property. `filter` iterates through the list and keeps only the strings that satisfy the length requirement.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Lambda with a statement, not an expression",
            "code": "# This code is invalid and will not run\n# adder = lambda x: total += x\n# print(adder(5))",
            "why": "A lambda function can only contain a single expression (a piece of code that evaluates to a value), not a statement (an instruction like an assignment). The line 'total += x' is an assignment statement, which is illegal",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Confusing sorted() with list.sort()",
            "code": "my_list = [3, 1, 2]\nnew_list = my_list.sort(key=lambda x: -x)\nprint(new_list)",
            "why": "The 'list.sort()' method sorts the list in-place and returns 'None'. The variable 'new_list' will be 'None'. To get the sorted list, you should use the 'sorted()' function: 'new_list = sorted(my_list, key=lambda x: -x)'.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Wrong Number of Arguments in Lambda",
            "code": "from functools import reduce\nnumbers = [1, 2, 3]\n# This line causes a TypeError\nresult = reduce(lambda x: x + 1, numbers)\n# TypeError: <lambda>() missing 1 required positional argument: 'y'",
            "why": "The function passed to `reduce` must accept two arguments: the accumulated value and the next item from the iterable. This `lambda` only accepts one, causing a `TypeError`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`sorted(iterable, key=lambda x: ...)` returns a new sorted list; `list.sort(key=lambda x: ...)` sorts in-place and returns `None`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `lambda` for concise operations, commonly with `sorted()`, `map()`, `filter()` via the `key` argument.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Lambda functions are anonymous, single-expression functions: `lambda args: expression`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Lambda functions can include conditional expressions: `lambda x, y: x if x > y else y`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`lambda` functions permit only a single expression, implicitly returning its result, and cannot contain multiple statements.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`filter()` evaluates each item, including multiple arguments from iterables, passing items that meet the condition.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`reduce(function, iterable, initial_value)` uses `initial_value` as the starting accumulator for empty iterables.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Prefer `def` for complex logic or multi-statement functions; restrict `lambda` to simple, concise operations.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`reduce(function, iterable)` applies `function` cumulatively to items, reducing `iterable` to a single value.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Conditional logic within `lambda` functions uses the ternary operator: `lambda x, y: x if x > y else y`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3, 4]\nprint(list(map(lambda x: x * 2, nums)))      # [2, 4, 6, 8]\nprint(list(filter(lambda x: x % 2 == 0, nums)))  # [2, 4]",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-fcf6f31262",
          "exm-9ac62bbb4e",
          "exm-17c4e4022d",
          "lec-0a5f25a4f4",
          "nb-b257dde94b",
          "nb-ead5baf6cb",
          "nb-64fa3cf49c"
        ]
      }
    },
    {
      "id": "topic-falsy-truthy",
      "topic": "truthy_falsy",
      "canonical_topic": "falsy truthy",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Truthy and Falsy",
        "conditions / truthy falsy",
        "truthy / falsy",
        "truthy_falsy"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-0fb3921997",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Truthy and Falsy",
            "explanation": "In conditions, Python auto-converts to bool. Falsy: [], (), {}, set(), '', 0, 0.0, range(0), None. Truthy: everything else (non-empty collections, non-zero numbers).",
            "code_examples": [
              {
                "description": "Falsy values",
                "code": "# All evaluate to False in a condition:\n[]    # empty list\n()    # empty tuple\n{}    # empty dict\nset() # empty set\n''    # empty string\n0     # zero int\n0.0   # zero float"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-6f4723b001",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 8,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following values is truthy in Python?",
            "code_context": "",
            "options": {
              "A": "0",
              "B": "''",
              "C": "[]",
              "D": "' '"
            },
            "correct": "D",
            "explanation": "A string with at least one space is truthy. 0, empty string, and empty list are all falsy."
          },
          {
            "id": "exm-f280f69ab8",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 7,
            "week": 2,
            "topic": "conditions / truthy falsy",
            "question": "What is the output of the following code?\n\nx = 0\nif x:\n    print('truthy')\nelse:\n    print('falsy')",
            "code_context": "",
            "options": {
              "A": "truthy",
              "B": "falsy",
              "C": "0",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "0 is falsy in Python. The else branch executes, printing 'falsy'."
          },
          {
            "id": "exm-ac7c608999",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 12,
            "week": 2,
            "topic": "truthy / falsy",
            "question": "Which of the following expressions evaluates to True?",
            "code_context": "",
            "options": {
              "A": "bool([])",
              "B": "bool(0)",
              "C": "bool('')",
              "D": "bool([0])"
            },
            "correct": "D",
            "explanation": "A list with one element [0] is truthy even though the element itself is falsy. [], 0, and '' are all falsy."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-33c2cdb26d",
            "week": 2,
            "cell_index": 108,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [[], (), {}, set(), '', 0, 0.0, range(0)] \nfor x in l1:\n    print (f'{x} is {\"Truthy\" if x else \"Falsy\"}')",
            "outputs": []
          },
          {
            "id": "nb-0e0cf74816",
            "week": 2,
            "cell_index": 110,
            "cell_type": "code",
            "topic": "truthy_falsy",
            "source": "l1 = [1, 2, 3, 4, 5, 6]\ntotal = 0\nwhile l1:\n    total += l1[0]\n    del l1[0]\nprint(total)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "In boolean contexts like 'if' or 'while' statements, Python automatically evaluates values as either 'Truthy' or 'Falsy'. 'Falsy' values are those that are considered 'empty' or 'zero': 0, 0.0, '', [], {}, (), set(), and None. Every other value is 'Truthy', including non-empty strings (like ' ') and non-empty lists (like [0]). The key trap is that a collection's truthiness depends on whether it's empty, not on the t…",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Which of the following values is Truthy/Falsy?",
            "Which branch of an if/else statement will be executed?",
            "Why is an empty list Falsy but a list containing a zero is Truthy?",
            "Will this 'while' loop run? If so, when will it stop?",
            "What is the output of 'bool([])' vs 'bool([0])'?",
            "Which of these expressions evaluates to True?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Non-empty list is Truthy",
            "code": "my_list = [0]\nif my_list:\n    print('Truthy')\nelse:\n    print('Falsy')",
            "why": "The list 'my_list' is not empty, so it is Truthy. The fact that its only element, 0, is Falsy is irrelevant. The code prints 'Truthy'.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "While loop on a list",
            "code": "items = [1, 2]\nwhile items:\n    print(items.pop())\n# Prints 2, then 1",
            "why": "The 'while' loop continues as long as the 'items' list is Truthy (not empty). '.pop()' removes and returns the last item, eventually emptying the list. When 'items' becomes [], it is Falsy, and the loop terminates.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Confusing 0 and '0'",
            "code": "value = '0'\nif value:\n    print('Is this Truthy?')\nelse:\n    print('Or Falsy?')",
            "why": "This prints 'Is this Truthy?'. The integer 0 is Falsy, but the string '0' is not empty, so it is Truthy. This is a common mistake.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Assuming an empty-looking string is Falsy",
            "code": "value = ' '\nif not value:\n    print('It was Falsy')\nelse:\n    print('It was Truthy')",
            "why": "This prints 'It was Truthy'. A string containing only whitespace is not an empty string (''). Since it is not empty, it is considered Truthy.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Falsy values: `None`, `False`, `0`, `0.0`, `''`, `[]`, `()`, `{}` (empty collections).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "Any non-empty collection (list, tuple, dict, set), non-zero number, or non-empty string is Truthy.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "Python implicitly converts values to boolean in `if` conditions, `while` loops, and `bool()` calls.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "`bool([])` evaluates to `False` (falsy empty list); `bool([0])` evaluates to `True` (truthy non-empty list).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "exm-6f4723b001",
          "exm-f280f69ab8",
          "exm-ac7c608999",
          "lec-0fb3921997",
          "nb-33c2cdb26d",
          "nb-0e0cf74816"
        ]
      }
    },
    {
      "id": "topic-args-mutable",
      "topic": "mutable args",
      "canonical_topic": "args mutable",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "midterm_2024": 2,
          "trial_midterm": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "default args / mutable defaults",
        "mutable args",
        "mutable args / side effects",
        "mutable_args"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [],
        "exam_questions": [
          {
            "id": "exm-88bc6a52d4",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 20,
            "week": 3,
            "topic": "mutable args",
            "question": "What is the output of the following code?\n\ndef append_to(element, to):\n    to.append(element)\n    return to\n\nmy_list = []\nresult1 = append_to(1, my_list)\nresult2 = append_to(2, my_list)\nprint(result1)\nprint(result2)",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]",
              "B": "[1]\n[1, 2]",
              "C": "[1, 2]\n[1, 2]",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "Both result1 and result2 refer to the same list my_list. After both calls, my_list = [1, 2], so both prints show [1, 2]."
          },
          {
            "id": "exm-d2e7fd42c3",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 16,
            "week": 3,
            "topic": "default args / mutable defaults",
            "question": "What is the output of the following code?\n\ndef func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))\nprint(func(3, []))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[3]",
              "C": "[1]\n[1, 2]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "func(1) and func(2) share the default list: [1] then [1,2]. func(3,[]) uses a fresh list: [3]."
          },
          {
            "id": "exm-245b0664c1",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 23,
            "week": 3,
            "topic": "mutable args / side effects",
            "question": "What is the output of the following code?\n\ndef double_list(lst):\n    lst = [x * 2 for x in lst]\n    return lst\n\nmy_list = [1, 2, 3]\nresult = double_list(my_list)\nprint(my_list)\nprint(result)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[2, 4, 6]",
              "B": "[2, 4, 6]\n[2, 4, 6]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "Inside the function, lst = [...] rebinds the local name to a new list. my_list is not modified. result is [2,4,6]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-a6c56752fc",
            "week": 3,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "mutable_args",
            "source": "def adder(l2):\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
            "outputs": []
          },
          {
            "id": "nb-de31c2de52",
            "week": 3,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "mutable_args",
            "source": "def adder(l2):\n    l2 = l2[:]\n    result = 0\n    while l2:\n        result += l2[0]\n        del l2[0]  \n    return result\nl1 = [1, 2, 3, 4, 5]\ntotal = adder(l1)\nprint(f\"The sum of {l1} = {total}\")",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Using a mutable type like a list or dictionary as a default function argument is a major trap. The default object is created only once when the function is defined and is shared across all calls that don't supply their own argument. This means if one call modifies the list, the change persists for the next call. The correct and safe pattern is to use 'None' as the default and then create a new list or dict inside th…",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the output of the second and third calls to this function?",
            "Explain why the list appears to 'remember' items from previous calls.",
            "How would you rewrite this function to prevent this side effect?",
            "What happens if you pass an explicit empty list '[]' in the call?",
            "What is the difference between 'lst.append(x)' and 'lst = lst + [x]' inside a function?",
            "What is the value of the original list passed to the function after the function returns?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Safe way to use mutable defaults",
            "code": "def add_item(item, target=None):\n    if target is None:\n        target = []\n    target.append(item)\n    return target\n\nprint(add_item(1))\nprint(add_item(2))",
            "why": "This is the correct pattern. A new empty list is created inside the function whenever one isn't provided. The first call returns [1], and the second call, being independent, returns [2].",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Rebinding a name does not affect caller",
            "code": "def double_vals(numbers):\n    numbers = [n * 2 for n in numbers]\n    return numbers\n\ndata = [1, 2, 3]\ndoubled_data = double_vals(data)\nprint(data) # Prints [1, 2, 3]",
            "why": "Inside the function, the name 'numbers' is reassigned to a brand new list created by the list comprehension. This does not change the original 'data' list outside the function.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Classic mutable default argument trap",
            "code": "def add_to_list(item, my_list=[]):\n    my_list.append(item)\n    return my_list\n\nprint(add_to_list(1))\nprint(add_to_list(2))",
            "why": "The default list 'my_list' is created once and shared. The first call appends 1 and returns [1]. The second call uses the *same list*, appends 2, and returns [1, 2]. This is usually not the intended behavior.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Modifying a passed-in list",
            "code": "def clear_list(numbers):\n    numbers = [] # This does NOT clear the original\n\ndata = [1, 2, 3]\nclear_list(data)\nprint(data)",
            "why": "This prints '[1, 2, 3]'. The assignment 'numbers = []' only reassigns the local name 'numbers' inside the function to a new empty list. It does not affect the original 'data' object from the caller's scope. To clear the…",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Mutable default arguments (e.g., `lst=[]`) are created once when the function is defined and retain state across calls.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Avoid mutable default arguments to prevent unexpected side effects; use `None` as default and initialize inside: `def func(x, lst=None): lst = [] if lst is None else lst`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Modifying a mutable argument (`lst.append(x)`) affects the original object passed into the function.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "Reassigning a parameter within a function (`lst = [...]`) creates a new local object, leaving the original external object unchanged.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def rebind(lst):\n    lst = [99]      # local rebinding only\n\na = [1, 2]\nrebind(a)\nprint(a)            # [1, 2]",
                "id": "kp-4-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-88bc6a52d4",
          "exm-d2e7fd42c3",
          "exm-245b0664c1",
          "nb-a6c56752fc",
          "nb-de31c2de52"
        ]
      }
    },
    {
      "id": "topic-return",
      "topic": "Return / None",
      "canonical_topic": "return / none",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 3,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 3
      },
      "related_topics": [
        "Implicit return — None",
        "Return statement",
        "global / return None",
        "multiple_returns",
        "return / None",
        "return / None / global",
        "return statement",
        "return_statement"
      ],
      "trap_patterns": [
        {
          "pattern": "Implicit return None",
          "trap": "Function without return statement, or where return is not reached, returns None. print(func()) will print None.",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        },
        {
          "pattern": "map/filter return iterables, not lists",
          "trap": "list(map(lambda x: x*2, l)) — must wrap in list(). Without it: <map object at 0x...>",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-c2c935e354",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Implicit return — None",
            "explanation": "If a function reaches the end without a return statement, Python returns None automatically. This is bad practice but you must know it. Test with: if a != None:  or  if a is not None:",
            "code_examples": [
              {
                "description": "Implicit None return",
                "code": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)  # Returns None (no return hit)\nprint(a)           # None"
              }
            ]
          },
          {
            "id": "lec-7ac5f34762",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Return statement",
            "explanation": "Returns a value to the caller. If you don't capture the return value it's lost. A function leaves no traces — local names are gone after function ends. Common error: using print() instead of return in homework functions.",
            "code_examples": [
              {
                "description": "Returning a tuple (multiple values)",
                "code": "def powers(n1):\n    return n1 ** 2, n1 ** 3  # returns a tuple\npower2, power3 = powers(3)\nprint(power2, power3)  # 9 27"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-9352bcbef8",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 14,
            "week": 3,
            "topic": "return / None",
            "question": "What is the output of the following code?\n\ndef func(x):\n    if x > 0:\n        return x\n\nprint(func(-1))",
            "code_context": "",
            "options": {
              "A": "-1",
              "B": "0",
              "C": "None",
              "D": "Error"
            },
            "correct": "C",
            "explanation": "func(-1): condition x>0 is False, function falls through without a return statement and implicitly returns None."
          },
          {
            "id": "exm-06f3293a1e",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 10,
            "week": 3,
            "topic": "return statement",
            "question": "What is the output of the following code?\n\ndef func():\n    return 1, 2, 3\n\nresult = func()\nprint(type(result))",
            "code_context": "",
            "options": {
              "A": "<class 'list'>",
              "B": "<class 'tuple'>",
              "C": "<class 'int'>",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "Returning multiple values with commas creates a tuple. type(result) is tuple."
          },
          {
            "id": "exm-63fab512ff",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 7,
            "week": 3,
            "topic": "return / None / global",
            "question": "def multiply(num1, num2):\n\tglobal result\n\tresult = num1 * num2\n\nprint(multiply(2, 3))\nprint(result)",
            "code_context": "",
            "options": {
              "a": "6\n6",
              "b": "None\n6",
              "c": "6\nNone",
              "d": "None\nNone"
            },
            "correct": "b",
            "explanation": "multiply() has no return statement, so it returns None. print(multiply(2,3)) prints None. But inside, global result is set to 6. print(result) prints 6. Output: None, 6."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-f2dcb6af3e",
            "week": 3,
            "cell_index": 16,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    total = n1 + n2\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-fcd5ecd9a3",
            "week": 3,
            "cell_index": 17,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    if type(n1) == type(n2) == int:\n        total = n1 + n2\n        return total\na = adder('1', 2)\nif a != None:\n    print ('The result is: ' + a)\nelse:\n    print ('Wrong numbers')",
            "outputs": []
          },
          {
            "id": "nb-659c693cdd",
            "week": 3,
            "cell_index": 18,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def adder(n1, n2):\n    return n1 + n2\na = adder(1,2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-4e869348fc",
            "week": 3,
            "cell_index": 19,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\na = powers(3)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-af7cb6892e",
            "week": 3,
            "cell_index": 20,
            "cell_type": "code",
            "topic": "return_statement",
            "source": "def powers(n1):\n    return n1 ** 2, n1 ** 3\npower2, power3 = powers(3)\nprint(power2, power3)",
            "outputs": []
          },
          {
            "id": "nb-20730924fb",
            "week": 3,
            "cell_index": 22,
            "cell_type": "code",
            "topic": "multiple_returns",
            "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        return n1+n2\n    return n1*n2\nprint(calculator())",
            "outputs": []
          },
          {
            "id": "nb-1551629e6c",
            "week": 3,
            "cell_index": 23,
            "cell_type": "code",
            "topic": "multiple_returns",
            "source": "def calculator():\n    n1 = int(input('First number? '))\n    while (operator :=input('Type of calculation? ')) not in '+*':\n        print(\"Only operators '+' and '*' allowed\")\n    n2 = int(input('Second number? '))\n    if operator == '+':\n        result = n1+n2\n    else:\n        result = n1 * n2\n    return result    \nprint(calculator())",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "A function can modify a global variable using the `global` keyword but still return `None` if it lacks an explicit `return` statement. Exam questions test this by printing the function call (which shows `None`) and then printing the modified global variable. You must track both the function's return value and its side-effect on the global state."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "In a function with an `if/else`, if only the `if` block has a `return`, what does the `else` path return?",
            "What `TypeError` might occur if a function that sometimes returns `None` is used in an expression?",
            "If a function modifies a global variable but has no `return`, what does `print(func())` show?",
            "What is the sequence of outputs for printing the function call, then the global variable?",
            "What happens if you forget the `global` keyword when trying to change a global variable?",
            "What is the return value of a method like `list.sort()` that modifies a list in-place?",
            "Can a function both modify a global variable and return a completely different value?",
            "If `my_func()` implicitly returns `None`, what is the output of `print(my_func())`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Function with no return statement",
            "code": "def greet(name):\n    message = f\"Hello, {name}\"\n\nresult = greet(\"World\")\nprint(result)",
            "why": "The `greet` function calculates a message and assigns it to a local variable, but never returns it. The function finishes and implicitly returns `None`, which is assigned to `result` and printed.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Conditional return not triggered",
            "code": "def find_admin(users):\n    for u in users:\n        if u == \"admin\":\n            return u\n\nfound = find_admin([\"guest\", \"user\"])\nprint(found)",
            "why": "The loop finishes without finding \"admin\", so the `return u` statement is never executed. The function implicitly returns `None` after the loop completes.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Modify Global and Return a Value",
            "code": "x = 10\ndef double_and_update():\n    global x\n    x = x * 2\n    return 'Done'\n\nprint(double_and_update())\nprint(x)",
            "why": "The function changes the global `x` to 20 and also explicitly returns the string 'Done'. The output is 'Done' from the first print, and `20` from the second.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Error from Unexpected None",
            "code": "def get_initial(name):\n    if len(name) > 0:\n        return name[0]\n\ninitial = get_initial(\"\")\nprint(initial + \".\")",
            "why": "The function is called with an empty string, so it returns `None`. The code then attempts to compute `None + \".\"`, which raises a `TypeError`. The code should have checked if `initial` was `None` before using it.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Forgetting the 'global' Keyword",
            "code": "value = 50\ndef set_to_zero():\n    value = 0 # This is a new LOCAL variable\n\nprint(set_to_zero())\nprint(value)",
            "why": "The assignment `value = 0` creates a new local variable, it does not change the global one. The function returns `None`. The global `value` is unchanged. The output is `None`, then `50`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Confusing Print with Return",
            "code": "def show_sum(a, b):\n    print(a + b)\n\nresult = show_sum(5, 3)\nprint(result)",
            "why": "This is a classic trap. The function prints `8`, but it does not have a `return` statement, so it returns `None`. `result` is assigned `None`, which is printed on the next line. The final output is `8` then `None`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "In-place modifying methods (e.g., `list.sort()`) return `None`, not the modified object, even if they affect global data structures.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [3, 1, 2]\nout = nums.sort()\nprint(nums)   # [1, 2, 3]\nprint(out)    # None",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Attempting arithmetic or attribute access on a `None` value (e.g., `None + 5`) results in a `TypeError` or `AttributeError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "result = None\n# print(result + 5)   # TypeError\nif result is None:\n    result = 0",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "A function modifying a global variable without an explicit `return` statement still implicitly returns `None` to its caller.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f():\n    x = 1\n\nprint(f())  # None",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Use the `global` keyword inside a function to modify a global variable; otherwise, assignment creates a new local variable.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "count = 0\ndef inc_global():\n    global count\n    count += 1\n\ndef outer():\n    n = 0\n    def inner():\n        nonlocal n\n        n += 1",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "A function without an explicit `return` statement or one where `return` is not executed implicitly returns `None`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f():\n    x = 1\n\nprint(f())  # None",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`return val1, val2` packs multiple values into a single tuple; use tuple unpacking `a, b = func()` to assign them.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def split_name(full):\n    first, last = full.split()\n    return first, last\n\na, b = split_name('Ada Lovelace')",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "A function can both modify global state (side effect) and return a value; these two actions are independent.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "total = 0\ndef add_and_store(x):\n    global total\n    total += x      # side effect\n    return total    # return value",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`print()` displays output to the console; `return` sends a value back to the caller for use or assignment.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "print vs return",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword/function",
                    "Purpose"
                  ],
                  "rows": [
                    [
                      "`print(...)`",
                      "Show text/value to console"
                    ],
                    [
                      "`return ...`",
                      "Send value back to caller"
                    ]
                  ]
                },
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "A function that finishes execution without an explicit `return` statement implicitly returns `None`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f():\n    x = 1\n\nprint(f())  # None",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "`print(func())` outputs `None` if `func` does not explicitly return a value, showing `print()`'s output first if any.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-9352bcbef8",
          "exm-63fab512ff",
          "exm-06f3293a1e",
          "lec-c2c935e354",
          "lec-7ac5f34762",
          "nb-f2dcb6af3e",
          "nb-fcd5ecd9a3",
          "nb-af7cb6892e",
          "nb-4e869348fc"
        ]
      }
    },
    {
      "id": "topic-object",
      "topic": "Objects",
      "canonical_topic": "object",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "midterm_2023": 1,
          "midterm_2024": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "Object types — the 8 types to know",
        "Objects/types",
        "Objects: core properties",
        "objects",
        "objects / identity",
        "objects / type / is vs ==",
        "objects / types"
      ],
      "trap_patterns": [
        {
          "pattern": "Slicing creates a NEW object",
          "trap": "l2=l1 vs l2=l1[:] — l2=l1 shares the SAME object, slicing creates independent copy",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023",
            "midterm_2024",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-03d78ccf62",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Object types — the 8 types to know",
            "explanation": "int, float, str, bool, tuple, list, dict, set",
            "code_examples": [
              {
                "description": "All 8 types",
                "code": "var_1 = 123              # int\nvar_2 = 123.3            # float\nvar_3 = '123'            # str\nvar_4 = True             # bool\nvar_5 = ('123', 123)     # tuple\nvar_6 = [123, '123']     # list\nvar_7 = {'k1': 'v1'}     # dict\nvar_8 = {123, '123'}     # set"
              }
            ]
          },
          {
            "id": "leq-eb2764fa14",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Objects/types",
            "question": "Which of the following statements is correct? I: Two objects can have different values, while having the same type. II: Two objects can have the same value, while having different types.",
            "options": {
              "a": "I is correct",
              "b": "II is correct",
              "c": "I and II are both correct",
              "d": "Neither is correct"
            },
            "correct": "a",
            "explanation": "I is correct (e.g. a=1, b=2, both int). II is incorrect — if two objects have the same value they must have the same type."
          },
          {
            "id": "lec-8c4ac0f026",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Objects: core properties",
            "explanation": "Every object has exactly one unique id (cannot change), exactly one type (cannot change), and exactly one value. The type defines what value can be stored and whether the value is mutable or immutable. An object can have zero, one, or more names bound to it. A name can only refer to one object at any time.",
            "code_examples": []
          }
        ],
        "exam_questions": [
          {
            "id": "exm-ab87bba39e",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 1,
            "week": 1,
            "topic": "objects / types",
            "question": "What is the output of the following code?\n\nprint(type(True))",
            "code_context": "",
            "options": {
              "A": "<class 'int'>",
              "B": "<class 'bool'>",
              "C": "<class 'str'>",
              "D": "<class 'NoneType'>"
            },
            "correct": "B",
            "explanation": "True is of type bool in Python."
          },
          {
            "id": "exm-58c16c860b",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 1,
            "week": 1,
            "topic": "objects / identity",
            "question": "What is the output of the following code?\n\nx = 257\ny = 257\nprint(x is y)",
            "code_context": "",
            "options": {
              "A": "True",
              "B": "False",
              "C": "Error",
              "D": "None"
            },
            "correct": "B",
            "explanation": "For integers outside the range [-5, 256], Python does not guarantee interning. Two separate 257 literals are different objects, so 'is' returns False."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-ebb2df2e4e",
            "week": 1,
            "cell_index": 11,
            "cell_type": "markdown",
            "topic": "objects",
            "source": "### Everything in Python is an object. Objects in Python have one id, one value, one type, and zero or more names\n<br>An assignment statement is one of the ways to create an object. An object created with an assignment statement will have a name, an id, a value and a type.\n<br>If you know the name you can ask for the id, the value, and the type",
            "outputs": []
          },
          {
            "id": "nb-522899bb07",
            "week": 1,
            "cell_index": 12,
            "cell_type": "code",
            "topic": "objects",
            "source": "a = 1\nprint(id(a))\nprint(a)\nprint(type(a))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Every value in Python is an object with a unique ID, a fixed type, and a value. The `is` operator checks if two variables point to the exact same object (comparing their IDs), while `==` checks if their values are equal. For output questions, pay close attention to whether the code uses `is` or `==`, especially with mutable types like lists or integers outside the range of -5 to 256, where Python creates separate ob"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the key difference between the `is` operator and the `==` operator?",
            "Will `x is y` be `True` or `False` for large integers or strings?",
            "If `a == b` is true, does that guarantee `a is b` is also true?",
            "Are lists mutable or immutable? What about tuples and strings?",
            "What is the difference between the `is` and `==` operators?",
            "Can an object's ID or type change after it is created?",
            "If `list2 = list1[:]`, are they one object or two?",
            "Why might `a = 257; b = 257; a is b` be `False`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Identity (`is`) vs. Equality (`==`)",
            "code": "list_a = [1, 2]\nlist_b = [1, 2]\nlist_c = list_a\n\nprint(list_a == list_b) # True\nprint(list_a is list_b) # False\nprint(list_a is list_c) # True",
            "why": "`list_a` and `list_b` are two separate objects in memory that happen to have the same value. `list_c` is just another name for the exact same object as `list_a`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Integer Caching (Interning)",
            "code": "x = 256\ny = 256\nprint(x is y)",
            "why": "Python pre-allocates and reuses integer objects in the range [-5, 256]. Since `256` is in this range, `x` and `y` both point to the exact same object in memory, so `is` returns `True`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Lists: `is` vs `==`",
            "code": "a = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b) # True\nprint(a is b) # False",
            "why": "The lists have the same values, so `==` is True. However, they are two separate objects in memory, so `is` is False.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Integer Interning (Outside Range)",
            "code": "a = 257\nb = 257\nprint(a is b)",
            "why": "This is a classic trap. `257` is outside the common range of cached integers. Python may create two separate integer objects for `a` and `b`. While their values are equal (`a == b`), they are not the same object, so `",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Attempting to Mutate an Immutable Object",
            "code": "my_tuple = (10, 20, 30)\nmy_tuple[0] = 5",
            "why": "This raises a `TypeError`. A `tuple` is an immutable object type. Once created, you cannot change, add, or remove its elements. A common mistake is to confuse tuples with lists, which are mutable.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Assuming `is` is Always True for Equal Immutables",
            "code": "# Goal: check if two large numbers are the same\nx = 1000\ny = 1000\n# This might print True or False depending on the Python version\nprint(x is y)",
            "why": "Python caches small integers (-5 to 256), making `is` return `True` for them. This is not guaranteed for larger numbers or other immutable types. Always use `==` to compare values.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Integers in the range [-5, 256] are often interned, causing `a is b` to be `True` for identical values in this range, but generally `False` for larger integers.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional exam-safe rule",
                "text": "Treat interning as implementation detail; use `==` for values, not `is`.",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`int`, `float`, `str`, `tuple`, `bool` are immutable (operations create new objects); `list`, `dict`, `set` are mutable (can be changed in place).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Mutability quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Type family",
                    "In-place update?"
                  ],
                  "rows": [
                    [
                      "`int`, `float`, `str`, `tuple`, `bool`",
                      "No"
                    ],
                    [
                      "`list`, `dict`, `set`",
                      "Yes"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Slicing a mutable sequence `new_list = old_list[:]` creates a *new shallow copy* (a distinct object with its own identity).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [[1], [2]]\nb = a[:]         # shallow copy\nb[0].append(9)\nprint(a)         # [[1, 9], [2]] (inner list shared)",
                "id": "kp-3-d1"
              },
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `copy.deepcopy(...)` when nested mutable objects must be fully independent.",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Small integers (-5 to 256) and certain string literals are often interned, causing `is` to return `True` for equal values.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional exam-safe rule",
                "text": "Use `==` for value comparison in exams; reserve `is` for identity checks (`None`, singleton objects).",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`is` checks if two variables refer to the *exact same object* (`id()`); `==` checks if their *values are equal*.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [1, 2]\nb = [1, 2]\nc = a\nprint(a == b)  # True  (same value)\nprint(a is b)  # False (different objects)\nprint(a is c)  # True",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`True` is an instance of `<class 'bool'>`, which is a subclass of `<class 'int'>` with a value of `1`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(isinstance(True, int))   # True\nprint(True + True)             # 2\nprint(False * 10)              # 0",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`is` operator checks object identity (same memory address); `==` operator checks object value equality.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "`id(obj)` returns the unique memory address (identity) of an object, which never changes once created.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "An object's type (`type(obj)`) and identity are immutable properties once the object is created.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "Assignment `var2 = var1` makes both `var1` and `var2` reference the *same* object in memory.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-ab87bba39e",
          "exm-58c16c860b",
          "lec-8c4ac0f026",
          "lec-03d78ccf62",
          "nb-ebb2df2e4e",
          "nb-522899bb07",
          "leq-eb2764fa14"
        ]
      }
    },
    {
      "id": "topic-zip",
      "topic": "Zip",
      "canonical_topic": "zip",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "extra_practice": 1,
          "midterm_2023": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "dictionaries / zip / counting",
        "dictionary / zip",
        "enumerate",
        "enumerate()",
        "zip",
        "zip / enumerate",
        "zip / looping",
        "zip()"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) — second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          },
          {
            "id": "lec-bff7a8929a",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "zip()",
            "explanation": "Loops over multiple sequences in parallel. Zips sequences of equal length (Python handles unequal lengths but it can be messy). Can zip sequences of different types. Can zip more than 2.",
            "code_examples": [
              {
                "description": "zip two lists",
                "code": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(country, 'has capital:', capital)"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-ba031912fa",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 16,
            "week": 2,
            "topic": "zip / looping",
            "question": "What is the output of the following code?\n\nnames = ['Alice', 'Bob', 'Charlie']\nscores = [85, 92, 78]\nfor name, score in zip(names, scores):\n    print(f'{name}: {score}')",
            "code_context": "",
            "options": {
              "A": "Alice: 85\nBob: 92\nCharlie: 78",
              "B": "Alice: 92\nBob: 85\nCharlie: 78",
              "C": "Alice Bob Charlie: 85 92 78",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "zip pairs elements positionally. Output: Alice: 85, Bob: 92, Charlie: 78."
          },
          {
            "id": "exm-f6de891c85",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 5,
            "week": 2,
            "topic": "dictionaries / zip / counting",
            "question": "students = ['A','B','C','D','E','F']\ngrades = [9,10,9,11,10,9]\n\nYou need to create a dictionary called grade_counts that counts the number of students in each grade level.\n\nExpected: {9:3, 10:2, 11:1}\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "grade_counts = {}\nfor grade in grades:\n\tif grade not in grade_counts:\n\t\tgrade_counts[grade] = 0\n\tgrade_counts[grade] += 1",
              "b": "grade_counts = {}\nfor student, grade in zip(students, grades):\n\tif grade in grade_counts:\n\t\tgrade_counts[grade].append(student)\n\telse:\n\t\tgrade_counts[grade] = [student]",
              "c": "Both of the given options will work as intended.",
              "d": "Neither of the given options will work as intended."
            },
            "correct": "a",
            "explanation": "Option a correctly counts grades: initialises to 0 and increments. Produces {9:3, 10:2, 11:1}. Option b creates lists of student names, not counts — produces {9:['A','C','F'], 10:['B','E'], 11:['D']}, not the required format. Correct: a."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          },
          {
            "id": "nb-a88380d21a",
            "week": 2,
            "cell_index": 92,
            "cell_type": "code",
            "topic": "zip",
            "source": "countries = ['Andorra', 'Belgium']\ncapitals = ['Andorra la Vella', 'Brussels']\nfor country, capital in zip(countries, capitals):\n    print(f'country {country} has capital: {capital}')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `zip()` function combines multiple iterables (like lists or strings) into a single iterator of tuples. Each tuple contains elements from the input iterables at the same position. `zip()` stops when the shortest input iterable is exhausted, so be mindful of lists with unequal lengths in output questions."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How do you convert the result of `zip()` into a list or a dictionary?",
            "What is the data type of the object that `zip()` returns?",
            "What happens when you `zip` lists of different lengths?",
            "What is the output of `list(zip('hi', [1, 2, 3]))`?",
            "What will `dict(zip(keys, values))` produce?",
            "Can you `unzip` a list of tuples?",
            "Write a one-line expression to create a dictionary from a `keys` list and a `values` list.",
            "What is the value of the index and the item at each step of an `enumerate` loop?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Zipping Two Lists",
            "code": "students = ['Alice', 'Bob']\nscores = [88, 92]\ncombined = list(zip(students, scores))\nprint(combined)\n# Output: [('Alice', 88), ('Bob', 92)]",
            "why": "`zip` pairs the elements at each index from the input lists. `list()` is used to convert the zip object into a list for printing.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Creating a Dictionary with zip",
            "code": "keys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nd = dict(zip(keys, values))\nprint(d)\n# Output: {'a': 1, 'b': 2, 'c': 3}",
            "why": "A common and concise pattern is to use `zip` to create key-value pairs and pass the result directly to the `dict()` constructor.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Iterating over two lists in parallel with zip()",
            "code": "students = ['Alice', 'Bob', 'Charlie']\nscores = [88, 92, 78]\nfor student, score in zip(students, scores):\n    if score > 90:\n        print(f'{student} is a top student!')",
            "why": "This correctly pairs each student with their corresponding score from the other list, allowing the code to process them together within a single loop.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Zipping Unequal Length Lists",
            "code": "letters = ['A', 'B']\nnumbers = [1, 2, 3, 4]\nresult = list(zip(letters, numbers))\nprint(result)\n# Output: [('A', 1), ('B', 2)]",
            "why": "A common mistake is assuming `zip` will pad with `None` or raise an error. Instead, it stops as soon as the shortest iterable (in this case, `letters`) runs out of items.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Accessing Zip Object Directly",
            "code": "names = ['C', 'D']\nids = (10, 20)\nzipped = zip(names, ids)\nprint(zipped[0])\n# TypeError: 'zip' object is not subscriptable",
            "why": "`zip` returns an iterator, not a list or tuple. Iterators are designed to be used in loops and cannot be accessed by index. You must first convert it with `list(zipped)`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Forgetting to unpack the tuple",
            "code": "items = ['A', 'B', 'C']\n# Forgetting to unpack (i, item)\nfor data in enumerate(items):\n    print(f'Index: {data[0]}, Value: {data[1]}') # This works, but is clumsy\n\n# The wrong way to access:\n# print(f'Index: {i}, Value: {item}') # NameError",
            "why": "If you don't unpack the tuple from `enumerate` (or `zip`) in the `for` loop statement (e.g., `for i, item in ...`), the entire tuple `(index, value)` is assigned to a single variable. Forgetting this leads to `NameError",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "When zipping iterables of different lengths, `zip()` stops when the shortest iterable is exhausted.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`dict(zip(keys, values))` is a common pattern to create dictionaries from two lists.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Unzip a sequence of tuples using the `*` operator with `zip()`: `zip(*zipped_list)`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`zip()` returns an iterator; convert to `list()` or `dict()` to view contents.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`zip()` aggregates elements from multiple iterables into tuples.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`list(zip('hi', [1, 2, 3]))` produces `[('h', 1), ('i', 2)]`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "If `keys_list` contains duplicate keys, `dict(zip(...))` assigns the value from the *last* occurrence to that key.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`zip(*iterables)` aggregates elements from each iterable; it stops when the shortest iterable is exhausted.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`list(zip(list1, list2))` produces a list of tuples, each containing elements from corresponding positions.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "Using `dict(zip(...))` for dictionary creation is typically more concise and efficient than manual looping.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "names = ['Ana', 'Bo', 'Cy']\nscores = [8, 9]\nprint(list(zip(names, scores)))\n# [('Ana', 8), ('Bo', 9)]",
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-ba031912fa",
          "exm-f6de891c85",
          "lec-bff7a8929a",
          "lec-ca6bf752eb",
          "nb-a88380d21a",
          "nb-6d22b8d418",
          "nb-87216389d2"
        ]
      }
    },
    {
      "id": "topic-argument-double-keyword-kwarg-star",
      "topic": "*args / **kwargs",
      "canonical_topic": "argument double keyword kwarg star",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "midterm_2023": 1,
          "trial_midterm": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "*args / **kwargs",
        "Keyword arguments and **kwargs",
        "keyword args / **kwargs"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-521c0f3bef",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Keyword arguments and **kwargs",
            "explanation": "Arguments can be passed by name (keyword). **kwargs collects undefined keyword arguments into a dict. Order in function definition: positional, *args, keyword-with-defaults, **kwargs.",
            "code_examples": [
              {
                "description": "Keyword arguments",
                "code": "def calc(first, second, third, fourth, fifth, sixth):\n    return first + 2*second + 3*third + 4*fourth + 5*fifth + 6*sixth\nprint(calc(fifth=2, third=4, fourth=1, sixth=5, second=2, first=3))  # 63"
              },
              {
                "description": "**kwargs",
                "code": "def calc(**kwargs):\n    return kwargs['first'] + 2*kwargs['second'] + 3*kwargs['third']\nprint(calc(third=4, second=2, first=3))"
              },
              {
                "description": "Mixed: positional + *args + **kwargs",
                "code": "def calc(first, second, *args, **kwargs):\n    return first + second*2 + args[0]*3 + args[1]*4 + 5*kwargs['fifth'] + 6*kwargs['sixth']\nprint(calc(3, 2, 4, 1, sixth=5, fifth=2))  # 63"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-11949e2fb1",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 22,
            "week": 3,
            "topic": "keyword args / **kwargs",
            "question": "What is the output of the following code?\n\ndef greet(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\ngreet(name='Alice', age=30)",
            "code_context": "",
            "options": {
              "A": "name: Alice\nage: 30",
              "B": "Alice: name\n30: age",
              "C": "{'name': 'Alice', 'age': 30}",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "**kwargs collects keyword arguments as a dict. Iterating items() gives key-value pairs: name: Alice, age: 30."
          },
          {
            "id": "exm-fda16bbeb3",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 14,
            "week": 3,
            "topic": "*args / **kwargs",
            "question": "What is the output of the following code?\n\ndef func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\n\nfunc(1, 2, 3, 4, x=5, y=6)",
            "code_context": "",
            "options": {
              "A": "1 2 (3, 4) {'x': 5, 'y': 6}",
              "B": "1 2 [3, 4] {'x': 5, 'y': 6}",
              "C": "1 2 3 4 5 6",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "a=1, b=2, args=(3,4) as tuple, kwargs={'x':5,'y':6} as dict."
          }
        ],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "`*args` and `**kwargs` allow functions to accept a variable number of arguments. `*args` collects any extra positional arguments into a tuple, while `**kwargs` gathers any extra keyword arguments into a dictionary. In exam questions, focus on how arguments are distributed: positional arguments fill named parameters first, then `*args`, and all `key=value` arguments not matching a parameter name go into `**kwargs`.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type of the `args` variable inside the function?",
            "What is the data type of the `kwargs` variable inside the function?",
            "In what order must `a`, `*args`, `b=1`, and `**kwargs` appear in a function signature?",
            "How are arguments distributed with `def f(a, *args, **kwargs):`?",
            "Can a function be defined with `*args` but not `**kwargs`?",
            "What is a `SyntaxError` you might get when calling a function with keyword arguments?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Using *args and **kwargs",
            "code": "def f(a, b, *args, **kwargs):\n    print(f'a={a}, b={b}')\n    print(f'args={args}')\n    print(f'kwargs={kwargs}')\nf(1, 2, 3, 4, x=5, y=6)",
            "why": "The function correctly assigns 1 to `a`, 2 to `b`, collects the remaining positional arguments (3, 4) into the `args` tuple, and the keyword arguments into the `kwargs` dictionary.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Using only **kwargs",
            "code": "def process_data(**settings):\n    if settings.get('debug_mode'):\n        print('Debug is ON')\n    print(f'Processing file: {settings[\"file\"]}')\nprocess_data(file='data.csv', debug_mode=True)",
            "why": "`**kwargs` is useful for functions that handle flexible options. Arguments are passed by name and accessed like dictionary keys inside the function.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Invalid Argument Order",
            "code": "def my_func(a, **kwargs, *args):\n    pass\n# SyntaxError: invalid syntax",
            "why": "In a function definition, standard positional parameters must come first, followed by `*args`, and then `**kwargs` must be last. This order is not flexible.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Positional Argument After Keyword",
            "code": "def setup(port, host='localhost'):\n    print(f'Connecting to {host}:{port}')\n\nsetup(port=8080, 'example.com')\n# SyntaxError: positional argument follows keyword argument",
            "why": "When calling a function, all positional arguments must come before any keyword arguments. Once you use `key=value` syntax, you cannot switch back to providing arguments positionally.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`*args` collects non-keyword variable-length arguments into a `tuple`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(*args):\n    print(type(args).__name__, args)\n\nf(1, 2, 3)  # tuple (1, 2, 3)",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`**kwargs` collects keyword variable-length arguments into a `dict`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def g(**kwargs):\n    for k, v in kwargs.items():\n        print(k, v)\n\ng(name='Ana', score=10)",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Function parameter order: positional arguments, `*args`, keyword-only arguments with defaults, `**kwargs`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "`def f(a, *args, **kwargs):` `a` binds to the first positional, `*args` to remaining positionals, `**kwargs` to keyword arguments.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Parameter binding map",
                "text": "",
                "table": {
                  "headers": [
                    "Syntax part",
                    "Binds to"
                  ],
                  "rows": [
                    [
                      "`a`",
                      "First positional argument"
                    ],
                    [
                      "`*args`",
                      "Remaining positional arguments (tuple)"
                    ],
                    [
                      "`**kwargs`",
                      "Keyword arguments (dict)"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Passing an unexpected keyword argument to a function without `**kwargs` will raise a `TypeError`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "exm-11949e2fb1",
          "exm-fda16bbeb3",
          "lec-521c0f3bef"
        ]
      }
    },
    {
      "id": "topic-default-mutable",
      "topic": "mutable_default",
      "canonical_topic": "default mutable",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 2,
        "by_exam": {
          "midterm_2024": 1,
          "trial_midterm": 1
        },
        "coverage_count": 2
      },
      "related_topics": [
        "Mutable default argument",
        "default args / mutable defaults",
        "default arguments / mutable defaults",
        "mutable_default",
        "mutable_defaults"
      ],
      "trap_patterns": [
        {
          "pattern": "Mutable default argument",
          "trap": "def f(lst=[]): — the [] is created ONCE at def time and persists across calls. Fix: use None and create inside function",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "leq-a9a97c880c",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Mutable default argument",
            "question": "What is the result of:\ndef main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))\nprint(main(3))",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [
          {
            "id": "exm-72aaa9b4b7",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 13,
            "week": 3,
            "topic": "default arguments / mutable defaults",
            "question": "What is the output of the following code?\n\ndef add_item(item, lst=[]):\n    lst.append(item)\n    return lst\n\nprint(add_item(1))\nprint(add_item(2))\nprint(add_item(3))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[1, 2, 3]",
              "C": "[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "The default list [] is created once when the function is defined and shared across all calls. Each call appends to the same list."
          },
          {
            "id": "exm-d2e7fd42c3",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 16,
            "week": 3,
            "topic": "default args / mutable defaults",
            "question": "What is the output of the following code?\n\ndef func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))\nprint(func(3, []))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[3]",
              "C": "[1]\n[1, 2]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "func(1) and func(2) share the default list: [1] then [1,2]. func(3,[]) uses a fresh list: [3]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-6725133dff",
            "week": 3,
            "cell_index": 56,
            "cell_type": "code",
            "topic": "mutable_defaults",
            "source": "def main (addition, l1 = []):\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
            "outputs": []
          },
          {
            "id": "nb-d69134ce72",
            "week": 3,
            "cell_index": 57,
            "cell_type": "code",
            "topic": "mutable_defaults",
            "source": "def main (addition, l1 = None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))\nprint(main(3))",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "A function's default mutable argument (like a list or dict) is created only once when the function is defined, not each time it's called. This means subsequent calls that don't provide their own argument will modify the same, shared object, leading to unexpected results. In exam questions, track calls using the default; they will all append to or change the same object. The standard fix is to default to `None` and c…",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the output after multiple calls to a function with a default list argument?",
            "Why does a list in a default argument seem to remember items from previous calls?",
            "How do you correctly initialize an empty list as a default argument?",
            "What is the difference in behavior between `def f(a=[])` and `def f(a=None)`?",
            "If I call the function once with my own list, will it affect the default list for the next call?",
            "Predict the final state of the list after mixed calls (some with the default, some without)."
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Correct: Using `None` as Default",
            "code": "def add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nprint(add_item(1))\nprint(add_item(2))",
            "why": "This is the correct pattern. A new list is created inside the function whenever it's called without a specific list, preventing shared state between calls. Output is `[1]` then `[2]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Correct: Passing a New List Each Time",
            "code": "def add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1, []))\nprint(add_item(2, []))",
            "why": "This also works because the caller is explicitly creating and passing a new empty list `[]` for each call, thus avoiding the shared default argument.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Incorrect: The Classic Mutable Default Trap",
            "code": "def add_item(item, items=[]):\n    items.append(item)\n    return items\n\nlist1 = add_item('a')\nlist2 = add_item('b')\nprint(list2)",
            "why": "The second call `add_item('b')` modifies the *same* list object created when the function was defined. The programmer likely expected `['b']` but gets `['a', 'b']` because the list is shared.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Incorrect: Mixing Default and Provided Lists",
            "code": "def func(x, data=[]):\n    data.append(x)\n    return data\n\nprint(func(1))\nprint(func(2))\nprint(func(3, []))",
            "why": "The first two calls share the default list, so it grows to `[1, 2]`. The third call provides its own fresh list, so it returns `[3]`. A common mistake is thinking all calls modify the same list.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Mutable default arguments (e.g., `list`, `dict`) are created once at function definition and persist across calls.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Repeated calls to a function with a mutable default argument without providing an explicit value will modify the *same* object.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "To prevent mutable default argument issues, use `None` as the default and initialize the mutable object inside the function: `def func(arg=None): arg = arg if arg is not None else []`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Immutable default arguments (e.g., `str`, `int`, `tuple`, `None`) are safe as their values are copied or cannot be changed in place.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-4-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-72aaa9b4b7",
          "exm-d2e7fd42c3",
          "leq-a9a97c880c",
          "nb-6725133dff",
          "nb-d69134ce72"
        ]
      }
    },
    {
      "id": "topic-assignment-augmented",
      "topic": "Assignment",
      "canonical_topic": "assignment",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2024": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "Assignment statements — reading right to left",
        "Augmented assignment operators",
        "assignment",
        "augmented operators",
        "augmented_operators"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8f40fb5984",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Assignment statements — reading right to left",
            "explanation": "Python creates a new object with the value on the right, infers type from the value, then binds the name on the left to that object.",
            "code_examples": [
              {
                "description": "Basic assignment",
                "code": "name_1 = 300\nprint(name_1)        # 300\nprint(type(name_1))  # <class 'int'>\nprint(id(name_1))    # some unique integer"
              },
              {
                "description": "Two names bound to the same object (same id)",
                "code": "name_3 = name_4 = name_5 = name_6 = 300\nprint(name_3 is name_4 is name_5 is name_6)  # True"
              },
              {
                "description": "Two separate objects with equal value (different id)",
                "code": "name_1 = 300\nname_2 = 300\nprint(name_1 == name_2)           # True (same value)\nprint(id(name_1) != id(name_2))   # True (different objects)"
              }
            ]
          },
          {
            "id": "lec-18dd567530",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Augmented assignment operators",
            "explanation": "Shorthand for a = a OP b. All arithmetic operators have an augmented form.",
            "code_examples": [
              {
                "description": "All augmented operators",
                "code": "a += 1   # a = a + 1\na -= 2   # a = a - 2\na *= 3   # a = a * 3\na /= 4   # a = a / 4\na //= 5  # a = a // 5\na %= 6   # a = a % 6"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-970620e487",
            "exam_label": "midterm_2024",
            "exam_source": "2024.pdf",
            "year": "2023-2024",
            "number": 6,
            "week": 2,
            "topic": "augmented operators",
            "question": "What is the output of the following code?\n\nx = 10\nx //= 3\nprint(x)",
            "code_context": "",
            "options": {
              "A": "3",
              "B": "3.33",
              "C": "4",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "//= is floor division assignment. 10 // 3 = 3."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-1efd2c6579",
            "week": 1,
            "cell_index": 14,
            "cell_type": "code",
            "topic": "assignment",
            "source": "a = 100\nb = 200\nc = 300\nd, e, f = a, b, c\nprint(a, b, c)\nprint(d, e, f)",
            "outputs": []
          },
          {
            "id": "nb-3642142eff",
            "week": 1,
            "cell_index": 15,
            "cell_type": "code",
            "topic": "assignment",
            "source": "a = 100\nb = 200\nc = 300\nprint(a, b, c)\nb, c, a = a, b, c \nprint(a, b, c)",
            "outputs": []
          },
          {
            "id": "nb-49999b1411",
            "week": 2,
            "cell_index": 3,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 1 \na += 1\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-34ac437319",
            "week": 2,
            "cell_index": 4,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 1 \na = a + 1\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-c120563f18",
            "week": 2,
            "cell_index": 6,
            "cell_type": "code",
            "topic": "augmented_operators",
            "source": "a = 2\na -= 2\nprint(a)\n\na=3\na *= 3\nprint(a)\n\na = 5\na /= 4\nprint(a)\n\na = 6\na //= 5\nprint(a)\n\na = 7\na %= 6\nprint(a)\n\na = 8\na **= 7\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Augmented assignment operators like `+=`, `-=`, `*=`, `//=`, and `%=` are shortcuts for performing an operation and assignment in one step. For example, `x //= 3` is equivalent to `x = x // 3`. For exam questions, pay close attention to the specific operator, especially the difference between true division (`/=`), which produces a float, and floor division (`//=`), which produces an integer."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Predict the output of a sequence of different augmented assignments.",
            "What happens when you use `*=` on a string (e.g., `s *= 3`)?",
            "Rewrite `a = a % b` using an augmented assignment operator.",
            "What is the difference between `x /= 2` and `x //= 2`?",
            "Does `+=` work on strings and lists? If so, how?",
            "What is the final value of `x` after `x //= 3`?",
            "What are the values of `a`, `b`, and `c` after a tuple assignment or swap?",
            "What is the final value of a variable after a series of reassignments?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Correct: Floor Division Assignment `//=`",
            "code": "x = 10\nx //= 3\nprint(x)",
            "why": "`x //= 3` is shorthand for `x = x // 3`. The floor division of `10` by `3` is `3`, so `x` becomes `3`. The remainder is discarded.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Tuple Swap",
            "code": "a = 100\nb = 200\na, b = b, a\nprint(a, b)",
            "why": "This correctly swaps the values. Python evaluates the right side `(b, a)` to create a temporary tuple `(200, 100)` and then unpacks it into the names `a` and `b` on the left. The output is 200 100.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Correct: Modulo Assignment `%=`",
            "code": "x = 10\nx %= 3\nprint(x)",
            "why": "`x %= 3` is shorthand for `x = x % 3`. The remainder when `10` is divided by `3` is `1`, so `x` becomes `1`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Incorrect: Operator Precedence",
            "code": "x = 2\nx *= 3 + 1\nprint(x)",
            "why": "This is equivalent to `x = x * (3 + 1)`. The expression on the right is fully evaluated first (`3 + 1` becomes `4`), then the multiplication occurs (`2 * 4`). A mistake is to calculate `2*3` first, yielding an incorrect",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Incorrect: Confusing `/=` and `//=`",
            "code": "x = 5\nx /= 2\nprint(x)",
            "why": "A common mistake is forgetting that the true division operator `/` (and `/=`) always results in a float. The code prints `2.5`, not `2`. To get an integer result, `x //= 2` should be used.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Tuple Unpacking Mismatch",
            "code": "a, b = 10, 20, 30\nprint(a, b)",
            "why": "This code will raise a `ValueError`. The right side produces three values, but the left side only provides two names to unpack them into. The number of names must match the number of values.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Augmented assignment (e.g., `a += b`) evaluates the left-hand side once and may mutate in-place, so it can differ from `a = a + b`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Optional code example",
                "code": "lst = [1, 2]\nalias = lst\nlst += [3]\nprint(alias)  # [1, 2, 3] (in-place)\n\nlst = [1, 2]\nalias = lst\nlst = lst + [3]\nprint(alias)  # [1, 2] (new object assigned)",
                "text": ""
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`*=` on strings repeats (`s = s * n`); on lists, it repeats the list (`lst = lst * n`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'ab'\ns *= 3\nprint(s)        # 'ababab'\nlst = [1, 2]\nlst *= 2\nprint(lst)      # [1, 2, 1, 2]",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`+=` on strings concatenates (`s = s + other_s`); on lists, it extends (`lst.extend(other_lst)`).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-4",
            "text": "`x /= y` performs true division (e.g., `x = x / y`), always yielding a float result.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "`x //= y` performs floor division (e.g., `x = x // y`), yielding an integer result.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "Python assignment `name = value`: Creates value object on the right, infers type, then binds name on the left to that object.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Assignment binds a name to an object; it does not copy object contents unless an explicit copy operation is used.",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "Multiple assignment `a = b = c = value`: All names (`a`, `b`, `c`) bind to the *same* object in memory for immutable types.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Mutable vs immutable",
                "text": "",
                "table": {
                  "headers": [
                    "Category",
                    "Examples",
                    "Can change in place?"
                  ],
                  "rows": [
                    [
                      "Mutable",
                      "`list`, `dict`, `set`",
                      "Yes"
                    ],
                    [
                      "Immutable",
                      "`int`, `str`, `tuple`, `bool`",
                      "No"
                    ]
                  ]
                },
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Tuple assignment `d, e, f = x, y, z`: Assigns elements from the iterable on the right to corresponding names on the left.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x, y, z = (10, 20, 30)\nprint(x, y, z)\n\na, b = b, a   # swap values",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "`is` operator checks if two variables refer to the exact same object in memory (compares `id()` values).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "Tuple swap `a, b = b, a`: Simultaneously exchanges values by internally creating a temporary tuple.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-970620e487",
          "lec-18dd567530",
          "lec-8f40fb5984",
          "nb-49999b1411",
          "nb-c120563f18",
          "nb-1efd2c6579",
          "nb-3642142eff"
        ]
      }
    },
    {
      "id": "topic-loop-range",
      "topic": "Range()",
      "canonical_topic": "range()",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "trial_midterm": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "For-loops",
        "for loops / range",
        "for_loop / range",
        "for_loops",
        "range()"
      ],
      "trap_patterns": [
        {
          "pattern": "range() and slicing both exclusive at stop",
          "trap": "range(1,10,3)→[1,4,7] not including 10; l[2:7] goes up to but not including index 7",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "trial_midterm",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-e8f2474ca1",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "range()",
            "explanation": "range(start, stop, step). start default=0, step default=1. Stop is NOT inclusive. Works like slicing but defaults differ slightly.",
            "code_examples": [
              {
                "description": "range examples",
                "code": "print(list(range(6)))      # [0, 1, 2, 3, 4, 5]\nprint(list(range(3,6)))    # [3, 4, 5]\nprint(list(range(3,6,2)))  # [3, 5]"
              }
            ]
          },
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used — use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-7b51257c98",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 9,
            "week": 2,
            "topic": "for loops / range",
            "question": "What is the output of the following code?\n\nresult = 0\nfor i in range(1, 6):\n    result += i\nprint(result)",
            "code_context": "",
            "options": {
              "A": "10",
              "B": "15",
              "C": "21",
              "D": "6"
            },
            "correct": "B",
            "explanation": "range(1,6) gives 1,2,3,4,5. Sum = 15."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `range()` function generates a sequence of numbers, which is an iterable but not a list. It takes `range(start, stop, step)`. The most important rule to remember is that the sequence goes *up to* but does not include the `stop` value. In exam questions, always trace the starting number, the end condition (is it inclusive or exclusive?), and the increment value."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the value of the loop variable `i` *after* a loop `for i in range(3):` finishes?",
            "How do you sum the numbers from 1 to 100 using a `for` loop and `range()`?",
            "What will be the final value of a variable accumulated in a `for` loop?",
            "What is the difference between `break` and `continue` inside a loop?",
            "What are the default values for `start` and `step` in `range()`?",
            "How can you iterate backward from 5 down to 1 using `range()`?",
            "How do you create a sequence of even numbers from 2 to 10?",
            "What is the output of `list(range(10, 0, -2))`?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Looping with `continue` to Skip Iterations",
            "code": "total = 0\nfor i in range(1, 8):\n  if i % 2 == 0: # If i is even\n    continue\n  total += i\nprint(total) # 16",
            "why": "Correct. When `i` is even, `continue` immediately skips to the next iteration, so `total += i` is only executed for odd numbers (1, 3, 5, 7).",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Summing Numbers in a `range`",
            "code": "total = 0\nfor i in range(1, 6):\n  total += i\nprint(total)",
            "why": "Correct. The loop iterates with `i` as 1, 2, 3, 4, and 5. The `total` variable accumulates these values, resulting in `1+2+3+4+5 = 15`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Basic `range` with Start and Stop",
            "code": "nums = []\nfor i in range(1, 4):\n  nums.append(i)\nprint(nums)",
            "why": "This is correct. The range starts at 1 and stops *before* 4, producing the numbers 1, 2, and 3, which are appended to the list.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Incorrectly Modifying the Loop Variable",
            "code": "total = 0\nfor i in range(3): # i will be 0, 1, 2\n  i += 5 # This does not affect the loop's next value\n  total += i\n# Iteration 1: i=0, i becomes 5, total=5\n# Iteration 2: i=1, i becomes 6, total=11\n# Iteration 3: i=2, i becomes 7, total=18",
            "why": "A common trap. Modifying the loop variable `i` inside the loop does not affect the sequence generated by `range()`. On the next iteration, `i` will be assigned the next value from `range`, ignoring the `i += 5` change f",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Wrong Step for Backward Counting",
            "code": "# Goal: count down from 3 to 1\nfor i in range(3, 1):\n  print(i) # Prints nothing",
            "why": "This is incorrect. The default step is `+1`. To count down, a negative step is required. Since the start (3) is already past the stop (1) with a positive step, the range is empty. Use `range(3, 0, -1)`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Off-by-One Error: Including `stop` Value",
            "code": "# Goal: get numbers 1, 2, 3, 4\nnums = list(range(1, 4))\nprint(nums) # Output: [1, 2, 3]",
            "why": "This is a classic off-by-one error. A common mistake is forgetting that `range(start, stop)` does not include the `stop` value. To get numbers up to 4, one must use `range(1, 5)`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`range()` returns a lazy sequence object (iterable), not a list; use `list(range(...))` when you need materialized values.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "id": "kp-1-d1",
                "kind": "example",
                "title": "Optional code example",
                "code": "r = range(3)\nprint(r)       # range(0, 3)\nprint(list(r)) # [0, 1, 2]",
                "text": ""
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `_` as a loop variable name (e.g., `for _ in range(N):`) when the variable's value is not needed inside the loop body.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "for _ in range(3):\n    print('repeat')",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`continue` skips the current iteration's remaining code and proceeds to the next iteration of the loop.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-4",
            "text": "`for variable in sequence:` iterates, assigning each sequence element to `variable` per iteration.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "After a `for` loop completes, the loop variable retains the value of the last element processed.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "Create a decreasing sequence with a negative `step` (e.g., `range(5, 0, -1)` for 5 down to 1).",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-7",
            "text": "Default `start` for `range()` is 0, and default `step` is 1; `range(n)` is `range(0, n, 1)`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-8",
            "text": "`range(start, stop, step)` generates numbers up to, but *not including*, the `stop` value.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "`for i in range(N):` will execute `N` times, with `i` taking values from `0` to `N-1`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "`break` immediately terminates the innermost `for` or `while` loop.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-7b51257c98",
          "lec-e8f2474ca1",
          "lec-1a2667a070",
          "nb-0e6e871095",
          "nb-bde305d2c2"
        ]
      }
    },
    {
      "id": "topic-string",
      "topic": "Strings",
      "canonical_topic": "string",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2023": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "enumerate",
        "enumerate / dict / string_ops",
        "enumerate()",
        "string indexing",
        "string_methods",
        "strings",
        "strings_escape",
        "strings_fstrings",
        "strings_quotes"
      ],
      "trap_patterns": [
        {
          "pattern": "str.upper() / string methods don't modify in place",
          "trap": "s.upper() returns a new string; s is unchanged. Must do s = s.upper()",
          "weeks": [
            1
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2023"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-ca6bf752eb",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "enumerate()",
            "explanation": "Provides index alongside value when looping. enumerate(seq, start) — second arg sets the start index (default 0).",
            "code_examples": [
              {
                "description": "enumerate with start=1",
                "code": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(country, 'has index:', index)\n# Andorra has index: 1\n# Belgium has index: 2"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-14f703ef57",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 4,
            "week": 1,
            "topic": "string indexing",
            "question": "What is the output of the following code?\n\ns = 'Python'\nprint(s[1:4])",
            "code_context": "",
            "options": {
              "A": "Pyt",
              "B": "yth",
              "C": "ytho",
              "D": "ython"
            },
            "correct": "B",
            "explanation": "s[1:4] gives characters at indices 1, 2, 3: 'y', 't', 'h' = 'yth'."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-9ccea86971",
            "week": 1,
            "cell_index": 70,
            "cell_type": "code",
            "topic": "strings",
            "source": "print(\"This is a string\")\nprint('This is another string')",
            "outputs": []
          },
          {
            "id": "nb-fac92dad98",
            "week": 1,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"",
            "outputs": []
          },
          {
            "id": "nb-2dd9891d55",
            "week": 1,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a)\nprint(b)\nprint(a,b)",
            "outputs": []
          },
          {
            "id": "nb-046b3572aa",
            "week": 1,
            "cell_index": 83,
            "cell_type": "code",
            "topic": "strings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(a + b)\nprint(\"First string: '\" + a + \"', Second string: '\" + b + \"'.\")",
            "outputs": []
          },
          {
            "id": "nb-ecaef89c57",
            "week": 1,
            "cell_index": 85,
            "cell_type": "code",
            "topic": "strings_fstrings",
            "source": "a = 'This is a string'      \nb = \"This is another string\"\nprint(f\"First string: '{a}', Second string: '{b}'.\")\nprint(\"First string: '{a}', Second string: '{b}'.\")",
            "outputs": []
          },
          {
            "id": "nb-8d7baf62a3",
            "week": 1,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "strings_quotes",
            "source": "print('This gives an error\")\nprint(\"This gives an error')",
            "outputs": []
          },
          {
            "id": "nb-7fcad85f68",
            "week": 1,
            "cell_index": 91,
            "cell_type": "code",
            "topic": "strings_quotes",
            "source": "print(\"This gives no ' error\")\nprint('This gives no \" error')",
            "outputs": []
          },
          {
            "id": "nb-eefca863f9",
            "week": 1,
            "cell_index": 93,
            "cell_type": "code",
            "topic": "strings_escape",
            "source": "print('This gives no \\' error')\nprint(\"This gives no \\\" error\")",
            "outputs": []
          },
          {
            "id": "nb-6d22b8d418",
            "week": 2,
            "cell_index": 89,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nfor index, country in enumerate(countries, 1):\n    print(f'{country} has index: {index}')",
            "outputs": []
          },
          {
            "id": "nb-87216389d2",
            "week": 2,
            "cell_index": 90,
            "cell_type": "code",
            "topic": "enumerate",
            "source": "countries = ['Andorra', 'Belgium']\nindex = 1\nfor country in countries:\n    print(f'{country} has index: {index}')\n    index += 1",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Strings are immutable sequences of characters in Python. This means they cannot be changed in-place; methods like `.upper()` or `.replace()` always return a *new* string, leaving the original untouched. You can access parts of a string using indexing `s[i]` and slicing `s[i:j]`, which works just like list slicing and is a frequent topic for 'what is the output' questions."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How do you correctly update a string to its uppercase version?",
            "What is the output of `s[1:4]` for the string 'Python'?",
            "What does `s.upper()` do to the original string `s`?",
            "What error occurs if you try `my_string[0] = 'a'`?",
            "How do you get the last character of a string?",
            "Are strings mutable or immutable?",
            "Write a loop to print each character of a string on a new line with its position.",
            "Can you change a character in a string like `my_str[0] = 'a'`? (No)"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Enumerate with Custom Start (1)",
            "code": "letters = ['a', 'b', 'c']\nfor i, val in enumerate(letters, 1):\n    print(f'Position {i} is {val}')\n# Output: Position 1 is a, Position 2 is b, etc.",
            "why": "The optional second argument to `enumerate` sets the starting value for the index. Here it is set to 1, which is useful for human-readable numbering.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Correctly Updating a String with a Method",
            "code": "s1 = 'hello'\ns1 = s1.upper()\nprint(s1)",
            "why": "This is the correct way to 'change' a string. The `.upper()` method returns a new string 'HELLO', which is then reassigned back to the variable `s1`.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Enumerate with Default Start (0)",
            "code": "letters = ['a', 'b', 'c']\nfor index, value in enumerate(letters):\n    print(f'Index {index}: {value}')\n# Output: Index 0: a, Index 1: b, Index 2: c",
            "why": "By default, `enumerate` starts counting from 0, pairing each index with its corresponding value from the list during iteration.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Calling a String Method Without Re-assignment",
            "code": "my_str = 'test'\nmy_str.replace('t', 'b')\nprint(my_str)",
            "why": "A very common mistake. The `replace()` method returns a new string 'besb', but the code does not do anything with the returned value. The original string in `my_str` is unchanged and thus 'test' is printed.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Attempting to Modify a String In-Place",
            "code": "s = 'Python'\ntry:\n  s[0] = 'J'\nexcept TypeError as e:\n  print(e)",
            "why": "This is a fundamental error that causes a `TypeError`. Strings are immutable, so you cannot change a part of a string by assigning to an index. You must create a new string, e.g., `s = 'J' + s[1:]`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Forgetting to Unpack Enumerate Tuples",
            "code": "letters = ['a', 'b']\nfor item in enumerate(letters):\n    # 'item' is a tuple, e.g., (0, 'a')\n    print(f'Letter: {item[0]}')\n# Output: Letter: 0, Letter: 1",
            "why": "`enumerate` yields tuples `(index, value)`. This code iterates correctly but prints the index (`item[0]`) instead of the value (`item[1]`), a common mistake when not unpacking.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Strings are immutable: operations like `s.upper()` return a new string, `s` remains unchanged.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'uva'\ns.upper()          # ignored result\nprint(s)           # 'uva'\ns = s.upper()\nprint(s)           # 'UVA'",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "String slicing `s[start:end]` extracts characters from `start` up to (but not including) `end`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-3",
            "text": "Assign results of string methods to update the variable: `s = s.upper()`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "s = 'uva'\ns.upper()          # ignored result\nprint(s)           # 'uva'\ns = s.upper()\nprint(s)           # 'UVA'",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Attempting to modify a string directly (e.g., `s[0] = 'a'`) raises a `TypeError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-5",
            "text": "Negative indices access characters from the end: `s[-1]` is the last character.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-6",
            "text": "`enumerate()` returns an iterator; convert to a `list` to inspect its contents, e.g., `list(enumerate('hi'))` yields `[(0, 'h'), (1, 'i')]`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`enumerate(iterable)` produces `(index, value)` pairs, with `index` starting at 0 by default.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-7-d1"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "Strings are immutable; direct assignment to characters like `my_str[0] = 'a'` raises a `TypeError`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-9",
            "text": "Use `enumerate(iterable, start=N)` to set the initial index value to `N`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "items = ['a', 'b']\nfor i, v in enumerate(items, start=1):\n    print(i, v)\n# 1 a\n# 2 b",
                "id": "kp-9-d1"
              }
            ]
          },
          {
            "id": "kp-10",
            "text": "String concatenation uses `+`; f-strings offer flexible embedded expression evaluation.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          }
        ],
        "recommended_ids": [
          "exm-14f703ef57",
          "lec-ca6bf752eb",
          "nb-046b3572aa",
          "nb-ecaef89c57",
          "nb-8d7baf62a3",
          "nb-6d22b8d418",
          "nb-87216389d2"
        ]
      }
    },
    {
      "id": "topic-average-dict",
      "topic": "dict / average",
      "canonical_topic": "average dict",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "extra_practice": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "dict / average",
        "dictionaries / average"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [],
        "exam_questions": [
          {
            "id": "exm-d0901c699d",
            "exam_label": "extra_practice",
            "exam_source": "Midterm Extra Practice.txt",
            "year": "unknown",
            "number": 4,
            "week": 2,
            "topic": "dictionaries / average",
            "question": "math_scores = {'John': 85, 'Sarah': 92, 'Michael': 78, 'Emma': 90, 'David': 82}\n\nYou want to find and print the names of the students who scored above the average score.\n\nWhich of the following code segments will work as intended?",
            "code_context": "",
            "options": {
              "a": "average_score = sum(math_scores.values())/len(math_scores)\n\tfor student in math_scores.keys():\n\t\tif math_scores[student] > average_score:\n\t\t\tprint(student)",
              "b": "for student in math_scores:\n\tif math_scores[student] > (sum(math_scores.values())/len(math_scores)):\n\t\tprint(student)",
              "c": "Both code segments will work as intended.",
              "d": "Neither code segment will work as intended."
            },
            "correct": "b",
            "explanation": "Option a has an indentation error (the for loop is indented under the average_score line as if it's a block, but there's no colon). This causes an IndentationError. Option b works correctly. Actually option a depends on whether the indentation shown is a tab after a plain statement — in Python that's an IndentationError. So only b works. Correct: b."
          }
        ],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "To find the average of dictionary values, first get all values using `.values()`, sum them with `sum()`, and divide by the number of items using `len()`. This gives you the average. A common follow-up task is to iterate through the dictionary's `.items()` to find which keys have values that are above or below this calculated average.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How do you get only the values from a dictionary?",
            "How do you calculate the sum of all values in a dictionary?",
            "How do you find the number of key-value pairs in a dictionary?",
            "Write the code to find keys whose values are greater than the average value.",
            "What is the difference between `d.keys()`, `d.values()`, and `d.items()`?",
            "What happens if you try to average a dictionary with non-numeric values?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Calculating Average of Dictionary Values",
            "code": "scores = {'A': 80, 'B': 90, 'C': 100}\nvals = scores.values()\navg = sum(vals) / len(vals)\nprint(avg)",
            "why": "Correct. `scores.values()` provides the numbers (80, 90, 100), `sum()` adds them to 270, and `len()` gets the count of 3. The average is 270 / 3 = 90.0.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Finding Keys with Above-Average Values",
            "code": "scores = {'A': 80, 'B': 90, 'C': 100}\navg = sum(scores.values()) / len(scores)\nabove_avg = []\nfor name, score in scores.items():\n  if score > avg:\n    above_avg.append(name)\nprint(above_avg)",
            "why": "Correct. First, the average (90.0) is calculated. Then, the loop checks each person's score. Only 'C' has a score (100) greater than 90, so it's added to the list.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Averaging Keys Instead of Values",
            "code": "scores = {'A': 80, 'B': 90}\ntry:\n  # This will fail because keys are strings\n  avg = sum(scores.keys()) / len(scores)\nexcept TypeError as e:\n  print(e)",
            "why": "This is incorrect and raises a `TypeError`. The `sum()` function cannot add the keys ('A', 'B') because they are strings. You must sum the values using `scores.values()`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Incorrectly Looping over Dictionary",
            "code": "scores = {'A': 80, 'B': 90, 'C': 100}\ntotal = 0\n# Looping over `scores` gets the keys by default\nfor key in scores:\n  total += 1 # Mistake: adds 1 instead of value\navg = total / len(scores)\nprint(avg) # Prints 1.0",
            "why": "This is a logic error. The loop correctly iterates three times, but `total += 1` increments the total by 1 each time instead of adding the score. The correct way to get the value is `scores[key]`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Access dictionary values using `dict.values()` for iteration or sum calculation.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Determine the number of key-value pairs in a dictionary with `len(dict)`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "Calculate the average of numeric dictionary values as `sum(dict.values()) / len(dict)`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Iterate `dict.items()` to access both keys and values as tuples: `for key, value in dict.items():`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Filter dictionary items by iterating through `dict.items()` and applying a condition to the `value`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Dict iteration targets",
                "text": "",
                "table": {
                  "headers": [
                    "Form",
                    "Yields"
                  ],
                  "rows": [
                    [
                      "`for k in d` / `d.keys()`",
                      "Keys"
                    ],
                    [
                      "`d.values()`",
                      "Values"
                    ],
                    [
                      "`d.items()`",
                      "`(key, value)` pairs"
                    ]
                  ]
                },
                "id": "kp-5-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-d0901c699d"
        ]
      }
    },
    {
      "id": "topic-list-loop",
      "topic": "Lists",
      "canonical_topic": "list",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "midterm_2023": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "For-loops",
        "for_loop / list",
        "for_loops",
        "list_operations",
        "lists",
        "set / list / uniqueness",
        "set / list operations"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-1a2667a070",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "For-loops",
            "explanation": "for variable in sequence: expression. break: exit loop entirely. continue: skip to next iteration. You don't have to use the loop variable; use _ as convention when not needed.",
            "code_examples": [
              {
                "description": "For-loop with continue",
                "code": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint(total)  # 18"
              },
              {
                "description": "Loop variable not used — use _",
                "code": "for _ in range(5):\n    print('Hello')  # prints Hello 5 times"
              }
            ]
          }
        ],
        "exam_questions": [
          {
            "id": "exm-989ce43b0f",
            "exam_label": "midterm_2023",
            "exam_source": "2023.pdf",
            "year": "2022-2023",
            "number": 6,
            "week": 2,
            "topic": "lists",
            "question": "What is the output of the following code?\n\nlst = [1, 2, 3]\nlst2 = lst[:]\nlst2.append(4)\nprint(lst)\nprint(lst2)",
            "code_context": "",
            "options": {
              "A": "[1, 2, 3]\n[1, 2, 3, 4]",
              "B": "[1, 2, 3, 4]\n[1, 2, 3, 4]",
              "C": "[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "A",
            "explanation": "lst[:] creates a shallow copy. Modifying lst2 does not affect lst. lst stays [1,2,3], lst2 becomes [1,2,3,4]."
          }
        ],
        "notebook_snippets": [
          {
            "id": "nb-de37856825",
            "week": 2,
            "cell_index": 41,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = []\nprint(squares)\nsquares = list()\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-d2f4ffb243",
            "week": 2,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-959f6e1a09",
            "week": 2,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [4, 16]\nsquares = squares[:1] + [9] + squares[1:]  \nsquares.append(25)\nsquares += [36]\nsquares.insert(0, 1)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9b6dd0d742",
            "week": 2,
            "cell_index": 44,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 5, 9, 16]\ndel(squares[2])\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-001226386b",
            "week": 2,
            "cell_index": 45,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 8, 15]\nsquares[2] = 9\nsquares[3] = 16\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-80c6871326",
            "week": 2,
            "cell_index": 47,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nsquares.append(16)\nsquares.append(25)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-496d4b7476",
            "week": 2,
            "cell_index": 48,
            "cell_type": "code",
            "topic": "lists",
            "source": "if 16 not in squares:\n    squares.append(16)\nif 25 not in squares:\n    squares.append(25)    \nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-b93f963478",
            "week": 2,
            "cell_index": 50,
            "cell_type": "code",
            "topic": "lists",
            "source": "squares = [1, 4, 9, 16]\nsquares = set(squares)\nsquares.add(16)\nsquares.add(25)\nsquares = list(squares)\nprint(squares)",
            "outputs": []
          },
          {
            "id": "nb-9dd5136770",
            "week": 2,
            "cell_index": 79,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, 3, 3, 5, 7]:\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-0e6e871095",
            "week": 2,
            "cell_index": 80,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "total = 0\nfor number in [1, 2, '3', 3, 5, 7]:\n    if type(number) == str:\n        continue\n    total += number\nprint (total)",
            "outputs": []
          },
          {
            "id": "nb-8d5e0290b4",
            "week": 2,
            "cell_index": 81,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for number in range(5):\n    print ('Hello')",
            "outputs": []
          },
          {
            "id": "nb-bde305d2c2",
            "week": 2,
            "cell_index": 82,
            "cell_type": "code",
            "topic": "for_loops",
            "source": "for _ in range(5):\n    print ('Hello')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "List operations either modify a list 'in-place' or return a new, modified list. The most critical distinction to track for exams is whether the original list variable is changed or not. For example, `my_list.sort()` modifies the list and returns `None`, while `sorted(my_list)` leaves the original list untouched and returns a new, sorted list."
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What happens if you assign the result of an in-place method to a variable (e.g., `x = my_list.sort()`)?",
            "Will converting a list to a set and back to a list maintain the original order?",
            "What's the most efficient way to check if a list contains any duplicate values?",
            "Does the operation change the original list (`in-place`) or return a new one?",
            "How do you correctly create a copy of a list vs. just a new reference to it?",
            "What happens if you try to create a set from a list containing other lists?",
            "What is printed if the print statement is inside versus outside the loop?",
            "What is the difference between `list.sort()` and the `sorted()` function?"
          ]
        },
        "ai_examples": [
          {
            "id": "ai-example-correct-1",
            "kind": "correct",
            "title": "Skipping Non-Integers with `continue`",
            "code": "total = 0\ndata = [1, 5, 'skip', 10]\nfor item in data:\n    if not isinstance(item, int):\n        continue\n    total += item\nprint(total)",
            "why": "Demonstrates using `continue` to control flow. When the `if` condition is met (the item is not an integer), `continue` immediately starts the next iteration, skipping the `total += item` line.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-2",
            "kind": "correct",
            "title": "Fastest Way to Check for Duplicates",
            "code": "items = [1, 2, 3, 4, 2]\nhas_duplicates = len(items) != len(set(items))\nprint(f\"Has duplicates: {has_duplicates}\")",
            "why": "This is a concise and highly efficient way to determine if a list has duplicates. If the lengths are different, it means the set creation removed at least one duplicate item.",
            "status": "generated"
          },
          {
            "id": "ai-example-correct-3",
            "kind": "correct",
            "title": "Getting a List of Unique Items",
            "code": "data = ['a', 'b', 'a', 'c', 'c', 'a']\nunique_items = list(set(data))\n# Note: order is not guaranteed\nprint(unique_items)",
            "why": "This is the primary pattern for deduplication. A `set` is created from the list, automatically discarding duplicates, and then converted back to a `list`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-4",
            "kind": "incorrect",
            "title": "Modifying a List While Iterating",
            "code": "numbers = [1, 2, 3]\nfor num in numbers:\n    if num == 2:\n        numbers.append(4) # Bad practice!\nprint(numbers)",
            "why": "This is a common mistake that leads to unexpected behavior. Modifying the list you are looping over can sometimes cause an infinite loop or other logical errors. Here, the loop will now also run for the newly added `4`.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-5",
            "kind": "incorrect",
            "title": "Assuming Order is Preserved",
            "code": "ordered_data = [10, 2, 5, 2]\nsupposedly_ordered = list(set(ordered_data))\n# This will likely not be [10, 2, 5]\nprint(supposedly_ordered)",
            "why": "A common trap. Sets are inherently unordered collections. When you convert a list to a set and back, the final list's element order is arbitrary and should not be relied upon.",
            "status": "generated"
          },
          {
            "id": "ai-example-incorrect-6",
            "kind": "incorrect",
            "title": "Assignment Creates a Reference, Not a Copy",
            "code": "list1 = [1, 2, 3]\nlist2 = list1 # This is NOT a copy\nlist2.append(4)\nprint(f\"List 1: {list1}\")",
            "why": "A classic mistake. `list2 = list1` makes both variables point to the exact same list object in memory. Modifying one will affect the other. `list1` will be `[1, 2, 3, 4]`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "List slicing `lst[:]` creates a shallow copy; changes to the new list do not affect the original, unlike direct assignment `new_lst = old_lst`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [[1], [2]]\nb = a[:]         # shallow copy\nb[0].append(9)\nprint(a)         # [[1, 9], [2]] (inner list shared)",
                "id": "kp-1-d1"
              },
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `copy.deepcopy(...)` when nested mutable objects must be fully independent.",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`set.add(element)` adds an element; `set.remove(element)` removes an element and raises `KeyError` if not found; `set.discard(element)` removes without error.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Set remove behavior",
                "text": "",
                "table": {
                  "headers": [
                    "Method",
                    "If element missing"
                  ],
                  "rows": [
                    [
                      "`remove(x)`",
                      "Raises `KeyError`"
                    ],
                    [
                      "`discard(x)`",
                      "No error"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Use `list(set(my_list))` to remove duplicate elements from a list; this process does not guarantee the original order of elements.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "If order matters, use `list(dict.fromkeys(my_list))` to remove duplicates while preserving first appearance order.",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "List slicing `lst[:]` creates a shallow copy, preventing original list modification when the copy is changed.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [[1], [2]]\nb = a[:]         # shallow copy\nb[0].append(9)\nprint(a)         # [[1, 9], [2]] (inner list shared)",
                "id": "kp-4-d1"
              },
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `copy.deepcopy(...)` when nested mutable objects must be fully independent.",
                "id": "kp-4-d2"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`list.append(item)` adds an element to the end of the list; `list.insert(index, item)` adds an element at a specific index.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "lst = [1, 3]\nlst.append(4)      # [1, 3, 4]\nlst.insert(1, 2)   # [1, 2, 3, 4]",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "Sets do not maintain element order; converting `list` to `set` and back to `list` will not preserve original order.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `dict.fromkeys(lst)` or an ordered loop if uniqueness plus order must be preserved.",
                "id": "kp-6-d1"
              }
            ]
          },
          {
            "id": "kp-7",
            "text": "`lst[:]` creates a shallow copy; `lst2 = lst` creates a new reference to the same list.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "a = [[1], [2]]\nb = a[:]         # shallow copy\nb[0].append(9)\nprint(a)         # [[1, 9], [2]] (inner list shared)",
                "id": "kp-7-d1"
              },
              {
                "kind": "explanation",
                "title": "Optional note",
                "text": "Use `copy.deepcopy(...)` when nested mutable objects must be fully independent.",
                "id": "kp-7-d2"
              }
            ]
          },
          {
            "id": "kp-8",
            "text": "`list[index] = value` assigns a new value to an element at a specific index, modifying the list in-place.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "lst = ['a', 'b', 'c']\nlst[1] = 'B'\nprint(lst)    # ['a', 'B', 'c']",
                "id": "kp-8-d1"
              }
            ]
          },
          {
            "id": "kp-9",
            "text": "List methods like `append()`, `insert()`, `extend()`, `sort()`, and `pop()` modify the list in-place and return `None`.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge"
          },
          {
            "id": "kp-10",
            "text": "`break` terminates the current loop entirely; `continue` skips the rest of the current iteration.",
            "status": "generated",
            "model": "manual-curation",
            "generator": "duplicate-merge",
            "details": [
              {
                "kind": "table",
                "title": "Loop control quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`break`",
                      "Exit current loop immediately"
                    ],
                    [
                      "`continue`",
                      "Skip rest of current iteration"
                    ],
                    [
                      "`pass`",
                      "Do nothing (placeholder statement)"
                    ]
                  ]
                },
                "id": "kp-10-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-989ce43b0f",
          "lec-1a2667a070",
          "nb-959f6e1a09",
          "nb-496d4b7476",
          "nb-b93f963478",
          "nb-9b6dd0d742",
          "nb-de37856825",
          "nb-001226386b",
          "nb-80c6871326"
        ]
      }
    },
    {
      "id": "topic-argument-default",
      "topic": "Default arguments",
      "canonical_topic": "argument default",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 1,
        "by_exam": {
          "trial_midterm": 1
        },
        "coverage_count": 1
      },
      "related_topics": [
        "Default arguments",
        "Mutable default argument",
        "default arguments / mutable defaults"
      ],
      "trap_patterns": [
        {
          "pattern": "Mutable default argument",
          "trap": "def f(lst=[]): — the [] is created ONCE at def time and persists across calls. Fix: use None and create inside function",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "trial_midterm",
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-8f250614a1",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Default arguments",
            "explanation": "Default values are part of the function HEADER (not the call). When argument is omitted, the default is used. Keyword args in a call use =. CRITICAL: mutable defaults are evaluated ONCE at def time — never use mutable defaults; use None instead.",
            "code_examples": [
              {
                "description": "Default value",
                "code": "def multiplier(first, second=2):\n    return first * second\nprint(multiplier(3))       # 6 (uses default second=2)\nprint(multiplier(3, 3))    # 9\nprint(multiplier(2, second=3))  # 6"
              },
              {
                "description": "Mutable default BUG",
                "code": "def main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [2, 3] ← BUG: l1 persists!"
              },
              {
                "description": "Mutable default FIX — use None",
                "code": "def main(addition, l1=None):\n    if l1 is None:\n        l1 = []\n    l1 += [addition]\n    return l1\nprint(main(2))  # [2]\nprint(main(3))  # [3]  ← correct"
              }
            ]
          },
          {
            "id": "leq-a9a97c880c",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Mutable default argument",
            "question": "What is the result of:\ndef main(addition, l1=[]):\n    l1.append(addition)\n    return l1\nprint(main(2))\nprint(main(3))",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [
          {
            "id": "exm-72aaa9b4b7",
            "exam_label": "trial_midterm",
            "exam_source": "trial midterm.pdf",
            "year": "2024-2025",
            "number": 13,
            "week": 3,
            "topic": "default arguments / mutable defaults",
            "question": "What is the output of the following code?\n\ndef add_item(item, lst=[]):\n    lst.append(item)\n    return lst\n\nprint(add_item(1))\nprint(add_item(2))\nprint(add_item(3))",
            "code_context": "",
            "options": {
              "A": "[1]\n[2]\n[3]",
              "B": "[1]\n[1, 2]\n[1, 2, 3]",
              "C": "[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]",
              "D": "Error"
            },
            "correct": "B",
            "explanation": "The default list [] is created once when the function is defined and shared across all calls. Each call appends to the same list."
          }
        ],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Default arguments provide a fallback value for a parameter if one isn't supplied when the function is called. The most critical exam trap is using a mutable type (like a list `[]` or dict `{}`) as a default. This mutable default is created only once and shared across all calls, leading to bizarre bugs where calls interfere with each other.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the output after calling the function multiple times with a mutable default argument?",
            "How do you correctly and safely initialize an empty list as a default inside a function?",
            "At what point is the default argument's value evaluated: when the function is defined, or when it's called?",
            "Why does `def my_func(a=1, b):` cause a `SyntaxError`?",
            "If a function is `def f(x, y=2):`, how do you call it providing a value only for `x`?",
            "What is the value of a variable that is assigned the result of a function call?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "The Safe Pattern for Mutable Defaults",
            "code": "def add_item(item, target=None):\n    if target is None:\n        target = []\n    target.append(item)\n    return target",
            "why": "This is the correct, bug-free pattern. A new list is created inside the function every time it's called without a `target`, preventing shared state between calls.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Using Immutable Defaults (Safe)",
            "code": "def greet(name, punctuation=\"!\"):\n    return f\"Hello, {name}{punctuation}\"\n\nprint(greet(\"World\"))\nprint(greet(\"World\", \"...\"))",
            "why": "Immutable types like strings, numbers, and tuples are perfectly safe to use as default arguments because their value cannot be changed in-place.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "The Classic Mutable Default Argument Trap",
            "code": "def add_pet(pet, pet_list=[]):\n    pet_list.append(pet)\n    return pet_list\n\nprint(add_pet(\"dog\"))\nprint(add_pet(\"cat\")) # Unexpected output!",
            "why": "The `pet_list` is created once, when Python first defines the function. The second call appends 'cat' to the *same list* the first call used. Output: `['dog']`, then `['dog', 'cat']`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Non-Default Argument Follows Default",
            "code": "# This code won't even run\ndef create_user(is_admin=False, username):\n    return {\"name\": username, \"admin\": is_admin}",
            "why": "This is a `SyntaxError`. In a function definition, once you have a parameter with a default value, all subsequent parameters must also have default values.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Default arguments are evaluated once when the function is defined, not on each function call, potentially leading to persistent state for mutable defaults.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Avoid mutable default arguments (e.g., `list`, `dict`); instead, use `None` as a default and initialize the mutable object inside the function body.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def bad(acc=[]):\n    acc.append(1)\n    return acc\n\ndef good(acc=None):\n    if acc is None:\n        acc = []\n    acc.append(1)\n    return acc",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Positional arguments without defaults must precede arguments with defaults in a function signature; `def f(a=1, b):` causes a `SyntaxError`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(a, b=0):\n    return a + b\n\nf(1, b=2)      # valid\n# f(a=1, 2)    # SyntaxError",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Functions can be called using positional arguments, keyword arguments (`param=value`), or a mix; keyword arguments must follow all positional arguments.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(a, b=0):\n    return a + b\n\nf(1, b=2)      # valid\n# f(a=1, 2)    # SyntaxError",
                "id": "kp-4-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "exm-72aaa9b4b7",
          "lec-8f250614a1"
        ]
      }
    },
    {
      "id": "topic-arithmetic",
      "topic": "arithmetic_operators",
      "canonical_topic": "arithmetic",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Arithmetic operators",
        "arithmetic_operators"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-5eee5b396a",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Arithmetic operators",
            "explanation": "a+b, a-b, a*b: standard. a/b: always returns float. a//b: floor division (highest integer <= result). a%b: remainder. a**b: exponentiation. NOTE: ^ is NOT exponentiation in Python (it is XOR). (a//b)*b + a%b == a always.",
            "code_examples": [
              {
                "description": "Floor division and modulo",
                "code": "print(5 // 3, 5 % 3)    # 1 2\nprint(-5 // 3, -5 % 3)  # -2 1\nprint(5 // 2, 5 % 2)    # 2 1\nprint(-5 // 2, -5 % 2)  # -3 1"
              }
            ]
          },
          {
            "id": "leq-e9c4f96514",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Arithmetic operators",
            "question": "What is the result of (a//b)*b + a%b?",
            "options": {},
            "correct": null,
            "explanation": ""
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-47b9ce3817",
            "week": 1,
            "cell_index": 41,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(4 + 3)\nprint(4 - 3)\nprint(4 * 3)\nprint(4 / 3)\nprint(4 / 2)\nprint(4 ** 3)",
            "outputs": [
              "7\n1\n12\n1.3333333333333333\n2.0\n64"
            ]
          },
          {
            "id": "nb-f3f249a2d7",
            "week": 1,
            "cell_index": 42,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(5 // 3, 5 % 3)\nprint(-5 // 3, -5 % 3)\nprint(5 // 2, 5 % 2)\nprint(-5 // 2, -5 % 2)",
            "outputs": [
              "1 2\n-2 1\n2 1\n-3 1"
            ]
          },
          {
            "id": "nb-ff27913d20",
            "week": 1,
            "cell_index": 43,
            "cell_type": "code",
            "topic": "arithmetic_operators",
            "source": "print(5//2, 5%2)",
            "outputs": [
              "2 1"
            ]
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Python's arithmetic operators are straightforward, but exams often test edge cases. The key distinctions are between `/` (float division, always returns a float) and `//` (floor division, returns an integer). Also, be very careful with floor division and modulo (`%`) on negative numbers, as the results can be counterintuitive.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type and value of `10 / 5`? (float, `2.0`)",
            "What is the result of a negative floor division, like `-9 // 4`? (-3)",
            "What is the operator for exponentiation in Python? (`**`, not `^`)",
            "What is the result of `5 % 2` versus `-5 % 2`?",
            "Does Python follow PEMDAS/BODMAS for operator precedence?",
            "What is the result of `2 + 3 * 4`?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Float vs. Floor Division",
            "code": "float_div = 10 / 4   # Result is 2.5\nfloor_div = 10 // 4  # Result is 2\nprint(f\"Float: {float_div}, Floor: {floor_div}\")",
            "why": "This demonstrates the core difference: `/` performs standard division and always returns a float, while `//` performs integer division, discarding the remainder.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Exponentiation with `**`",
            "code": "base = 2\nexponent = 3\n# Correct way to calculate 2 to the power of 3\nresult = base ** exponent\nprint(result) # Output is 8",
            "why": "The correct operator for raising a number to a power in Python is `**`. This is a common point of confusion for beginners from other languages.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using `^` for Exponents",
            "code": "# Incorrectly trying to calculate 2 to the power of 3\nresult = 2 ^ 3\nprint(result) # Output is 1",
            "why": "A frequent mistake. In Python, `^` is the bitwise XOR operator, not exponentiation. `2` (binary `10`) XOR `3` (binary `11`) results in `1` (binary `01`).",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Misunderstanding Negative Floor Division",
            "code": "# Student expects -2\nresult = -9 // 4\nprint(result)",
            "why": "Floor division always rounds down (towards negative infinity). Since `-9 / 4` is `-2.25`, rounding down results in `-3`, not `-2` (which would be truncation).",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`/` (division) always returns a float; `//` (floor division) returns the largest integer less than or equal to the result of division.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Division operators",
                "text": "",
                "table": {
                  "headers": [
                    "Operator",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "`/`",
                      "True division (float result)"
                    ],
                    [
                      "`//`",
                      "Floor division (round down)"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`a % b` (modulo) returns the remainder of the division; its sign matches the divisor `b`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "Python uses `**` for exponentiation; `^` is the bitwise XOR operator, not exponentiation.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "For floor division with negative numbers, `//` truncates towards negative infinity (e.g., `-5 // 3` evaluates to -2).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(5 // 3)     # 1\nprint(-5 // 3)    # -2  (toward negative infinity)",
                "id": "kp-4-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-5eee5b396a",
          "nb-f3f249a2d7",
          "nb-47b9ce3817"
        ]
      }
    },
    {
      "id": "topic-boolean",
      "topic": "Boolean operators",
      "canonical_topic": "boolean",
      "weeks": [
        1,
        2
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Boolean operators",
        "Conditions and boolean operators — precedence"
      ],
      "trap_patterns": [
        {
          "pattern": "Boolean operator precedence: not > and > or",
          "trap": "a==1 or a==2 and b==1 or b==2 is evaluated as a==1 or (a==2 and b==1) or b==2",
          "weeks": [
            1,
            2
          ],
          "appears_in_exams": [
            "midterm_2023",
            "extra_practice"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-2f353ad9dc",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Boolean operators",
            "explanation": "x and y: True only if both True. x or y: False only if both False. not x: inverts. NOTE: && and || are Python operators but do something different (bitwise). Precedence: 'not' first, then 'and', then 'or'. Use parentheses to avoid confusion.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\nprint(a==1 or a==2 and b==1 or b==2)  # True (WRONG: and binds tighter)\nprint((a==1 or a==2) and (b==1 or b==2))  # False (CORRECT)"
              }
            ]
          },
          {
            "id": "lec-d7fa16c039",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Conditions and boolean operators — precedence",
            "explanation": "Precedence (high to low): comparisons → not → and → or. Use parentheses to be explicit. 'in' checks membership in sequence/set/dict-keys.",
            "code_examples": [
              {
                "description": "Precedence trap",
                "code": "a=1; b=3\n# WRONG: Python evaluates 'and' before 'or'\nprint(a==1 or a==2 and b==1 or b==2)     # True (unexpected)\n# CORRECT: use brackets\nprint((a==1 or a==2) and (b==1 or b==2)) # False"
              },
              {
                "description": "Inclusion check — 'in' operator",
                "code": "print(1 in [1,2,3])    # True\nprint(1 in (1,2,3))    # True\nprint('1' in '123')    # True (substring)\nprint(1 in {1:4, 2:3}) # True (checks keys)\nprint(4 in {1:4, 2:3}) # False (4 is value, not key)\nprint(1 in {1,2,3})    # True"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Boolean operators (`and`, `or`, `not`) are used to combine `True`/`False` values. Remember the operator precedence to resolve un-parenthesized expressions: `not` is evaluated first, then `and`, then `or`. Exam questions often test this precedence; when in doubt, add parentheses to force a specific order of evaluation.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the result of a complex boolean expression?",
            "Add parentheses to show how Python evaluates this expression.",
            "Why does this expression return an unexpected `True` or `False`?",
            "Is `x or y and z` evaluated as `(x or y) and z` or `x or (y and z)`?",
            "What is the difference between `&` and `and`?",
            "Simplify a nested boolean expression to its final value."
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Correct Precedence with `not`",
            "code": "a = True\nb = False\nprint(not b and a) # Evaluates to True",
            "why": "`not b` is evaluated first (`True`), resulting in `True and True`, which is `True`. This follows the `not` > `and` precedence rule.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Forcing Order with Parentheses",
            "code": "print(False or (True and True))",
            "why": "The parentheses force `True and True` to be evaluated first, resulting in `True`. The expression becomes `False or True`, which correctly evaluates to `True`.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Ignoring `and` Precedence",
            "code": "a = True\nb = False\nc = False\nprint(a or b and c)",
            "why": "A common mistake is reading left-to-right, calculating `a or b` as `True`, then `True and c` as `False`. The correct evaluation is `a or (b and c)`, which is `True or False`, resulting in `True`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Using Bitwise Operators for Logic",
            "code": "a = True\nb = False\nprint(a | b)",
            "why": "While this may produce the expected boolean result in some cases (`True`), using bitwise operators (`|`, `&`) instead of logical operators (`or`, `and`) is incorrect practice and can lead to unexpected behavior, especia…",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Boolean operator precedence: `not` (highest), then `and`, then `or` (lowest).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "expr = True or False and False\nprint(expr)  # True (`and` evaluated before `or`)\nprint((True or False) and False)  # False",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`and` operator returns the first Falsy operand encountered, or the last operand if all are Truthy.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "`or` operator returns the first Truthy operand encountered, or the last operand if all are Falsy.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Short-circuit return value",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Returns"
                  ],
                  "rows": [
                    [
                      "`A and B`",
                      "First falsy operand, else `B`"
                    ],
                    [
                      "`A or B`",
                      "First truthy operand, else `B`"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(0 and 5)      # 0\nprint(3 and 5)      # 5\nprint('' or 'x')    # 'x'",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Use parentheses `()` to explicitly define the order of evaluation in complex boolean expressions.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-5",
            "text": "Python uses `and`, `or`, `not` for logical operations; `&`, `|`, `~` are bitwise operators.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-6",
            "text": "`in` operator checks for membership (e.g., `element in list`, `key in dict`).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-2f353ad9dc",
          "lec-d7fa16c039"
        ]
      }
    },
    {
      "id": "topic-comparison",
      "topic": "comparison_operators",
      "canonical_topic": "comparison",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Comparison operators",
        "comparison_operators"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-f1ca9d62f9",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Comparison operators",
            "explanation": "==, !=, >, <, >=, <=. Always return True or False. Comparing floats can be tricky: 1.1+2.2 != 3.3 in Python due to floating-point precision. String/tuple/list comparison is element-by-element left to right; first differing element decides; if equal length and no differences, they are equal; shorter sequence is 'less than' longer if all elements match up to shorter length.",
            "code_examples": [
              {
                "description": "Float precision issue",
                "code": "print(1.1 + 2.2 == 3.3)  # False"
              },
              {
                "description": "List/tuple comparison",
                "code": "print([1, 2, 3] < [1, 2, 3, 0])  # True (shorter is less)\nprint([2] < [1, 2, 3, 0])        # False (2 > 1 at index 0)"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-05300174f2",
            "week": 1,
            "cell_index": 46,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print(3 == 2)\nprint(3 > 3)\nprint(3 < 4)\nprint(3 >= 2)\nprint(3 <= 3)\nprint(3 != 4)",
            "outputs": []
          },
          {
            "id": "nb-71e169e949",
            "week": 1,
            "cell_index": 47,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print(1.1, 2.2, 1.1 + 2.2 == 3.3)",
            "outputs": []
          },
          {
            "id": "nb-ee7017d81c",
            "week": 1,
            "cell_index": 50,
            "cell_type": "code",
            "topic": "comparison_operators",
            "source": "print([1, 2, 3] < [1, 2, 3, 0])\nprint([2] < [1, 2, 3, 0])\nprint((1, 2, 3, 0) < (1, 2, 3))\nprint((2,) >= (1, 2, 3, 0))\nprint('abc' < 'abc ')\nprint('b' < 'abc ')\nprint('123' < '123 ')\nprint('2' < '123 ')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Comparison operators (`==`, `!=`, `>`, `<`, `>=`, `<=`) compare two values and always return a boolean `True` or `False`. Be cautious when comparing floating-point numbers due to precision issues (e.g., `0.1 + 0.2` is not exactly `0.3`). When comparing sequences like lists or strings, Python compares them element by element from left to right until a difference is found.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Why does `0.1 + 0.2 == 0.3` evaluate to `False`?",
            "Which list is considered 'less than' the other and why?",
            "What is the result of comparing two strings?",
            "What is the difference between the `is` and `==` operators?",
            "Will this comparison result in a `TypeError`?",
            "What is the output of a chained comparison like `1 < x < 10`?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "List Comparison",
            "code": "list1 = [1, 2, 4]\nlist2 = [1, 2, 5]\nprint(list1 < list2)",
            "why": "The comparison is `True`. Python compares elements at index 0 (equal), then index 1 (equal), then index 2. Since `4 < 5`, `list1` is less than `list2`.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Chained Comparison",
            "code": "x = 5\nprint(0 < x <= 5)",
            "why": "This is `True`. Python allows chaining comparisons, which is a concise way of writing `(0 < x) and (x <= 5)`. This is a common and useful feature.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Floating-Point Precision Trap",
            "code": "a = 0.1 + 0.2\nb = 0.3\nprint(a == b)",
            "why": "This prints `False`. Due to how computers store floating-point numbers, `0.1 + 0.2` results in a value that is extremely close, but not exactly, `0.3`, causing the equality check to fail.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Assignment vs. Comparison",
            "code": "x = 5\nif x = 5:\n  print(\"Equal\")",
            "why": "This is a `SyntaxError`. The `=` operator is for assignment. The `==` operator must be used for comparison within an `if` statement. This is a very common mistake for beginners.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) always yield `True` or `False`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "Floating-point arithmetic can lead to imprecision; `0.1 + 0.2 == 0.3` typically evaluates to `False`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "Sequence comparisons (lists, tuples, strings) are lexicographical, element-by-element from left to right.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "In sequence comparison, if initial elements are equal, the shorter sequence is considered 'less than' the longer one.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print([1, 2] < [1, 2, 0])   # True\nprint((1, 3) > (1, 2, 9))   # True (compares at first differing element)",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Chained comparisons like `a < b < c` are evaluated as `(a < b) and (b < c)`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 3\nprint(1 < x < 5)          # True\nprint((1 < x) and (x < 5))  # equivalent",
                "id": "kp-5-d1"
              }
            ]
          },
          {
            "id": "kp-6",
            "text": "`==` compares values; `is` compares object identities (memory addresses).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-f1ca9d62f9",
          "nb-71e169e949",
          "nb-ee7017d81c"
        ]
      }
    },
    {
      "id": "topic-exam",
      "topic": "Exam question types",
      "canonical_topic": "exam",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Exam question types"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-f3fc8a65be",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Exam question types",
            "explanation": "Which code fragment will print the following output? / What will be printed by the following code fragment? / Which code fragment prints the SAME output as...? / One fragment prints different output from the others. / Which correctly solves the problem? Options may include: 'None of the above', 'Both', 'All', 'An error'.",
            "code_examples": []
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "This topic describes the format of exam questions themselves, not a Python concept. Common types include 'What will be printed?', where you trace the code's output, 'Which code produces this output?', where you match code to a result, and 'Which fragment is different?', where you find the outlier among several code blocks. Understanding these formats helps you quickly identify what the question is asking you to do.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "How should I approach a 'What will be printed?' question?",
            "What's a good strategy for 'Which code is different?' questions?",
            "How do I handle questions where multiple options seem correct?",
            "What does it mean to 'trace' a program's execution?",
            "What should I look for in 'Which fragment correctly solves the problem?' questions?",
            "What are common tricks or traps in multiple-choice questions?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Example of: 'What will be printed?'",
            "code": "x = 1\ny = x\nx = 2\nprint(y)",
            "why": "This question type tests your understanding of assignment. You must trace that `y` was assigned the value of `x` (which was 1), and that `y` is not affected when `x` is later reassigned. The answer is 1.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Example of: 'Which is different?'",
            "code": "# A: print(1+2)\n# B: print(3)\n# C: print(4-1)",
            "why": "This question format requires you to evaluate and compare the output of several snippets. A, B, and C all print '3'. If a fourth option printed '4', that would be the different one. It tests if you can spot functional e…",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Misreading 'Solves the problem'",
            "code": "def find_max(nums):\n  return nums[0]\n# Problem: Find the largest number in a list",
            "why": "This code runs without error, but it doesn't correctly solve the stated problem (it only works if the first element is the largest). An exam question might offer this as an option to trap students who don't test the log…",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Ignoring a Stated Constraint",
            "code": "def get_unique(items):\n  return list(set(items))\n# Constraint: Preserve original order.",
            "why": "This function correctly returns unique items, but converting to a set and back does not preserve the original order. If the exam question specified that order must be preserved, this would be an incorrect solution despi…",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Output-tracing workflow: annotate each executed line as `(line -> variable updates -> printed text)`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-1-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "For loop questions, count iterations first: `range(n)` executes `n` times with values `0..n-1`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "For nested loops, total inner executions are cumulative/multiplicative; compute counts before evaluating output.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "Type-check trap: `'3' + 2` raises `TypeError`, while `'3' * 2` repeats to `'33'`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "explanation",
                "title": "Optional trace template",
                "text": "Create a tiny table with columns `(line, variable state, output)` and fill it step by step.",
                "id": "kp-4-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "x = 0\nfor i in range(3):\n    x += i\nprint(x)\n# Trace rows: i=0 -> x=0, i=1 -> x=1, i=2 -> x=3",
                "id": "kp-4-d2"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "Method trap: in-place methods (e.g., `list.sort()`) return `None`; value-returning alternatives (e.g., `sorted(lst)`) return new objects.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "In-place vs new object",
                "text": "",
                "table": {
                  "headers": [
                    "Operation",
                    "Mutates original?",
                    "Return value"
                  ],
                  "rows": [
                    [
                      "`lst.sort()`",
                      "Yes",
                      "`None`"
                    ],
                    [
                      "`sorted(lst)`",
                      "No",
                      "New sorted list"
                    ]
                  ]
                },
                "id": "kp-5-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "lst = [3, 1, 2]\nresult = lst.sort()      # lst becomes [1, 2, 3]\nprint(result)            # None\nnew_lst = sorted(lst)    # new list object",
                "id": "kp-5-d2"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-f3fc8a65be"
        ]
      }
    },
    {
      "id": "topic-importing-package",
      "topic": "imports",
      "canonical_topic": "importing package",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Importing packages",
        "imports"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-7df6a75078",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Importing packages",
            "explanation": "Multiple import styles. 'import X' makes X available. 'import X as Y' renames. 'from X import Z' brings Z directly into namespace. 'from X import Z as W' renames. Once you use 'as', the original name is no longer accessible.",
            "code_examples": [
              {
                "description": "Import styles",
                "code": "import numpy\nnumpy.random.randint(1, 10)  # works\n\nimport numpy as np\nnp.random.randint(1, 10)     # works\nnumpy.random.randint(1, 10)  # ERROR\n\nfrom numpy.random import randint\nrandint(1, 10)               # works\n\nfrom numpy.random import randint as rnd\nrnd(1, 10)                   # works\nrandint(1, 10)               # ERROR"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-85bb01e6b1",
            "week": 1,
            "cell_index": 99,
            "cell_type": "code",
            "topic": "imports",
            "source": "# In this cell we create a function that deletes all the thus far created names in your program, \n# we need such a function else you cannot run some cells more times and getting the same result all the time when testing the import statements \nimport sys\ndef clear_names():\n    message = ''\n    for n in sorted(globals()): \n        if n[0]!='_' and n not in [\"sys\", \"clear_names\"]:\n            message += f\"{n}, \"\n            delattr(sys.modules[__name__], n)",
            "outputs": []
          },
          {
            "id": "nb-194b84a11d",
            "week": 1,
            "cell_index": 100,
            "cell_type": "code",
            "topic": "imports",
            "source": "%%writefile extension.py\n# In this cell we create a python file and write that to the hard disk (either of your computer or to the cloud depending where you run your code.\n# We will import this file to show how to import the names of objects \n# into your Python program\nYEAR = 2025\ndef create_absolute_year(x):\n    return YEAR + x",
            "outputs": [
              "Overwriting extension.py"
            ]
          },
          {
            "id": "nb-6ea8069d6e",
            "week": 1,
            "cell_index": 101,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(Exception)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)\n\nimport extension\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "<class 'Exception'>\nname 'extension' is not defined\nname 'YEAR' is not defined\n2025"
            ]
          },
          {
            "id": "nb-2709817f6f",
            "week": 1,
            "cell_index": 102,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2025\nname 'extension' is not defined"
            ]
          },
          {
            "id": "nb-364b083d05",
            "week": 1,
            "cell_index": 103,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nfrom extension import create_absolute_year\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2026\nname 'YEAR' is not defined"
            ]
          },
          {
            "id": "nb-ffb2c584b7",
            "week": 1,
            "cell_index": 104,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nfrom extension import create_absolute_year as cay\ntry:\n    print(create_absolute_year(1))\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(cay(1))\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "name 'create_absolute_year' is not defined\n2026"
            ]
          },
          {
            "id": "nb-8de680a61a",
            "week": 1,
            "cell_index": 105,
            "cell_type": "code",
            "topic": "imports",
            "source": "clear_names()\n\nimport extension\nimport extension as ex\ntry:\n    print(ex.YEAR)\nexcept Exception as e:\n    print(e)\n\ntry:\n    print(extension.YEAR)\nexcept Exception as e:\n    print(e)",
            "outputs": [
              "2025\n2025"
            ]
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "Importing brings code from other files into your program's memory so you can use it. The `import` style determines the name you must use to access the code. `import math` means you use `math.pi`, while `from math import pi` means you just use `pi`. Using an alias with `as` makes the original name unavailable.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "After `import numpy as np`, how do you access the `array` function?",
            "Why am I getting a `NameError` even though I imported the module?",
            "What is the difference between `import math` and `from math import *`?",
            "If you `import module as m`, can you still use `module.function()`? (No)",
            "After `from module import func`, what is the correct way to call `func`?",
            "Will changing an imported variable affect the original module?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Importing a Module with an Alias",
            "code": "import random as rd\n\n# Call function using the alias 'rd'\nnum = rd.randint(1, 10)\nprint(num)",
            "why": "Using `as` creates a shorter alias (`rd`) for the module `random`. All functions from the module must now be accessed through this alias.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Importing a Specific Name from a Module",
            "code": "from math import pi\n\n# The name 'pi' is now directly available\narea = pi * (5 ** 2)\nprint(area)",
            "why": "`from...import` brings the specific name (`pi`) into the current scope. It can be used directly without referencing the `math` module.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using Original Name After Aliasing",
            "code": "import random as rd\n\n# This will fail\nnum = random.randint(1, 10)\n# NameError: name 'random' is not defined",
            "why": "Once a module is imported with an alias (`as rd`), the original name (`random`) is no longer defined in the program's scope. You must use the alias.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Using Module Prefix After `from...import`",
            "code": "from math import pi\n\n# This will fail\narea = math.pi * (5 ** 2)\n# NameError: name 'math' is not defined",
            "why": "`from math import pi` only imports the name `pi`, not the `math` module itself. `pi` is now a global variable and `math` is not recognized.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`import module` requires access via `module.name`; `import module as alias` requires `alias.name`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "After `import module as alias`, use `alias.name`; `module.name` works only if `module` was also imported under its original name.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "id": "kp-2-det-1",
                "kind": "example",
                "title": "Optional code example",
                "code": "import math as m\nprint(m.sqrt(9))  # 3.0\n# math.sqrt(9) would fail unless `import math` was also executed"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`from module import name` allows direct access via `name` (e.g., `func()`), not `module.name`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "`from module import name as alias` brings `name` into the namespace as `alias`; access via `alias`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-5",
            "text": "Avoid `from module import *` as it pollutes the current namespace and can lead to name collisions.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-7df6a75078",
          "nb-2709817f6f",
          "nb-364b083d05",
          "nb-ffb2c584b7"
        ]
      }
    },
    {
      "id": "topic-execution-python",
      "topic": "Python execution model",
      "canonical_topic": "execution python",
      "weeks": [
        1
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Python execution model"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-e91df37af4",
            "week": 1,
            "source": "Lecture Week 1",
            "topic": "Python execution model",
            "explanation": "Python script is translated line by line into byte code, then byte code is translated into machine code. Writing code must be precise; ambiguities that humans handle fine will cause Python errors.",
            "code_examples": []
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Python executes code sequentially, from the top of the file to the bottom, one line at a time. A variable or function must be defined before it can be used. If Python encounters an error on any line, the program will immediately stop, and any code after the error-causing line will not be executed.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the final output of this script?",
            "Why did the program stop executing?",
            "If a `NameError` happens on line 3, is line 2 executed? (Yes)",
            "If an error happens on line 3, is line 4 executed? (No)",
            "What is a `NameError` and why does it happen?",
            "Can I call a function before it is defined? (No)"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Simple Sequential Execution",
            "code": "x = 10\ny = 20\nx = x + y\nprint(x)\n# Output: 30",
            "why": "Python executes each line in order. By the time `print(x)` is reached, `x` has been defined, assigned 10, and then updated to 30.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Function Definition vs. Call",
            "code": "def say_hello():\n    print('Hello')\n\nprint('Start')\nsay_hello()\nprint('End')\n# Output: Start, Hello, End",
            "why": "Defining a function does not run its code. Python notes the definition, prints 'Start', executes the function body when `say_hello()` is called, and then continues.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using a Variable Before It's Defined",
            "code": "print(price)\nprice = 100\n# NameError: name 'price' is not defined",
            "why": "The script executes top-to-bottom. When `print(price)` is reached on the first line, the variable `price` has not yet been created in memory, causing a `NameError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Error Halting Execution",
            "code": "a = 10\nb = 0\nprint('Calculating...')\nc = a / b # Error occurs here\nprint('Done!') # This line is never reached",
            "why": "The program successfully executes the lines before the error. However, the `ZeroDivisionError` on the fourth line halts the script immediately. The final `print` statement is never run.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "Execution order is sequential: `line_n` must finish before Python runs `line_n+1`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "An uncaught exception (`NameError`, `TypeError`, etc.) stops execution immediately; later lines do not run.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print('A')\n1 / 0              # ZeroDivisionError\nprint('B')         # never runs",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`def name(...):` creates a function object now; the function body executes only when `name(...)` is called.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-4",
            "text": "Name resolution follows LEGB order: Local -> Enclosing -> Global -> Builtins.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "LEGB order",
                "text": "",
                "table": {
                  "headers": [
                    "Lookup order",
                    "Meaning"
                  ],
                  "rows": [
                    [
                      "Local",
                      "Current function scope"
                    ],
                    [
                      "Enclosing",
                      "Nearest outer function scope"
                    ],
                    [
                      "Global",
                      "Module-level scope"
                    ],
                    [
                      "Builtins",
                      "Python built-in names"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`if`/`while` evaluate the condition before running the body; a falsy condition skips the body.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-e91df37af4"
        ]
      }
    },
    {
      "id": "topic-walru",
      "topic": "walrus_operator",
      "canonical_topic": "= walru",
      "weeks": [
        2
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Walrus operator :=",
        "walrus_operator"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-aa87baadd4",
            "week": 2,
            "source": "Lecture Week 2",
            "topic": "Walrus operator :=",
            "explanation": "Introduced in Python 3.8. Assigns AND evaluates to a value (unlike = which is a statement). Useful in while conditions to assign and test at once.",
            "code_examples": [
              {
                "description": "Walrus in while loop",
                "code": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100:\n    if number % 2 == 1:\n        total += number\nprint(total)"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-43d9c8aa9a",
            "week": 2,
            "cell_index": 98,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "total = 0\nwhile (number := int(input('give a number, or 100 to stop '))) != 100 :\n    if number % 2 == 1:\n        total += number\nprint (f'The sum of all the uneven numbers you entered is {total}')",
            "outputs": []
          },
          {
            "id": "nb-d7e9f74017",
            "week": 2,
            "cell_index": 100,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "from random import randint\na = randint(0,5)\nprint(a)\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          },
          {
            "id": "nb-d4e293f6ac",
            "week": 2,
            "cell_index": 101,
            "cell_type": "code",
            "topic": "walrus_operator",
            "source": "from random import randint\nprint(a := randint(0,5))\nif a > 1 and a < 5:\n    print('a between 2 and 5')\nelse: \n    print('a not between 2 and 5')",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The walrus operator `:=` both assigns a value to a variable and evaluates to that same value within an expression. It's most useful for simplifying `while` loops by allowing you to get a value (e.g., from `input()`) and check it in the same line. Unlike `=`, `:=` is an expression, not a statement.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "Rewrite a traditional `while` loop using the walrus operator.",
            "What is the main difference between `=` and `:=`?",
            "In which situations is the walrus operator most useful?",
            "What is the value of the variable after a `while` loop using `:=` has finished?",
            "Explain what `if (x := f()) > 10:` does.",
            "Is `x := 5` a valid standalone statement? (Yes)"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Simplify a while loop with user input",
            "code": "numbers = []\nwhile (line := input('Enter a number (or quit): ')) != 'quit':\n    numbers.append(int(line))\nprint(sum(numbers))",
            "why": "This is the classic use case. The `input()` result is assigned to `line` and `line` is immediately compared to 'quit' in the loop's condition, making the code more concise.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Use and test a value in an if statement",
            "code": "def get_len(text):\n    return len(text)\n\nsample = 'Python'\nif (n := get_len(sample)) > 5:\n    print(f'Text is too long: {n} chars')",
            "why": "The walrus operator captures the return value of `get_len(sample)` into `n`. This allows the code to both check if it's greater than 5 and use the value `n` in the print statement without calling the function twice.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Using assignment operator (=) in a condition",
            "code": "while x = 5:\n    print('This will not work')\n\n# SyntaxError: invalid syntax",
            "why": "This is a `SyntaxError` because the standard assignment operator `=` is a statement, not an expression, and cannot be used as a condition in a `while` or `if` statement.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Misunderstanding operator precedence",
            "code": "data = [1, 2, 3]\nif x := len(data) > 2:\n    print(f'Value of x is {x}')\n\n# Value of x is True",
            "why": "The comparison `len(data) > 2` is evaluated first (to `True`), and then this boolean result `True` is assigned to `x`. The correct way to assign the length is `if (x := len(data)) > 2:`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The walrus operator `:=` (Python 3.8+) assigns a value to a variable and simultaneously evaluates to that value.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `:=` within `while` loop conditions to assign input to a variable and test it in a single concise expression (e.g., `while (var := input()) != 'stop':`).",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "The assignment operator `=` is a statement and does not return a value, unlike the walrus operator `:=` which allows assignment within an expression.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "The walrus operator can be used within an `if` condition to assign a value and immediately evaluate it, as in `if (x := f()) > 10:`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "`x := 5` is a valid standalone statement.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "while (line := input().strip()) != 'stop':\n    print(line)\n# assigns and checks in one expression",
                "id": "kp-5-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-aa87baadd4",
          "nb-43d9c8aa9a",
          "nb-d4e293f6ac"
        ]
      }
    },
    {
      "id": "topic-args-argument-number-positional-star-undefined",
      "topic": "*args — undefined number of positional arguments",
      "canonical_topic": "args argument number positional star undefined —",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "*args — undefined number of positional arguments"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-db6665e15a",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "*args — undefined number of positional arguments",
            "explanation": "Prefixing a parameter with * makes Python collect all extra positional arguments into a tuple named args. Can mix with defined parameters: def f(n1, n2, *args) — Python fills n1,n2 first then collects remainder into args.",
            "code_examples": [
              {
                "description": "*args usage",
                "code": "def adder(*args):\n    result = 0\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
              },
              {
                "description": "Mix defined and *args",
                "code": "def adder(n1, n2, *args):\n    result = n1 + n2\n    for number in args:\n        result += number\n    return result\nprint(adder(1, 2, 3, 4, 5))  # 15"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "In a function definition, `*args` collects an indefinite number of positional arguments into a tuple. This allows you to create flexible functions that can accept any number of inputs. When analyzing code, determine which arguments are assigned to regular parameters and which are gathered into the `args` tuple.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type of the `args` variable inside the function? (A tuple)",
            "How do you pass a list of values to a function that accepts `*args`? (e.g., `my_func(*my_list)`)",
            "Can a function have both regular parameters and `*args`? (Yes, regular ones come first)",
            "What is the difference between `*args` and `**kwargs`?",
            "What is the value of `args` if the function is called with no extra arguments? (An empty tuple)",
            "Can you add an item to the `args` tuple inside the function? (No, tuples are immutable)"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Function to sum any number of arguments",
            "code": "def sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3)) # 6",
            "why": "This correctly uses `*numbers` to capture all positional arguments (1, 2, 3) into a tuple named `numbers`. The function then iterates over this tuple to calculate the sum.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Mixing regular parameters and *args",
            "code": "def multiply_first(multiplier, *numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total * multiplier\n\nprint(multiply_first(10, 1, 2, 3)) # 60",
            "why": "Python correctly assigns the first argument `10` to `multiplier`, and then collects the remaining positional arguments `(1, 2, 3)` into the `numbers` tuple.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Trying to modify the args tuple",
            "code": "def process_data(*args):\n    args.append(100)\n    # AttributeError: 'tuple' object has no attribute 'append'\n    return sum(args)\n\nprocess_data(10, 20)",
            "why": "The `*args` syntax always creates a tuple, not a list. Tuples are immutable and do not have an `.append()` method, so this code will raise an `AttributeError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Wrong parameter order",
            "code": "def my_func(*args, regular_param):\n    pass\n\n# SyntaxError: invalid syntax",
            "why": "Standard positional parameters cannot follow `*args`. Any parameter after `*args` must be a keyword-only argument. The correct order is `def my_func(regular_param, *args):`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "The `*parameter` syntax collects an undefined number of positional arguments into a `tuple` within the function.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-2",
            "text": "When using `*args`, regular positional arguments are assigned first, then remaining arguments are gathered into the `*args` tuple.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(*args):\n    print(type(args).__name__, args)\n\nf(1, 2, 3)  # tuple (1, 2, 3)",
                "id": "kp-2-d1"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "Calling `func(*my_list)` unpacks the elements of `my_list` as individual positional arguments to `func`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "nums = [1, 2, 3]\nprint(*nums)  # 1 2 3\n\ndef add(a, b, c):\n    return a + b + c\nprint(add(*nums))  # 6",
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`*args` is always a `tuple`, meaning its contents are immutable and cannot be changed inside the function.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(*args):\n    print(type(args).__name__, args)\n\nf(1, 2, 3)  # tuple (1, 2, 3)",
                "id": "kp-4-d1"
              }
            ]
          },
          {
            "id": "kp-5",
            "text": "If no extra positional arguments are provided, `*args` within the function will be an empty tuple `()`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "def f(*args):\n    print(type(args).__name__, args)\n\nf(1, 2, 3)  # tuple (1, 2, 3)",
                "id": "kp-5-d1"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-db6665e15a"
        ]
      }
    },
    {
      "id": "topic-keyword-pass",
      "topic": "pass",
      "canonical_topic": "keyword pass",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "pass",
        "pass keyword"
      ],
      "trap_patterns": [],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-242c6fa7e5",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "pass keyword",
            "explanation": "Does nothing. Used as a placeholder when an indented block is required but you have nothing to put there yet (stub). After a colon you must have an indented block — pass satisfies this.",
            "code_examples": [
              {
                "description": "pass as stub",
                "code": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else:\n        pass  # placeholder — won't cause IndentationError\n    return result"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [
          {
            "id": "nb-b29776646d",
            "week": 3,
            "cell_index": 25,
            "cell_type": "code",
            "topic": "pass",
            "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n    return result\na = adder(1, 2)\nprint(a)",
            "outputs": []
          },
          {
            "id": "nb-d63665c405",
            "week": 3,
            "cell_index": 26,
            "cell_type": "code",
            "topic": "pass",
            "source": "def adder(n1, n2):\n    if type(n1) == int and type(n2) == int:\n        result = n1 + n2\n    else: # What to do when inputs are no integers\n        pass\n    return result\na = adder(1, 2)\nprint(a)",
            "outputs": []
          }
        ],
        "ai_summary": {
          "status": "generated",
          "content": "The `pass` keyword is a null statement; it does nothing when executed. It serves as a placeholder where Python's syntax requires an indented block but you have no code to write yet. Using `pass` prevents an `IndentationError` in empty functions, classes, or conditional branches.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "When is it necessary to use the `pass` keyword?",
            "What is the difference between `pass`, `continue`, and `break`?",
            "What error occurs if you leave a function or `if` statement body empty?",
            "Can `pass` be used as a temporary stub during development?",
            "Does `pass` have any effect on program execution flow or variables?",
            "Is `pass` considered good practice in finished code?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Placeholder in a Function",
            "code": "def process_data(data):\n    # TODO: Implement data processing logic later\n    pass\n\nprocess_data([]) # Runs without error",
            "why": "`pass` correctly acts as a placeholder, allowing the empty function to be defined and called without causing an `IndentationError`.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Ignoring a Condition",
            "code": "for num in range(1, 5):\n    if num % 2 != 0:\n        # We only care about even numbers\n        pass\n    else:\n        print(f'{num} is even')",
            "why": "`pass` is used to explicitly and readably ignore cases you don't want to act on, fulfilling the `if` block's syntax requirement.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Missing Indented Block",
            "code": "def my_function():\n    # Forgetting to add pass or other code\n\n# IndentationError: expected an indented block",
            "why": "Python requires at least one indented statement after a colon (:). Leaving the block empty is a syntax error. `pass` should be used here as a placeholder.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Confusing `pass` with `return`",
            "code": "def check_user(user):\n    if not user:\n        pass\n    return 'User is valid'\n\nprint(check_user(None))",
            "why": "`pass` does nothing and execution continues to the next line. The function will always proceed to `return 'User is valid'`, even if the user is `None`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "`pass` is a null operation; it does nothing and acts as a placeholder where a statement is syntactically required.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "if True:\n    pass   # TODO: fill logic later",
                "id": "kp-1-d1"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "Use `pass` to avoid `IndentationError` when defining empty blocks for functions, classes, `if`/`else`, or loops.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          },
          {
            "id": "kp-3",
            "text": "`break` terminates the enclosing loop; `continue` skips to the next iteration of the loop; `pass` is a no-op.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Loop control quick table",
                "text": "",
                "table": {
                  "headers": [
                    "Keyword",
                    "Effect"
                  ],
                  "rows": [
                    [
                      "`break`",
                      "Exit current loop immediately"
                    ],
                    [
                      "`continue`",
                      "Skip rest of current iteration"
                    ],
                    [
                      "`pass`",
                      "Do nothing (placeholder statement)"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`pass` does not affect program execution flow or variables, serving only to satisfy syntax requirements.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli"
          }
        ],
        "recommended_ids": [
          "lec-242c6fa7e5",
          "nb-d63665c405",
          "nb-b29776646d"
        ]
      }
    },
    {
      "id": "topic-element-single-tuple",
      "topic": "Single-element tuple",
      "canonical_topic": "element single tuple",
      "weeks": [
        3
      ],
      "exam_stats": {
        "total_hits": 0,
        "by_exam": {},
        "coverage_count": 0
      },
      "related_topics": [
        "Single-element tuple"
      ],
      "trap_patterns": [
        {
          "pattern": "Single-element tuple needs trailing comma",
          "trap": "(1) is int, not tuple. (1,) or 1, is a tuple",
          "weeks": [
            3
          ],
          "appears_in_exams": [
            "midterm_2024"
          ]
        }
      ],
      "sections": {
        "lecture_snippets": [
          {
            "id": "lec-240025dd8c",
            "week": 3,
            "source": "Lecture Week 3",
            "topic": "Single-element tuple",
            "explanation": "(1) is NOT a tuple — it's just the integer 1. To create a 1-element tuple: t = (1,) or t = 1,. Neat swap trick: x, y = y, x",
            "code_examples": [
              {
                "description": "1-element tuple gotcha",
                "code": "t1 = (1)\nprint(type(t1) == tuple)  # False\nprint(type(t1) == int)    # True\nt1 = (1,)  # correct 1-element tuple\nt1 = 1,    # also correct\nx, y = y, x  # swap using tuple unpacking"
              }
            ]
          }
        ],
        "exam_questions": [],
        "notebook_snippets": [],
        "ai_summary": {
          "status": "generated",
          "content": "Creating a tuple with only one element is a common exam trap. Using parentheses like `(1)` does not create a tuple; it evaluates to the integer `1`. To create a single-element tuple, you must include a trailing comma after the element, as in `(1,)`.",
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_common_questions": {
          "status": "generated",
          "bullets": [
            "What is the data type of the expression `x = ('hello')`?",
            "How do you correctly define a tuple containing only the integer 5?",
            "Why is the trailing comma essential for single-element tuples?",
            "What is the output of `len((99))`?",
            "Can a single-element tuple be created without using any parentheses?",
            "What happens when you try to loop over `(10)` vs `(10,)`?"
          ],
          "generator": "gemini-cli",
          "model": "gemini-2.5-pro"
        },
        "ai_examples": [
          {
            "id": "ai-example-1",
            "kind": "correct",
            "title": "Correct: With Trailing Comma",
            "code": "my_tuple = (42,)\nprint(type(my_tuple))\n# <class 'tuple'>",
            "why": "The trailing comma after `42` is the correct and essential syntax that tells Python to create a tuple with one element.",
            "status": "generated"
          },
          {
            "id": "ai-example-2",
            "kind": "correct",
            "title": "Correct: Without Parentheses",
            "code": "my_tuple = 42,\nprint(type(my_tuple))\n# <class 'tuple'>",
            "why": "A trailing comma after any expression is sufficient to create a tuple, even without parentheses. This is less common but valid.",
            "status": "generated"
          },
          {
            "id": "ai-example-3",
            "kind": "incorrect",
            "title": "Incorrect: Missing Trailing Comma",
            "code": "not_a_tuple = (99)\nprint(type(not_a_tuple))\n# <class 'int'>",
            "why": "Without a trailing comma, the parentheses are treated as standard grouping operators. The expression evaluates to the integer `99`, not a tuple.",
            "status": "generated"
          },
          {
            "id": "ai-example-4",
            "kind": "incorrect",
            "title": "Incorrect: TypeError on Iteration",
            "code": "my_val = (100)\nfor i in my_val:\n    print(i)\n# TypeError: 'int' object is not iterable",
            "why": "Because `(100)` is just an integer, it cannot be iterated over with a `for` loop. To fix this, it must be defined as a tuple: `(100,)`.",
            "status": "generated"
          }
        ],
        "key_points_to_remember": [
          {
            "id": "kp-1",
            "text": "A single-element tuple requires a trailing comma: `(value,)` or `value,`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-1-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-1-d2"
              }
            ]
          },
          {
            "id": "kp-2",
            "text": "`(value)` without a trailing comma evaluates to `value` itself, not a tuple; e.g., `(5)` is an `int`, not a `tuple`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-2-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-2-d2"
              }
            ]
          },
          {
            "id": "kp-3",
            "text": "`type((5))` is `int`, while `type((5,))` is `tuple`.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-3-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-3-d2"
              }
            ]
          },
          {
            "id": "kp-4",
            "text": "`len((99))` results in a `TypeError` if `99` is not iterable, because `(99)` evaluates to the `int` 99; `len((99,))` returns 1.",
            "status": "generated",
            "model": "gemini-2.5-flash",
            "generator": "gemini-cli",
            "details": [
              {
                "kind": "table",
                "title": "Tuple comma rule",
                "text": "",
                "table": {
                  "headers": [
                    "Expression",
                    "Type/meaning"
                  ],
                  "rows": [
                    [
                      "`(5)`",
                      "`int` value `5`"
                    ],
                    [
                      "`(5,)`",
                      "Single-element `tuple`"
                    ]
                  ]
                },
                "id": "kp-4-d1"
              },
              {
                "kind": "example",
                "title": "Optional code example",
                "text": "",
                "code": "print(type((5)).__name__)    # int\nprint(type((5,)).__name__)   # tuple",
                "id": "kp-4-d2"
              }
            ]
          }
        ],
        "recommended_ids": [
          "lec-240025dd8c"
        ]
      }
    }
  ]
}